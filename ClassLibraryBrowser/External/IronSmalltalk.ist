Smalltalk interchangeVersion: 'IronSmalltalk 1.0'! 

"
Iron Smalltalk Source Code
Filed-Out: 2013-08-04 20:33
Definition: C:\Users\tt\Documents\Visual Studio 2010\Projects\IronSmalltalk\ClassLibraryBrowser\External\SmalltalkSystem.xml
Browser Version: 1.0.0.0
" !  

" Class Definitions " ! 
Class named: 'AbstractArray'
	superclass: 'SequencedCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'AbstractDictionary'
	superclass: 'Collection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'abstractDictionary'! 

Class named: 'AbstractFloat'
	superclass: 'Number'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <floatCharacterization>. Its language element type is implementation defined. The value of this global is equivalent to the value of one of the globals: FloatE , FloatE , or FloatE .'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;floatCharacterization&gt;. Its language element type is implementation defined. The value of this global is equivalent to the value of one of the globals: <CODE>FloatE</CODE> , <CODE>FloatE</CODE> , or <CODE>FloatE</CODE> .'! 

Annotation key: 'ist.defining-protocol'
	value: 'floatCharacterization'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'floatCharacterization'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Float'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'AbstractReadStream'
	superclass: 'AbstractStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'gettableStream'! 

Class named: 'AbstractStream'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'sequencedStream'! 

Class named: 'AbstractString'
	superclass: 'SequencedReadableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'magnitude, readableString'! 

Class named: 'Array'
	superclass: 'AbstractArray'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Array factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <Array>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Array factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;Array&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Array factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Array factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Array'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Object[]'! 

Class named: 'Bag'
	superclass: 'ExtensibleCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Bag factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <Bag>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Bag factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;Bag&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Bag factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Bag factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Bag'! 

Class named: 'BigDecimal'
	superclass: 'ScaledDecimal'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: '_BigDecimal'! 

Class named: 'BigInteger'
	superclass: 'SignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'! 

Class named: 'BlockClosure'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'valuable'! 

Class named: 'Boolean'
	superclass: 'Object'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'This class describes the behavior of the objects that are the values of the reserved identifiers "true" and "false". These objects are identity objects .

Several message specifications include a truth table describing the result of the binary operation implemented by that message. In each table, the value of the receiver is used to locate a row and the value of the argument is used to locate a column, the result being located at the intersection of the row and column.
'! 

Annotation key: 'ist.description'
	value: '<P>This class describes the behavior of the objects that are the values of the reserved identifiers "true" and "false". These objects are <EM>identity objects</EM> .</P>
<P>Several message specifications include a truth table describing the result of the binary operation implemented by that message. In each table, the value of the receiver is used to locate a row and the value of the argument is used to locate a column, the result being located at the intersection of the row and column.</P>'! 

Annotation key: 'ist.defining-protocol'
	value: 'boolean'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'boolean'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Boolean'! 

Class named: 'Byte'
	superclass: 'UnsignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Byte'! 

Class named: 'ByteArray'
	superclass: 'AbstractArray'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <ByteArray factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <ByteArray>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;ByteArray factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;ByteArray&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'ByteArray factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'ByteArray factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'ByteArray'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Byte[]'! 

Class named: 'Character'
	superclass: 'Object'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: 'CharacterConstants'
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object>. Its language element type is unspecified. This global is a factory for for creating or accessing objects that conform to <Character>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object&gt;. Its language element type is unspecified. This global is a factory for for creating or accessing objects that conform to &lt;Character&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Character factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Character factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Character'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Char'! 

Class named: 'Class'
	superclass: 'Object'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'classDescription'! 

Annotation key: 'ist.runtime.native-class' value: 'class'! 

Class named: 'Collection'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'collection factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'collection'! 

Class named: 'CollectionReadStream'
	superclass: 'AbstractReadStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'collectionStream, ReadStream'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'Console'
	superclass: 'NativeObject'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'puttableStream, Transcript'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'CultureInfo'
	superclass: 'NativeObject'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Globalization.CultureInfo'! 

Class named: 'DateTime'
	superclass: 'SimpleDateTime'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.defining-protocol'
	value: 'DateAndTime factory'! 

Annotation key: 'ist.runtime.native-class' value: 'System.DateTimeOffset'! 

Class named: 'DateTimeFormatInfo'
	superclass: 'NativeObject'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Globalization.DateTimeFormatInfo'! 

Class named: 'Decimal'
	superclass: 'ScaledDecimal'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Decimal'! 

Class named: 'Dictionary'
	superclass: 'AbstractDictionary'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Dictionary factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <Dictionary>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Dictionary factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;Dictionary&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Dictionary factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Dictionary factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Dictionary'! 

Class named: 'Duration'
	superclass: 'Magnitude'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Duration factory>. Its language element type is unspecified.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Duration factory&gt;. Its language element type is unspecified.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Duration factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Duration factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Duration'! 

Annotation key: 'ist.runtime.native-class' value: 'System.TimeSpan'! 

Class named: 'DyadicBlock'
	superclass: 'BlockClosure'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'dyadicValuable'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Func`3[[System.Object],[System.Object],[System.Object]]'! 

Class named: 'Enumerable'
	superclass: 'Collection'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'Error'
	superclass: 'Exception'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'A class name. Conforms to the protocol <Error class>. Error must inherit (possibly indirectly) from the class Exception . Instances of this class conform to the protocol <Error>.'! 

Annotation key: 'ist.description'
	value: 'A class name. Conforms to the protocol &lt;Error class&gt;. <CODE>Error</CODE> must inherit (possibly indirectly) from the class <CODE>Exception</CODE> . Instances of this class conform to the protocol &lt;Error&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Error class'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Error class'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Error'! 

Class named: 'Exception'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'messageText tag'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'A class name. Conforms to the protocol <Exception class>. Instances of this class conform to the protocol <Exception>.'! 

Annotation key: 'ist.description'
	value: 'A class name. Conforms to the protocol &lt;Exception class&gt;. Instances of this class conform to the protocol &lt;Exception&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Exception class'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Exception class, exceptionInstantiator, exceptionSelector, exceptionSignaler'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Exception, exceptionBuilder, exceptionDescription, exceptionSignaler, signaledException'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'ExceptionSet'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'exceptionSelector, exceptionSet'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'ExtensibleCollection'
	superclass: 'InitializableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'extensibleCollection'! 

Class named: 'FailedMessage'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'arguments selector'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Represent a message that was sent to an object, but was not understood by that object.'! 

Annotation key: 'ist.description'
	value: 'Represent a message that was sent to an object, but was not understood by that object.'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'failedMessage'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'False'
	superclass: 'Boolean'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.defining-protocol'
	value: 'boolean'! 

Annotation key: 'ist.runtime.native-class' value: 'false'! 

Class named: 'FileStream'
	superclass: 'AbstractReadStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <FileStream factory>. Its program element type is unspecified. This is a factory for collections that conform to <readFileStream> and <writeFileStream>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;FileStream factory&gt;. Its program element type is unspecified. This is a factory for collections that conform to &lt;readFileStream&gt; and &lt;writeFileStream&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'FileStream factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'FileStream factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'FileStream, puttableStream, readFileStream, writeFileStream'! 

Class named: 'FloatD'
	superclass: 'AbstractFloat'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <floatCharacterization>. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the ''d'' floating point literal syntax.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;floatCharacterization&gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the ''d'' floating point literal syntax.'! 

Annotation key: 'ist.defining-protocol'
	value: 'floatCharacterization'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Double'! 

Class named: 'FloatE'
	superclass: 'AbstractFloat'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <floatCharacterization>. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the ''e'' floating point literal syntax.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;floatCharacterization&gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the ''e'' floating point literal syntax.'! 

Annotation key: 'ist.defining-protocol'
	value: 'floatCharacterization'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Single'! 

Class named: 'Fraction'
	superclass: 'Number'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'denominator numerator'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Fraction factory>. Its language element type is implementation defined.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Fraction factory&gt;. Its language element type is implementation defined.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Fraction factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Fraction factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Fraction, rational'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'IdentityDictionary'
	superclass: 'AbstractDictionary'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <IdentityDictionary factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <IdentityDictionary>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;IdentityDictionary factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;IdentityDictionary&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'IdentityDictionary factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'IdentityDictionary factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'IdentityDictionary'! 

Class named: 'ImmutableString'
	superclass: 'AbstractString'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: 'CharacterConstants'
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'String factory'! 

Annotation key: 'ist.runtime.native-class' value: 'string'! 

Class named: 'InitializableCollection'
	superclass: 'Collection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'initializableCollection factory'! 

Class named: 'Int16'
	superclass: 'SignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Int16'! 

Class named: 'Int32'
	superclass: 'SignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Int32'! 

Class named: 'Int64'
	superclass: 'SignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Int64'! 

Class named: 'Integer'
	superclass: 'Number'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object>. Its language element type is unspecified. This global identifies integer objects.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object&gt;. Its language element type is unspecified. This global identifies integer objects.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Object'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'integer, rational'! 

Class named: 'Interval'
	superclass: 'SequencedReadableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'start step stop'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Interval factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <Interval>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Interval factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;Interval&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Interval factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Interval factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Interval'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'Magnitude'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'magnitude'! 

Class named: 'MessageNotUnderstood'
	superclass: 'Error'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'message receiver'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Unspecified language element type. Conforms to the protocol <MessageNotUnderstoodSelector>. Used as an exception selector .'! 

Annotation key: 'ist.description'
	value: 'Unspecified language element type. Conforms to the protocol &lt;MessageNotUnderstoodSelector&gt;. Used as an <EM>exception selector</EM> .'! 

Annotation key: 'ist.defining-protocol'
	value: 'MessageNotUnderstoodSelector'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'MessageNotUnderstoodSelector'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'MessageNotUnderstood'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'MonadicBlock'
	superclass: 'BlockClosure'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'monadicBlock, monadicValuable'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Func`2[[System.Object],[System.Object]]'! 

Class named: 'NativeArray'
	superclass: 'AbstractArray'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'NativeObject'
	superclass: 'Object'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'native'! 

Class named: 'NiladicBlock'
	superclass: 'BlockClosure'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'niladicBlock, niladicValuable'! 

Annotation key: 'ist.runtime.native-class' value: 'System.Func`1[[System.Object]]'! 

Class named: 'Notification'
	superclass: 'Exception'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'A class name. Conforms to the protocol <Notification class>. Notification must inherit (possibly indirectly) from the class Exception . Instances of this class conform to the protocol <Notification>.'! 

Annotation key: 'ist.description'
	value: 'A class name. Conforms to the protocol &lt;Notification class&gt;. <CODE>Notification</CODE> must inherit (possibly indirectly) from the class <CODE>Exception</CODE> . Instances of this class conform to the protocol &lt;Notification&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Notification class'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Notification class'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Notification'! 

Class named: 'Number'
	superclass: 'Magnitude'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: 'one zero'! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object>. Its language element type is unspecified. This global identifies number objects.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object&gt;. Its language element type is unspecified. This global identifies number objects.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Object'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'number'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'NumberFormatInfo'
	superclass: 'NativeObject'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.Globalization.NumberFormatInfo'! 

Class named: 'Object'
	superclass: ''
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object class>. It is a class object and the name of a class definition.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object class&gt;. It is a class object and the name of a class definition.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Object class'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'instantiator, Object class'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Object'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'OrderedCollection'
	superclass: 'SequencedCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <OrderedCollection factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <OrderedCollection>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;OrderedCollection factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;OrderedCollection&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'OrderedCollection factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'OrderedCollection factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'extensibleCollection, OrderedCollection, sequencedContractibleCollection'! 

Class named: 'ReadStream'
	superclass: 'CollectionReadStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <ReadStream factory>. Its language element type is unspecified. This is a factory for streams that conform to <ReadStream>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;ReadStream factory&gt;. Its language element type is unspecified. This is a factory for streams that conform to &lt;ReadStream&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'ReadStream factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'ReadStream factory'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'ReadWriteStream'
	superclass: 'CollectionReadStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <ReadWriteStream factory>. Its language element type is unspecified. This is a factory for streams that conform to <ReadWriteStream>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;ReadWriteStream factory&gt;. Its language element type is unspecified. This is a factory for streams that conform to &lt;ReadWriteStream&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'ReadWriteStream factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'ReadWriteStream factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'puttableStream, ReadWriteStream, WriteStream'! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'SByte'
	superclass: 'SignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.SByte'! 

Class named: 'ScaledDecimal'
	superclass: 'Number'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object>. Its language element type is unspecified. This global identifies scaled decimal objects.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object&gt;. Its language element type is unspecified. This global identifies scaled decimal objects.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Object'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'scaledDecimal'! 

Class named: 'SequencedCollection'
	superclass: 'SequencedReadableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'sequencedCollection'! 

Class named: 'SequencedReadableCollection'
	superclass: 'InitializableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'sequencedReadableCollection'! 

Class named: 'Set'
	superclass: 'ExtensibleCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Set factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <Set>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Set factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;Set&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Set factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Set factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Set'! 

Class named: 'SignedInteger'
	superclass: 'Integer'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'SimpleDateTime'
	superclass: 'Magnitude'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <DateAndTime factory>. Its language element type is unspecified.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;DateAndTime factory&gt;. Its language element type is unspecified.'! 

Annotation key: 'ist.defining-protocol'
	value: 'DateAndTime factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'DateAndTime factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'DateAndTime'! 

Annotation key: 'ist.runtime.native-class' value: 'System.DateTime'! 

Class named: 'SmalltalkRuntime'
	superclass: 'Object'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: '_SmalltalkRuntime'! 

Class named: 'SortedCollection'
	superclass: 'SequencedReadableCollection'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <SortedCollection factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <SortedCollection>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;SortedCollection factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;SortedCollection&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'SortedCollection factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'SortedCollection factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'extensibleCollection, sequencedContractibleCollection, SortedCollection'! 

Class named: 'String'
	superclass: 'AbstractString'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: 'CharacterConstants'
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <String factory>. Its language element type is unspecified. This is a factory and discriminator for collections that conform to <String>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;String factory&gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &lt;String&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'String factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'String factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'sequencedCollection, String'! 

Annotation key: 'ist.runtime.native-class' value: '_SmalltalkString'! 

Class named: 'Symbol'
	superclass: 'AbstractString'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Object>. Its language element type is unspecified. This global identifies objects that conform to the protocol <symbol>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Object&gt;. Its language element type is unspecified. This global identifies objects that conform to the protocol &lt;symbol&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Object'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'selector, symbol'! 

Annotation key: 'ist.runtime.native-class' value: '_Symbol'! 

Class named: 'SystemType'
	superclass: 'NativeObject'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'type'! 

Class named: 'True'
	superclass: 'Boolean'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.defining-protocol'
	value: 'boolean'! 

Annotation key: 'ist.runtime.native-class' value: 'true'! 

Class named: 'UInt16'
	superclass: 'UnsignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.UInt16'! 

Class named: 'UInt32'
	superclass: 'UnsignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.UInt32'! 

Class named: 'UInt64'
	superclass: 'UnsignedInteger'
	indexedInstanceVariables: #'native'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: 'System.UInt64'! 

Class named: 'UndefinedObject'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'nil'! 

Annotation key: 'ist.runtime.native-class' value: 'nil'! 

Class named: 'UnsignedInteger'
	superclass: 'Integer'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'ist.runtime.native-class' value: ''! 

Class named: 'Warning'
	superclass: 'Notification'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'A class name. Conforms to the protocol <Warning class>. Warning must inherit (possibly indirectly) from the class Notification . Instances of this class conform to the protocol <Warning>.'! 

Annotation key: 'ist.description'
	value: 'A class name. Conforms to the protocol &lt;Warning class&gt;. <CODE>Warning</CODE> must inherit (possibly indirectly) from the class <CODE>Notification</CODE> . Instances of this class conform to the protocol &lt;Warning&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Warning class'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'Warning class'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'Warning'! 

Class named: 'WriteStream'
	superclass: 'AbstractStream'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <WriteStream factory >. Its language element type is unspecified. This is a factory for streams that conform to <WriteStream>.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;WriteStream factory &gt;. Its language element type is unspecified. This is a factory for streams that conform to &lt;WriteStream&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'WriteStream factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'WriteStream factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'collectionStream, puttableStream, WriteStream'! 

Class named: 'ZeroDivide'
	superclass: 'Error'
	indexedInstanceVariables: #'none'
	instanceVariableNames: 'dividend'
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

Annotation key: 'comment'
	value: 'Unspecified language element type. Conforms to the protocol <ZeroDivide class>.'! 

Annotation key: 'ist.description'
	value: 'Unspecified language element type. Conforms to the protocol &lt;ZeroDivide class&gt;.'! 

Annotation key: 'ist.defining-protocol'
	value: 'ZeroDivide factory'! 

Annotation key: 'ist.implemented-class-protocols'
	value: 'ZeroDivide factory'! 

Annotation key: 'ist.implemented-instance-protocols'
	value: 'ZeroDivide'! 

Annotation key: 'ist.runtime.native-class' value: ''! 


" Global Definitions " ! 
Global constant: 'DateAndTime'! 

Annotation key: 'ist.implemented-protocols'
	value: 'DateAndTime factory'! 

Global constant: 'Float'! 

Annotation key: 'ist.defining-protocol'
	value: 'floatCharacterization'! 

Annotation key: 'ist.implemented-protocols'
	value: 'floatCharacterization'! 

Global constant: 'FloatQ'! 

Annotation key: 'ist.defining-protocol'
	value: 'floatCharacterization'! 

Annotation key: 'ist.implemented-protocols'
	value: 'floatCharacterization'! 

Global constant: 'Transcript'! 

Annotation key: 'comment'
	value: 'Conforms to the protocol <Transcript>. Its language element type is unspecified. This is a <Transcript> that is always available to output textual messages in an implementtion defined manner.'! 

Annotation key: 'ist.description'
	value: 'Conforms to the protocol &lt;Transcript&gt;. Its language element type is unspecified. This is a &lt;Transcript&gt; that is always available to output textual messages in an implementtion defined manner.'! 

Annotation key: 'ist.defining-protocol'
	value: 'Transcript'! 

Annotation key: 'ist.implemented-protocols'
	value: 'Transcript'! 


" Pool Definitions " ! 
Pool named: 'CharacterConstants'! 

Annotation key: 'comment'
	value: 'Contains characters that are control characters or other characters that are not easyly typed on the keyboard.'! 

Annotation key: 'ist.description'
	value: 'Contains characters that are control characters or other characters that are not easyly typed on the keyboard.'! 

CharacterConstants constant: 'Nul'! 

CharacterConstants constant: 'Soh'! 

CharacterConstants constant: 'Stx'! 

CharacterConstants constant: 'Etx'! 

CharacterConstants constant: 'Eot'! 

CharacterConstants constant: 'Enq'! 

CharacterConstants constant: 'Ack'! 

CharacterConstants constant: 'Bel'! 

CharacterConstants constant: 'Bs'! 

CharacterConstants constant: 'Ht'! 

CharacterConstants constant: 'Lf'! 

CharacterConstants constant: 'Vt'! 

CharacterConstants constant: 'Ff'! 

CharacterConstants constant: 'Cr'! 

CharacterConstants constant: 'So'! 

CharacterConstants constant: 'Si'! 

CharacterConstants constant: 'Dle'! 

CharacterConstants constant: 'Dc1'! 

CharacterConstants constant: 'Dc2'! 

CharacterConstants constant: 'Dc3'! 

CharacterConstants constant: 'Dc4'! 

CharacterConstants constant: 'Nak'! 

CharacterConstants constant: 'Syn'! 

CharacterConstants constant: 'Etb'! 

CharacterConstants constant: 'Can'! 

CharacterConstants constant: 'Em'! 

CharacterConstants constant: 'Sub'! 

CharacterConstants constant: 'Esc'! 

CharacterConstants constant: 'Fs'! 

CharacterConstants constant: 'Gs'! 

CharacterConstants constant: 'Rs'! 

CharacterConstants constant: 'Us'! 

CharacterConstants constant: 'Tab'! 

CharacterConstants constant: 'VerticalTab'! 

CharacterConstants constant: 'Backspace'! 

CharacterConstants constant: 'Bell'! 

CharacterConstants constant: 'Null'! 

CharacterConstants constant: 'Space'! 

CharacterConstants constant: 'Del'! 


" AbstractArray Class Methods " ! 

" AbstractArray Instance Methods " ! 

" AbstractDictionary Class Methods " ! 

" AbstractDictionary Instance Methods " ! 

" AbstractFloat Class Methods " ! 
AbstractFloat classMethod! 
e

	<get_field: 'System.Math' E>! 

Annotation key: 'ist.runtime.native-name' value: 'E'! 

AbstractFloat classMethod! 
pi

	<get_field: 'System.Math' PI>! 

Annotation key: 'ist.runtime.native-name' value: 'Pi'! 

AbstractFloat classMethod! 
radix

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Radix'! 

AbstractFloat classMethod! 
precision

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Precision'! 

AbstractFloat classMethod! 
emax

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Emax'! 

AbstractFloat classMethod! 
emin

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Emin'! 

AbstractFloat classMethod! 
denormalized
	" 
	Currently, assume this feature is off. 
	Alternatively, ask the MSVCRT _controlfp for this.
	"
	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'Denormalized'! 

AbstractFloat classMethod! 
epsilon

	^(self radix raisedTo: (1 - self precision)) asFloat.! 

Annotation key: 'ist.runtime.native-name' value: 'Epsilon'! 

AbstractFloat classMethod! 
fmin

	self denormalized
		ifTrue: [ ^self fminDenormalized ]
		ifFalse: [ ^self fminNormalized ].! 

Annotation key: 'ist.runtime.native-name' value: 'Fmin'! 

AbstractFloat classMethod! 
fminDenormalized

	^(self radix raisedTo: (self emin - self precision)) asFloat.! 

Annotation key: 'ist.runtime.native-name' value: 'FminDenormalized'! 

AbstractFloat classMethod! 
fminNormalized

	^(self radix raisedTo: self emin - 1) asFloat.! 

Annotation key: 'ist.runtime.native-name' value: 'FminNormalized'! 

AbstractFloat classMethod! 
fmax
	" NB: There is a bug in the X3J20 formula. See ISO/IEC 10967 for the correct formula. "
	| val |
	val := (1 - (self radix raisedTo: self precision negated)) * (self radix raisedTo: self emax).
	^self one _coerce: val.! 

Annotation key: 'ist.runtime.native-name' value: 'Fmax'! 


" AbstractFloat Instance Methods " ! 
AbstractFloat method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^400.! 

AbstractFloat method! 
asBigInteger

	self >= 0.0
		ifTrue: [ ^self _asBigInteger ]
		ifFalse: [ ^self abs _asBigInteger negated ].! 

Annotation key: 'ist.runtime.native-name' value: 'AsBigInteger'! 

AbstractFloat method! 
_asBigInteger

	^self subclassResponsibility.! 

AbstractFloat method! 
asFraction

	| i n d v p z t |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i.
	p := 0.
	z := self class zero.
	t := self class one * 10.
	[ v = z ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * t.
		i := v truncated.
		n := n * 10 + i.
		v := v - (z _coerce: i).
		" Max precision reached "
		p > 10 ifTrue: [ ^n / d ].
	].
	^n / d.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

AbstractFloat method! 
arcCos

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcCos'! 

AbstractFloat method! 
arcSin

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcSin'! 

AbstractFloat method! 
arcTan

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcTan'! 

AbstractFloat method! 
cos

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Cos'! 

AbstractFloat method! 
sin

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Sin'! 

AbstractFloat method! 
tan

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Tan'! 

AbstractFloat method! 
exp

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Exp'! 

AbstractFloat method! 
ln

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Ln'! 

AbstractFloat method! 
log: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Log'! 

AbstractFloat method! 
degreesToRadians

	^self * self class pi / 180.0.! 

Annotation key: 'ist.runtime.native-name' value: 'DegreesToRadians'! 

AbstractFloat method! 
radiansToDegrees

	^self * 180.0 / self class pi.! 

Annotation key: 'ist.runtime.native-name' value: 'RadiansToDegrees'! 

AbstractFloat method! 
floorLog: operand

	^(self log: operand) floor.! 

Annotation key: 'ist.runtime.native-name' value: 'FloorLog'! 

AbstractFloat method! 
= comparand

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

AbstractFloat method! 
printString

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

AbstractFloat method! 
_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.! 

AbstractFloat method! 
_toString: format formatProvider: formatProvider

	^self subclassResponsibility.! 

AbstractFloat method! 
_toPrintString: exponentLetter
	" 
	"
	| str |
	"1. Print it in .Net style. R = Roundtrip; the most verbouse format "
	str := self _toString: 'R' formatProvider: CultureInfo invariantCulture.
	" 2. Exponent letter may be upper-case, so convert to lowercase. "
	str := str copyReplacing: $E withObject: $e. 
	" 3. In case it's an integer only, we need the decimal separator in ST format "
	(str includes: $.) ifFalse: [
		(str includes: $e) 
			ifTrue: [ str := str copyReplaceAll: 'e' with: '.0e' ]
			ifFalse: [ str := str, '.0' ].
	].
	" 4. In case the exponent is positive, we don't want the + sign "
	str := str copyReplaceAll: 'e+' with: 'e'.
	" 5. In case the exponent letter is missing, add it to preserve the float type "
	(str includes: $e) ifFalse: [ str := str, 'e0' ].
	" 6. Finally, return with the exponent letter that we need for this type. "
	^str copyReplacing: $e withObject: exponentLetter.! 

AbstractFloat method! 
// operand

	^(self / operand) asFloatD _floor asInteger.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

AbstractFloat method! 
asScaledDecimal: scale

	^self asFloatD asScaledDecimal: scale.! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

AbstractFloat method! 
truncated

	<primitive: ConvertChecked 'System.Int32'>
	^self asBigInteger.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 


" AbstractReadStream Class Methods " ! 

" AbstractReadStream Instance Methods " ! 

" AbstractStream Class Methods " ! 

" AbstractStream Instance Methods " ! 

" AbstractString Class Methods " ! 

" AbstractString Instance Methods " ! 

" Array Class Methods " ! 

" Array Instance Methods " ! 
Array method! 
asArray

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsArray'! 


" Bag Class Methods " ! 

" Bag Instance Methods " ! 

" BigDecimal Class Methods " ! 

" BigDecimal Instance Methods " ! 
BigDecimal method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^220.! 

BigDecimal method! 
= comparand

	<primitive: NumberEquals _BigDecimal _BigDecimal>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

BigDecimal method! 
> operand

	<primitive: NumberGreatherThan _BigDecimal _BigDecimal>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

BigDecimal method! 
_asHigherPrecision

	^self error: 'Unexpected!!'.! 

BigDecimal method! 
- operand

	<primitive: NumberSubtract _BigDecimal _BigDecimal>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

BigDecimal method! 
* operand

	<primitive: DecimalMultiply _BigDecimal _BigDecimal>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

BigDecimal method! 
>= operand

	<primitive: NumberGreatherThanOrEqual _BigDecimal _BigDecimal>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

BigDecimal method! 
<= operand

	<primitive: NumberLessThanOrEqual _BigDecimal _BigDecimal>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

BigDecimal method! 
< operand

	<primitive: NumberLessThan _BigDecimal _BigDecimal>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

BigDecimal method! 
negated

	<primitive: NumberNegate _BigDecimal>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

BigDecimal method! 
+ operand

	<primitive: NumberAdd _BigDecimal _BigDecimal>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

BigDecimal method! 
/ operand

	<primitive: DecimalDivide _BigDecimal _BigDecimal>

	^super / operand.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

BigDecimal method! 
// operand! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

BigDecimal method! 
asInteger

	^self rounded.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

BigDecimal method! 
_coerce: aNumber

	^aNumber asScaledDecimal: self scale.! 

BigDecimal method! 
truncated

	<primitive: ConvertChecked 'System.Int32'>
	^self asBigInteger.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 

BigDecimal method! 
printString

	<call: _BigDecimal ToSourceString this>! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

BigDecimal method! 
asFloatE

	^self asFloatD asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatE'! 

BigDecimal method! 
asFraction

	^self _numerator / self _denominator.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

BigDecimal method! 
asScaledDecimal: scale

	^self _asScaledDecimal: scale asInt32.! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

BigDecimal method! 
_numerator

	<get_field: _BigDecimal Numerator>! 

BigDecimal method! 
_denominator

	<get_field: _BigDecimal Denominator>! 

BigDecimal method! 
_asScaledDecimal: scale

	<call: _BigDecimal ToScale _BigDecimal 'System.Int32'>! 

BigDecimal method! 
scale

	<get_field: _BigDecimal Scale>! 

Annotation key: 'ist.runtime.native-name' value: 'Scale'! 


" BigInteger Class Methods " ! 

" BigInteger Instance Methods " ! 
BigInteger method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^150.! 

BigInteger method! 
asBigInteger

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsBigInteger'! 

BigInteger method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asBigInteger.! 

BigInteger method! 
+ operand

	<primitive: IntegerAdd 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

BigInteger method! 
> operand

	<primitive: IntegerGreatherThan 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

BigInteger method! 
= comparand

	<primitive: IntegerEquals
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

BigInteger method! 
_asHigherPrecision

	^self error: 'Unexpected!!'.! 

BigInteger method! 
- operand

	<primitive: IntegerSubtract
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

BigInteger method! 
* operand

	<primitive: IntegerMultiply
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

BigInteger method! 
bitShift: shift

	<primitive: IntegerBitShift 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

BigInteger method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual	
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

BigInteger method! 
<= operand

	<primitive: IntegerLessThanOrEqual 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

BigInteger method! 
< operand

	<primitive: IntegerLessThan
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

BigInteger method! 
negated

	<primitive: IntegerNegate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

BigInteger method! 
gcd: operand

	" Not really needed to do this in primitive, but speeds up a little "
	<static: _RuntimeHelper GCD 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>! 

Annotation key: 'ist.runtime.native-name' value: 'Gcd'! 

BigInteger method! 
// operand

	<primitive: IntegerDivideFloor 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

BigInteger method! 
\\ operand

	<primitive: IntegerRemainderFloor
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

BigInteger method! 
quo: operand

	<primitive: IntegerDivideTruncate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

BigInteger method! 
rem: operand

	<primitive: IntegerRemainderTruncate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

BigInteger method! 
_toString: format formatProvider: formatProvider

	<call: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	ToString this 'System.String' 'System.IFormatProvider'>! 

BigInteger method! 
bitAnd: operand

	<primitive: IntegerBitAnd 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

BigInteger method! 
bitOr: operand

	<primitive: IntegerBitOr 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

BigInteger method! 
bitXor: operand

	<primitive: IntegerBitXor
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' >

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" BlockClosure Class Methods " ! 
BlockClosure classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" BlockClosure Instance Methods " ! 

" Boolean Class Methods " ! 
Boolean classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" Boolean Instance Methods " ! 
Boolean method! 
& operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '&'! 

Boolean method! 
| operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '|'! 

Boolean method! 
and: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'And'! 

Boolean method! 
eqv: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Eqv'! 

Boolean method! 
ifFalse: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

Boolean method! 
ifFalse: falseOperand ifTrue: trueOperand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

Boolean method! 
ifTrue: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

Boolean method! 
ifTrue: trueOperand ifFalse: falseOperand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

Boolean method! 
not

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Not'! 

Boolean method! 
or: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Or'! 

Boolean method! 
printString

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Boolean method! 
xor: operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Xor'! 


" Byte Class Methods " ! 
Byte classMethod! 
min

	<get_field: 'System.Byte' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

Byte classMethod! 
max

	<get_field: 'System.Byte' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" Byte Instance Methods " ! 
Byte method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^110.! 

Byte method! 
asByte

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsByte'! 

Byte method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asByte.! 

Byte method! 
= comparand

	<primitive: IntegerEquals 'System.Byte' 'System.Byte'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Byte method! 
> operand

	<primitive: IntegerGreatherThan 'System.Byte' 'System.Byte'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Byte method! 
_asHigherPrecision

	^self asInt16.! 

Byte method! 
- operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Byte method! 
* operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Byte method! 
+ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Byte method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.Byte' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

Byte method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.Byte' 'System.Byte'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Byte method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.Byte' 'System.Byte'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Byte method! 
< operand

	<primitive: IntegerLessThan 'System.Byte' 'System.Byte'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Byte method! 
// operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Byte method! 
\\ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

Byte method! 
quo: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Byte method! 
rem: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Byte method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Byte' ToString this 'System.String' 'System.IFormatProvider'>! 

Byte method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.Byte' 'System.Byte'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

Byte method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.Byte' 'System.Byte'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

Byte method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.Byte' 'System.Byte'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" ByteArray Class Methods " ! 

" ByteArray Instance Methods " ! 
ByteArray method! 
asByteArray

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsByteArray'! 


" Character Class Methods " ! 
Character classMethod! 
codePoint: integer

	<primitive: ConvertChecked char>! 

Annotation key: 'ist.runtime.native-name' value: 'CodePoint'! 

Character classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

Character classMethod! 
cr

	^Cr.! 

Annotation key: 'ist.runtime.native-name' value: 'Cr'! 

Character classMethod! 
lf

	^Lf.! 

Annotation key: 'ist.runtime.native-name' value: 'Lf'! 

Character classMethod! 
space

	^Space.! 

Annotation key: 'ist.runtime.native-name' value: 'Space'! 

Character classMethod! 
tab

	^Tab.! 

Annotation key: 'ist.runtime.native-name' value: 'Tab'! 


" Character Instance Methods " ! 
Character method! 
asLowercase

	<static: char ToLower char>! 

Annotation key: 'ist.runtime.native-name' value: 'AsLowercase'! 

Character method! 
asString

	^String with: self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsString'! 

Character method! 
asUppercase

	<static: char ToUpper char>! 

Annotation key: 'ist.runtime.native-name' value: 'AsUppercase'! 

Character method! 
isAlphaNumeric

	^self isLetter or: [ self isDigit ].! 

Annotation key: 'ist.runtime.native-name' value: 'IsAlphaNumeric'! 

Character method! 
isDigit

	<static: char IsDigit char>! 

Annotation key: 'ist.runtime.native-name' value: 'IsDigit'! 

Character method! 
isLetter

	<static: char IsLetter char>! 

Annotation key: 'ist.runtime.native-name' value: 'IsLetter'! 

Character method! 
isLowercase

	<static: char IsLower char>! 

Annotation key: 'ist.runtime.native-name' value: 'IsLowercase'! 

Character method! 
isUppercase

	<static: char IsUpper char>! 

Annotation key: 'ist.runtime.native-name' value: 'IsUppercase'! 

Character method! 
codePoint

	<primitive: ConvertUnchecked int>! 

Annotation key: 'ist.runtime.native-name' value: 'CodePoint'! 

Character method! 
= comparand

	<primitive: Equals char char>
	^false.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Character method! 
asImmutableString

	<static: char ToString char>! 

Annotation key: 'ist.runtime.native-name' value: 'AsImmutableString'! 


" Class Class Methods " ! 
Class classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" Class Instance Methods " ! 
Class method! 
name

	<get_property: _SmalltalkClass Name _Symbol>! 

Annotation key: 'ist.runtime.native-name' value: 'Name'! 

Class method! 
superclass

	<get_property: _SmalltalkClass Superclass _SmalltalkClass>! 

Annotation key: 'ist.runtime.native-name' value: 'Superclass'! 

Class method! 
basicNew

	<call: _SmalltalkClass NewObject this>! 

Annotation key: 'ist.runtime.native-name' value: 'BasicNew'! 

Class method! 
= comparand

	<call: _SmalltalkClass Equals this object>! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Class method! 
subclasses

	<get_property: _SmalltalkClass Subclasses 
	'System.Collections.Generic.IEnumerable`1[[IronSmalltalk.Runtime.SmalltalkClass, IronSmalltalk.Runtime]]'>! 

Annotation key: 'ist.runtime.native-name' value: 'Subclasses'! 


" Collection Class Methods " ! 

" Collection Instance Methods " ! 
Collection method! 
allSatisfy: discriminator

	self do: [ :element |
		(discriminator value: element) ifFalse: [ ^false ].
	].
	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'AllSatisfy'! 

Collection method! 
anySatisfy: discriminator

	self do: [ :element |
		(discriminator value: element) ifTrue: [ ^true ].
	].
	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'AnySatisfy'! 

Collection method! 
detect: discriminator ifNone: exceptionHandler

	self do: [ :element |
		(discriminator value: element) ifTrue: [ ^element ].
	].
	^exceptionHandler value.! 

Annotation key: 'ist.runtime.native-name' value: 'Detect'! 

Collection method! 
do: operation separatedBy: separator

	| firstTime |
	firstTime := true.
	self do: [ :element |
		firstTime 
			ifTrue: [ firstTime := false ]
			ifFalse: [ separator value ].
		operation value: element.
	].! 

Annotation key: 'ist.runtime.native-name' value: 'Do'! 

Collection method! 
includes: target

	self do: [ :element |
		element = target ifTrue: [ ^true ].
	].
	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'Includes'! 

Collection method! 
inject: initialValue into: operation

	| value |
	value := initialValue.
	self do: [ :element |
		value := operation value: value value: element.
	].
	^value.! 

Annotation key: 'ist.runtime.native-name' value: 'Inject'! 

Collection method! 
isEmpty

	^self size = 0.! 

Annotation key: 'ist.runtime.native-name' value: 'IsEmpty'! 

Collection method! 
notEmpty

	^self size ~= 0.! 

Annotation key: 'ist.runtime.native-name' value: 'NotEmpty'! 

Collection method! 
occurrencesOf: target

	| occurrences |
	occurrences := 0.
	self do: [ :element |
		element = target ifTrue: [ occurrences := occurrences + 1 ].
	].
	^occurrences.! 

Annotation key: 'ist.runtime.native-name' value: 'OccurrencesOf'! 

Collection method! 
reject: discriminator

	^self select: [ :element | (discriminator value: element) not ].! 

Annotation key: 'ist.runtime.native-name' value: 'Reject'! 

Collection method! 
size

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Size'! 

Collection method! 
asArray

	^Array withAll: self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsArray'! 

Collection method! 
asByteArray

	^ByteArray withAll: self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsByteArray'! 


" CollectionReadStream Class Methods " ! 

" CollectionReadStream Instance Methods " ! 

" Console Class Methods " ! 
Console classMethod! 
writeLine: anObject

	<static: 'System.Console' WriteLine object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteLine'! 

Console classMethod! 
beep

	<static: 'System.Console' Beep>! 

Annotation key: 'ist.runtime.native-name' value: 'Beep'! 

Console classMethod! 
beep: frequency duration: duration

	<static: 'System.Console' Beep int int>! 

Annotation key: 'ist.runtime.native-name' value: 'Beep'! 

Console classMethod! 
clear

	<static: 'System.Console' Clear>! 

Annotation key: 'ist.runtime.native-name' value: 'Clear'! 

Console classMethod! 
read

	<static: 'System.Console' Read>! 

Annotation key: 'ist.runtime.native-name' value: 'Read'! 

Console classMethod! 
readKey

	<static: 'System.Console' ReadKey>! 

Annotation key: 'ist.runtime.native-name' value: 'ReadKey'! 

Console classMethod! 
readKey: intercept

	<static: 'System.Console' ReadKey bool>! 

Annotation key: 'ist.runtime.native-name' value: 'ReadKey'! 

Console classMethod! 
readLine

	<static: 'System.Console' ReadLine>! 

Annotation key: 'ist.runtime.native-name' value: 'ReadLine'! 

Console classMethod! 
openStandardInput

	<static: 'System.Console' OpenStandardInput>! 

Annotation key: 'ist.runtime.native-name' value: 'OpenStandardInput'! 

Console classMethod! 
openStandardOutput

	<static: 'System.Console' OpenStandardOutput>! 

Annotation key: 'ist.runtime.native-name' value: 'OpenStandardOutput'! 

Console classMethod! 
openStandardError

	<static: 'System.Console' OpenStandardError>! 

Annotation key: 'ist.runtime.native-name' value: 'OpenStandardError'! 

Console classMethod! 
resetColor

	<static: 'System.Console' ResetColor>! 

Annotation key: 'ist.runtime.native-name' value: 'ResetColor'! 

Console classMethod! 
setCursorPosition: left top: top

	<static: 'System.Console' SetCursorPosition int int>! 

Annotation key: 'ist.runtime.native-name' value: 'SetCursorPosition'! 

Console classMethod! 
error: aTextWriter

	<static: 'System.Console' SetError 'System.IO.TextWriter'>! 

Annotation key: 'ist.runtime.native-name' value: 'Error'! 

Console classMethod! 
in: aTextWriter

	<static: 'System.Console' SetIn 'System.IO.TextReader'>! 

Annotation key: 'ist.runtime.native-name' value: 'In'! 

Console classMethod! 
out: aTextWriter

	<static: 'System.Console' SetOut 'System.IO.TextWriter'>! 

Annotation key: 'ist.runtime.native-name' value: 'Out'! 

Console classMethod! 
setWindowPosition: left top: top

	<static: 'System.Console' SetWindowPosition int int>! 

Annotation key: 'ist.runtime.native-name' value: 'SetWindowPosition'! 

Console classMethod! 
setWindowSize: width height: height

	<static: 'System.Console' SetWindowSize int int>! 

Annotation key: 'ist.runtime.native-name' value: 'SetWindowSize'! 

Console classMethod! 
write: anObject

	<static: 'System.Console' Write object>! 

Annotation key: 'ist.runtime.native-name' value: 'Write'! 

Console classMethod! 
writeFormatted: format with: arg1 with: arg2

	<static: 'System.Console' Write string object object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteFormatted'! 

Console classMethod! 
writeFormatted: format arguments: arg

	<static: 'System.Console' Write string 'System.Object[]'>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteFormatted'! 

Console classMethod! 
writeFormatted: format with: arg

	<static: 'System.Console' Write string object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteFormatted'! 

Console classMethod! 
writeFormatted: format with: arg1 with: arg2 with: arg3

	<static: 'System.Console' Write string object object object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteFormatted'! 

Console classMethod! 
writeLineFormatted: format arguments: arg

	<static: 'System.Console' WriteLine string 'System.Object[]'>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteLineFormatted'! 

Console classMethod! 
writeLineFormatted: format with: arg

	<static: 'System.Console' WriteLine string object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteLineFormatted'! 

Console classMethod! 
writeLineFormatted: format with: arg1 with: arg2

	<static: 'System.Console' WriteLine string object object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteLineFormatted'! 

Console classMethod! 
writeLineFormatted: format with: arg1 with: arg2 with: arg3

	<static: 'System.Console' WriteLine string object object object>! 

Annotation key: 'ist.runtime.native-name' value: 'WriteLineFormatted'! 

Console classMethod! 
backgroundColor

	<get_property: 'System.Console' BackgroundColor 'System.ConsoleColor'>! 

Annotation key: 'ist.runtime.native-name' value: 'BackgroundColor'! 

Console classMethod! 
backgroundColor: aConsoleColor

	<set_property: 'System.Console' BackgroundColor 'System.ConsoleColor'>! 

Annotation key: 'ist.runtime.native-name' value: 'BackgroundColor'! 

Console classMethod! 
bufferWidth

	<get_property: 'System.Console' BufferWidth int>! 

Annotation key: 'ist.runtime.native-name' value: 'BufferWidth'! 

Console classMethod! 
bufferWidth: anInteger

	<set_property: 'System.Console' BufferWidth int>! 

Annotation key: 'ist.runtime.native-name' value: 'BufferWidth'! 

Console classMethod! 
bufferHeight

	<get_property: 'System.Console' BufferHeight int>! 

Annotation key: 'ist.runtime.native-name' value: 'BufferHeight'! 

Console classMethod! 
bufferHeight: anInteger

	<set_property: 'System.Console' BufferHeight int>! 

Annotation key: 'ist.runtime.native-name' value: 'BufferHeight'! 

Console classMethod! 
capsLock

	<get_property: 'System.Console' CapsLock bool>! 

Annotation key: 'ist.runtime.native-name' value: 'CapsLock'! 

Console classMethod! 
cursorLeft

	<get_property: 'System.Console' CursorLeft int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorLeft'! 

Console classMethod! 
cursorSize

	<get_property: 'System.Console' CursorSize int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorSize'! 

Console classMethod! 
cursorTop

	<get_property: 'System.Console' CursorTop int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorTop'! 

Console classMethod! 
cursorVisible

	<get_property: 'System.Console' CursorVisible bool>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorVisible'! 

Console classMethod! 
cursorVisible: aBoolean

	<set_property: 'System.Console' CursorVisible bool>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorVisible'! 

Console classMethod! 
cursorTop: anInteger

	<set_property: 'System.Console' CursorTop int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorTop'! 

Console classMethod! 
cursorSize: anInteger

	<set_property: 'System.Console' CursorSize int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorSize'! 

Console classMethod! 
cursorLeft: anInteger

	<set_property: 'System.Console' CursorLeft int>! 

Annotation key: 'ist.runtime.native-name' value: 'CursorLeft'! 

Console classMethod! 
error

	<get_property: 'System.Console' Error 'System.IO.TextWriter'>! 

Annotation key: 'ist.runtime.native-name' value: 'Error'! 

Console classMethod! 
in

	<get_property: 'System.Console' In 'System.IO.TextReader'>! 

Annotation key: 'ist.runtime.native-name' value: 'In'! 

Console classMethod! 
out

	<get_property: 'System.Console' Out 'System.IO.TextWriter'>! 

Annotation key: 'ist.runtime.native-name' value: 'Out'! 

Console classMethod! 
foregroundColor

	<get_property: 'System.Console' ForegroundColor 'System.ConsoleColor'>! 

Annotation key: 'ist.runtime.native-name' value: 'ForegroundColor'! 

Console classMethod! 
foregroundColor: aConsoleColor

	<set_property: 'System.Console' ForegroundColor 'System.ConsoleColor'>! 

Annotation key: 'ist.runtime.native-name' value: 'ForegroundColor'! 

Console classMethod! 
inputEncoding: anEncoding

	<set_property: 'System.Console' InputEncoding 'System.Text.Encoding'>! 

Annotation key: 'ist.runtime.native-name' value: 'InputEncoding'! 

Console classMethod! 
inputEncoding

	<get_property: 'System.Console' InputEncoding 'System.Text.Encoding'>! 

Annotation key: 'ist.runtime.native-name' value: 'InputEncoding'! 

Console classMethod! 
outputEncoding

	<get_property: 'System.Console' OutputEncoding 'System.Text.Encoding'>! 

Annotation key: 'ist.runtime.native-name' value: 'OutputEncoding'! 

Console classMethod! 
outputEncoding: anEncoding

	<set_property: 'System.Console' OutputEncoding 'System.Text.Encoding'>! 

Annotation key: 'ist.runtime.native-name' value: 'OutputEncoding'! 

Console classMethod! 
keyAvailable 

	<get_property: 'System.Console' KeyAvailable bool>! 

Annotation key: 'ist.runtime.native-name' value: 'KeyAvailable'! 

Console classMethod! 
largestWindowHeight 

	<get_property: 'System.Console' LargestWindowHeight int>! 

Annotation key: 'ist.runtime.native-name' value: 'LargestWindowHeight'! 

Console classMethod! 
largestWindowWidth

	<get_property: 'System.Console' LargestWindowWidth int>! 

Annotation key: 'ist.runtime.native-name' value: 'LargestWindowWidth'! 

Console classMethod! 
numberLock

	<get_property: 'System.Console' NumberLock bool>! 

Annotation key: 'ist.runtime.native-name' value: 'NumberLock'! 

Console classMethod! 
title

	<get_property: 'System.Console' Title string>! 

Annotation key: 'ist.runtime.native-name' value: 'Title'! 

Console classMethod! 
title: aString

	<set_property: 'System.Console' Title string>! 

Annotation key: 'ist.runtime.native-name' value: 'Title'! 

Console classMethod! 
treatControlCAsInput: aBoolean

	<set_property: 'System.Console' TreatControlCAsInput bool>! 

Annotation key: 'ist.runtime.native-name' value: 'TreatControlCAsInput'! 

Console classMethod! 
treatControlCAsInput

	<get_property: 'System.Console' TreatControlCAsInput bool>! 

Annotation key: 'ist.runtime.native-name' value: 'TreatControlCAsInput'! 

Console classMethod! 
windowHeight

	<get_property: 'System.Console' WindowHeight int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowHeight'! 

Console classMethod! 
windowLeft

	<get_property: 'System.Console' WindowLeft int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowLeft'! 

Console classMethod! 
windowTop

	<get_property: 'System.Console' WindowTop int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowTop'! 

Console classMethod! 
windowWidth

	<get_property: 'System.Console' WindowWidth int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowWidth'! 

Console classMethod! 
windowWidth: anInteger

	<set_property: 'System.Console' WindowWidth int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowWidth'! 

Console classMethod! 
windowTop: anInteger

	<set_property: 'System.Console' WindowTop int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowTop'! 

Console classMethod! 
windowLeft: anInteger

	<set_property: 'System.Console' WindowLeft int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowLeft'! 

Console classMethod! 
windowHeight: anInteger

	<set_property: 'System.Console' WindowHeight int>! 

Annotation key: 'ist.runtime.native-name' value: 'WindowHeight'! 

Console classMethod! 
cr

	self nextPut: Character cr.! 

Annotation key: 'ist.runtime.native-name' value: 'Cr'! 

Console classMethod! 
flush

	" Does nothing - No need for flush "! 

Annotation key: 'ist.runtime.native-name' value: 'Flush'! 

Console classMethod! 
space

	self nextPut: Character space.! 

Annotation key: 'ist.runtime.native-name' value: 'Space'! 

Console classMethod! 
tab

	self nextPut: Character tab.! 

Annotation key: 'ist.runtime.native-name' value: 'Tab'! 

Console classMethod! 
nextPutAll: aString

	self write: aString.! 

Annotation key: 'ist.runtime.native-name' value: 'NextPutAll'! 

Console classMethod! 
nextPut: anObject

	<static: 'System.Console' Write char>! 

Annotation key: 'ist.runtime.native-name' value: 'NextPut'! 

Console classMethod! 
show: aString

	self write: aString.! 

Annotation key: 'ist.runtime.native-name' value: 'Show'! 


" Console Instance Methods " ! 

" CultureInfo Class Methods " ! 
CultureInfo classMethod! 
currentCulture

	<get_property: 'System.Globalization.CultureInfo' CurrentCulture 'System.Globalization.CultureInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'CurrentCulture'! 

CultureInfo classMethod! 
currentUICulture

	<get_property: 'System.Globalization.CultureInfo' CurrentUICulture 'System.Globalization.CultureInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'CurrentUICulture'! 

CultureInfo classMethod! 
installedUICulture

	<get_property: 'System.Globalization.CultureInfo' InstalledUICulture 'System.Globalization.CultureInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'InstalledUICulture'! 

CultureInfo classMethod! 
invariantCulture

	<get_property: 'System.Globalization.CultureInfo' InvariantCulture 'System.Globalization.CultureInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'InvariantCulture'! 

CultureInfo classMethod! 
readOnly: aCultureInfo

	<static: 'System.Globalization.CultureInfo' ReadOnly 'System.Globalization.CultureInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'ReadOnly'! 

CultureInfo classMethod! 
getCultureInfo: name alternativeName: altName

	<static: 'System.Globalization.CultureInfo' GetCultureInfo string string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetCultureInfo'! 

CultureInfo classMethod! 
getCultureInfo: name

	<static: 'System.Globalization.CultureInfo' GetCultureInfo string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetCultureInfo'! 

CultureInfo classMethod! 
getCultureInfoFromLCID: lcid

	<static: 'System.Globalization.CultureInfo' GetCultureInfo int>

	^self getCultureInfoFromLCID: lcid asInt32.! 

Annotation key: 'ist.runtime.native-name' value: 'GetCultureInfoFromLCID'! 

CultureInfo classMethod! 
createSpecificCulture: name

	<static: 'System.Globalization.CultureInfo' CreateSpecificCulture string>! 

Annotation key: 'ist.runtime.native-name' value: 'CreateSpecificCulture'! 


" CultureInfo Instance Methods " ! 
CultureInfo method! 
clearCachedData

	<call: 'System.Globalization.CultureInfo' ClearCachedData this>! 

Annotation key: 'ist.runtime.native-name' value: 'ClearCachedData'! 

CultureInfo method! 
clone

	<call: 'System.Globalization.CultureInfo' Clone this>! 

Annotation key: 'ist.runtime.native-name' value: 'Clone'! 

CultureInfo method! 
getConsoleFallbackUICulture 

	<call: 'System.Globalization.CultureInfo' GetConsoleFallbackUICulture this>! 

Annotation key: 'ist.runtime.native-name' value: 'GetConsoleFallbackUICulture'! 

CultureInfo method! 
calendar

	<get_property: 'System.Globalization.CultureInfo' Calendar 'System.Globalization.Calendar'>! 

Annotation key: 'ist.runtime.native-name' value: 'Calendar'! 

CultureInfo method! 
dateTimeFormat

	<get_property: 'System.Globalization.CultureInfo' DateTimeFormat 'System.Globalization.DateTimeFormatInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'DateTimeFormat'! 

CultureInfo method! 
displayName

	<get_property: 'System.Globalization.CultureInfo' DisplayName string>! 

Annotation key: 'ist.runtime.native-name' value: 'DisplayName'! 

CultureInfo method! 
englishName

	<get_property: 'System.Globalization.CultureInfo' EnglishName string>! 

Annotation key: 'ist.runtime.native-name' value: 'EnglishName'! 

CultureInfo method! 
dateTimeFormat: aDateTimeFormatInfo

	<set_property: 'System.Globalization.CultureInfo' DateTimeFormat 'System.Globalization.DateTimeFormatInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'DateTimeFormat'! 

CultureInfo method! 
isNeutralCulture

	<get_property: 'System.Globalization.CultureInfo' IsNeutralCulture bool>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNeutralCulture'! 

CultureInfo method! 
isReadOnly

	<get_property: 'System.Globalization.CultureInfo' IsReadOnly bool>! 

Annotation key: 'ist.runtime.native-name' value: 'IsReadOnly'! 

CultureInfo method! 
keyboardLayoutId 

	<get_property: 'System.Globalization.CultureInfo' KeyboardLayoutId int>! 

Annotation key: 'ist.runtime.native-name' value: 'KeyboardLayoutId'! 

CultureInfo method! 
lcid

	<get_property: 'System.Globalization.CultureInfo' LCID int>! 

Annotation key: 'ist.runtime.native-name' value: 'Lcid'! 

CultureInfo method! 
name

	<get_property: 'System.Globalization.CultureInfo' Name string>! 

Annotation key: 'ist.runtime.native-name' value: 'Name'! 

CultureInfo method! 
nativeName

	<get_property: 'System.Globalization.CultureInfo' NativeName string>! 

Annotation key: 'ist.runtime.native-name' value: 'NativeName'! 

CultureInfo method! 
numberFormat

	<get_property: 'System.Globalization.CultureInfo' NumberFormat 'System.Globalization.NumberFormatInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'NumberFormat'! 

CultureInfo method! 
threeLetterISOLanguageName

	<get_property: 'System.Globalization.CultureInfo' ThreeLetterISOLanguageName string>! 

Annotation key: 'ist.runtime.native-name' value: 'ThreeLetterISOLanguageName'! 

CultureInfo method! 
threeLetterWindowsLanguageName

	<get_property: 'System.Globalization.CultureInfo' ThreeLetterWindowsLanguageName string>! 

Annotation key: 'ist.runtime.native-name' value: 'ThreeLetterWindowsLanguageName'! 

CultureInfo method! 
twoLetterISOLanguageName

	<get_property: 'System.Globalization.CultureInfo' TwoLetterISOLanguageName string>! 

Annotation key: 'ist.runtime.native-name' value: 'TwoLetterISOLanguageName'! 

CultureInfo method! 
useUserOverride

	<get_property: 'System.Globalization.CultureInfo' UseUserOverride bool>! 

Annotation key: 'ist.runtime.native-name' value: 'UseUserOverride'! 

CultureInfo method! 
numberFormat: aNumberFormatInfo

	<set_property: 'System.Globalization.CultureInfo' NumberFormat 'System.Globalization.NumberFormatInfo'>! 

Annotation key: 'ist.runtime.native-name' value: 'NumberFormat'! 


" DateTime Class Methods " ! 
DateTime classMethod! 
year: year month: month day: dayOfMonth hour: hour minute: minute second: second
	
	^(super year: year month: month day: dayOfMonth hour: hour minute: minute second: second) asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

DateTime classMethod! 
now

	<get_property: 'System.DateTimeOffset' Now 'System.DateTimeOffset'>! 

Annotation key: 'ist.runtime.native-name' value: 'Now'! 

DateTime classMethod! 
year: year day: dayOfYear hour: hour minute: minute second: second offset: offset

	| monthStartDay |
	monthStartDay := 0.
	1 to: 12 do: [ :month |
		| daysInMonth |
		daysInMonth := self _daysIn: year month: month.
		dayOfYear <= (monthStartDay + daysInMonth) ifTrue: [
			| day |
			day := dayOfYear - monthStartDay.
			^self year: year month: month day: day hour: hour minute: minute second: second offset: offset.
		].
		monthStartDay := monthStartDay + daysInMonth.
	].
	^self error: 'Invalid dayOfYear'.! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

DateTime classMethod! 
year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: offset

	<ctor: 'System.DateTimeOffset' int int int int int int 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 


" DateTime Instance Methods " ! 
DateTime method! 
asDateTime

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsDateTime'! 

DateTime method! 
- operand

	<primitive: Subtract 'System.DateTimeOffset' 'System.DateTimeOffset'>
	^self asDateTime - operand asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 


" DateTimeFormatInfo Class Methods " ! 

" DateTimeFormatInfo Instance Methods " ! 

" Decimal Class Methods " ! 

" Decimal Instance Methods " ! 
Decimal method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^210.! 

Decimal method! 
= comparand

	<primitive: NumberEquals 'System.Decimal' 'System.Decimal'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Decimal method! 
> operand

	<primitive: NumberGreatherThan 'System.Decimal' 'System.Decimal'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Decimal method! 
- operand

	<primitive: NumberSubtract 'System.Decimal' 'System.Decimal'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Decimal method! 
* operand

	<primitive: DecimalMultiply 'System.Decimal' 'System.Decimal'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Decimal method! 
>= operand

	<primitive: NumberGreatherThanOrEqual 'System.Decimal' 'System.Decimal'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Decimal method! 
<= operand

	<primitive: NumberLessThanOrEqual 'System.Decimal' 'System.Decimal'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Decimal method! 
< operand

	<primitive: NumberLessThan 'System.Decimal' 'System.Decimal'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Decimal method! 
negated

	<primitive: NumberNegate 'System.Decimal'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Decimal method! 
asNativeDecimal

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsNativeDecimal'! 

Decimal method! 
+ operand

	<primitive: NumberAdd 'System.Decimal' 'System.Decimal'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Decimal method! 
/ operand

	<primitive: DecimalDivide 'System.Decimal' 'System.Decimal'>

	^super / operand.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

Decimal method! 
// operand! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Decimal method! 
truncated

	<primitive: ConvertChecked 'System.Int32'>
	^self asBigInteger.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 

Decimal method! 
_asHigherPrecision

	^self _asBigDecimal.! 

Decimal method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asNativeDecimal.! 

Decimal method! 
asScaledDecimal: scale

	^self _asBigDecimal asScaledDecimal: scale.! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

Decimal method! 
asInteger

	^self rounded.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

Decimal method! 
asFraction

	| i n d v p |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i.
	p := 0.
	[ v = 0.0 ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * 10.
		i := v truncated.
		n := n * 10 + i.
		v := v - i.
		" Just in case of a bug ... max precision is 28 for decimal "
		p > 30 ifTrue: [ ^n / d ].
	].
	^n / d.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

Decimal method! 
scale

	^self _asBigDecimal scale.! 

Annotation key: 'ist.runtime.native-name' value: 'Scale'! 

Decimal method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Decimal' ToString this 'System.String' 'System.IFormatProvider'>! 

Decimal method! 
_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.! 

Decimal method! 
_asBigDecimal

	<primitive: ConvertChecked _BigDecimal>! 

Annotation key: 'ist.runtime.native-name' value: ''! 

Decimal method! 
printString

	^self _asBigDecimal printString.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 


" Dictionary Class Methods " ! 

" Dictionary Instance Methods " ! 

" Duration Class Methods " ! 
Duration classMethod! 
zero

	<get_field: 'System.TimeSpan' Zero>! 

Annotation key: 'ist.runtime.native-name' value: 'Zero'! 

Duration classMethod! 
days: days hours: hours minutes: minutes seconds: seconds

	<ctor: 'System.TimeSpan' int int int int>! 

Annotation key: 'ist.runtime.native-name' value: 'Days'! 

Duration classMethod! 
_ticks: ticks

	<ctor: 'System.TimeSpan' 'System.Int64'>

	^self _ticks: ticks asInt64.! 

Duration classMethod! 
seconds: seconds
	"
	1 tick = 100 nanoseconds.
	1 seconds = 10000000 ticks.
	"
	^self _ticks: (seconds * 10000000) asInt64.! 

Annotation key: 'ist.runtime.native-name' value: 'Seconds'! 

Duration classMethod! 
days: days hours: hours minutes: minutes seconds: seconds milliseconds: milliseconds

	<ctor: 'System.TimeSpan' int int int int int>! 

Annotation key: 'ist.runtime.native-name' value: 'Days'! 

Duration classMethod! 
milliseconds: milliseconds
	"
	1 tick = 100 nanoseconds.
	1 milliseconds = 10000 ticks.
	"
	^self _ticks: (milliseconds * 10000) asInt64.! 

Annotation key: 'ist.runtime.native-name' value: 'Milliseconds'! 


" Duration Instance Methods " ! 
Duration method! 
_ticks

	<get_property: 'System.TimeSpan' Ticks 'System.Int64'>! 

Duration method! 
seconds

	<get_property: 'System.TimeSpan' Seconds 'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'Seconds'! 

Duration method! 
milliseconds

	<get_property: 'System.TimeSpan' Milliseconds 'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'Milliseconds'! 

Duration method! 
asMilliseconds

	<get_property: 'System.TimeSpan' TotalMilliseconds 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsMilliseconds'! 

Duration method! 
asSeconds

	<get_property: 'System.TimeSpan' TotalSeconds 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsSeconds'! 

Duration method! 
< operand

	<primitive: LessThan 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Duration method! 
<= operand

	<primitive: LessThanOrEqual 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Duration method! 
> operand

	<primitive: GreatherThan 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Duration method! 
>= operand

	<primitive: GreatherThanOrEqual 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Duration method! 
= comparand

	<primitive: Equals 'System.TimeSpan' 'System.TimeSpan'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Duration method! 
+ operand

	<primitive: Add 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Duration method! 
- operand

	<primitive: Subtract 'System.TimeSpan' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Duration method! 
* operand

	^self class _ticks: (self _ticks * operand) asInteger.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Duration method! 
abs

	^self class _ticks: self _ticks abs.! 

Annotation key: 'ist.runtime.native-name' value: 'Abs'! 

Duration method! 
days

	<get_property: 'System.TimeSpan' Days 'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'Days'! 

Duration method! 
hours

	<get_property: 'System.TimeSpan' Hours 'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'Hours'! 

Duration method! 
minutes

	<get_property: 'System.TimeSpan' Minutes'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'Minutes'! 

Duration method! 
negated

	<primitive: Negate 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Duration method! 
negative

	^self < self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'Negative'! 

Duration method! 
positive

	^self >= self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'Positive'! 

Duration method! 
_toString: format formatProvider: formatProvider

	<call: 'System.TimeSpan' ToString this string 'System.IFormatProvider'>! 

Duration method! 
_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.! 

Duration method! 
printString
	"
	X3J20 requires relatively stiff representation - we obey.
	"
	self negative ifTrue: [
		self milliseconds = 0
			ifTrue: [ ^self _toString: '\-d\:hh\:mm\:ss' ]
			ifFalse: [ ^self _toString: '\-d\:hh\:mm\:ss\.fffffff' ].
	] ifFalse: [
		self milliseconds = 0
			ifTrue: [ ^self _toString: 'd\:hh\:mm\:ss' ]
			ifFalse: [ ^self _toString: 'd\:hh\:mm\:ss\.fffffff' ].
	].! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Duration method! 
/ operand

	operand class = self class ifTrue: [
		" Duration ... return number "
		^self _ticks / operand _ticks.
	] ifFalse: [
		" Number ... return duration "
		^self class _ticks: (self _ticks / operand) asInteger.
	].! 

Annotation key: 'ist.runtime.native-name' value: '/'! 


" DyadicBlock Class Methods " ! 

" DyadicBlock Instance Methods " ! 
DyadicBlock method! 
value: argument1 value: argument2

	<static: _RuntimeHelper BlockValue 'System.Func`3[[System.Object], [System.Object], [System.Object]]' 'System.Object' 'System.Object'>! 

Annotation key: 'ist.runtime.native-name' value: 'Value'! 

DyadicBlock method! 
argumentCount

	^2.! 

Annotation key: 'ist.runtime.native-name' value: 'ArgumentCount'! 


" Enumerable Class Methods " ! 

" Enumerable Instance Methods " ! 

" Error Class Methods " ! 

" Error Instance Methods " ! 
Error method! 
isResumable

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsResumable'! 


" Exception Class Methods " ! 

" Exception Instance Methods " ! 
Exception method! 
isResumable

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsResumable'! 

Exception method! 
messageText

	^messageText.! 

Annotation key: 'ist.runtime.native-name' value: 'MessageText'! 


" ExceptionSet Class Methods " ! 

" ExceptionSet Instance Methods " ! 

" ExtensibleCollection Class Methods " ! 

" ExtensibleCollection Instance Methods " ! 

" FailedMessage Class Methods " ! 
FailedMessage classMethod! 
_selector: aSymbol arguments: anArray

	^self new _selector: aSymbol arguments: anArray; yourself.! 

Annotation key: 'ist.runtime.native-name' value: ''! 


" FailedMessage Instance Methods " ! 
FailedMessage method! 
arguments

	^arguments.! 

Annotation key: 'ist.runtime.native-name' value: 'Arguments'! 

FailedMessage method! 
selector

	^selector.! 

Annotation key: 'ist.runtime.native-name' value: 'Selector'! 

FailedMessage method! 
_selector: aSymbol arguments: anArray

	selector := aSymbol.
	arguments := anArray.! 

Annotation key: 'ist.runtime.native-name' value: ''! 


" False Class Methods " ! 

" False Instance Methods " ! 
False method! 
not

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'Not'! 

False method! 
printString

	^'false'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

False method! 
ifFalse: operand

	^operand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

False method! 
ifFalse: falseOperand ifTrue: trueOperand

	^falseOperand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

False method! 
ifTrue: operand

	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

False method! 
ifTrue: trueOperand ifFalse: falseOperand

	^falseOperand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

False method! 
eqv: operand

	^operand not.! 

Annotation key: 'ist.runtime.native-name' value: 'Eqv'! 

False method! 
& operand

	^false.! 

Annotation key: 'ist.runtime.native-name' value: '&'! 

False method! 
| operand

	^operand.! 

Annotation key: 'ist.runtime.native-name' value: '|'! 

False method! 
and: operand

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'And'! 

False method! 
or: operand

	^operand value.! 

Annotation key: 'ist.runtime.native-name' value: 'Or'! 

False method! 
xor: operand

	^operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Xor'! 

False method! 
printOn: target

	target nextPutAll: 'false'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintOn'! 


" FileStream Class Methods " ! 

" FileStream Instance Methods " ! 

" FloatD Class Methods " ! 
FloatD classMethod! 
radix
	
	" System.Double uses IEEE 754 binary64 floats "
	^2.! 

Annotation key: 'ist.runtime.native-name' value: 'Radix'! 

FloatD classMethod! 
emin
	" System.Double uses IEEE 754 binary64 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^-1021.! 

Annotation key: 'ist.runtime.native-name' value: 'Emin'! 

FloatD classMethod! 
emax
	" System.Double uses IEEE 754 binary64 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^1024.! 

Annotation key: 'ist.runtime.native-name' value: 'Emax'! 

FloatD classMethod! 
precision
	
	" System.Double uses IEEE 754 binary64 floats "
	^53 " 52 + 1 ".! 

Annotation key: 'ist.runtime.native-name' value: 'Precision'! 

FloatD classMethod! 
fmax

	<get_field: 'System.Double' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Fmax'! 


" FloatD Instance Methods " ! 
FloatD method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^420.! 

FloatD method! 
asFloatD

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

FloatD method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asFloatD.! 

FloatD method! 
= comparand

	<primitive: FloatEquals 'System.Double' 'System.Double'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

FloatD method! 
> operand

	<primitive: FloatGreatherThan 'System.Double' 'System.Double'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

FloatD method! 
_asBigInteger

	<ctor: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Double'>! 

FloatD method! 
_asHigherPrecision

	^self error: 'Unexpected!!'.! 

FloatD method! 
- operand

	<primitive: FloatSubtract 'System.Double' 'System.Double'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

FloatD method! 
* operand

	<primitive: FloatMultiply 'System.Double' 'System.Double'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

FloatD method! 
>= operand

	<primitive: FloatGreatherThanOrEqual 'System.Double' 'System.Double'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

FloatD method! 
<= operand

	<primitive: FloatLessThanOrEqual 'System.Double' 'System.Double'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

FloatD method! 
< operand

	<primitive: FloatLessThan 'System.Double' 'System.Double'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

FloatD method! 
+ operand

	<primitive: FloatAdd 'System.Double' 'System.Double'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

FloatD method! 
negated

	<primitive: FloatNegate 'System.Double'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

FloatD method! 
/ operand

	<primitive: FloatDivide 'System.Double' 'System.Double'>

	^super / operand.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

FloatD method! 
_truncated

	<static: 'System.Math' Truncate 'System.Double'>! 

FloatD method! 
asScaledDecimal: scale

	| i n d v p z t |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i asFloatD.
	p := 0.
	z := self class zero.
	t := self class one * 10.
	[ v = z or: [ p > scale ] ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * t.
		i := v truncated.
		n := n * 10 + i.
		v := v - i asFloatD.
	].
	^(n asScaledDecimal: scale) / (d asScaledDecimal: scale).! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

FloatD method! 
asInteger

	^self rounded.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

FloatD method! 
arcCos

	<static: 'System.Math' Acos 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'ArcCos'! 

FloatD method! 
arcSin

	<static: 'System.Math' Asin 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'ArcSin'! 

FloatD method! 
arcTan

	<static: 'System.Math' Atan 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'ArcTan'! 

FloatD method! 
cos

	<static: 'System.Math' Cos 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Cos'! 

FloatD method! 
sin

	<static: 'System.Math' Sin 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Sin'! 

FloatD method! 
tan

	<static: 'System.Math' Tan 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Tan'! 

FloatD method! 
exp

	<static: 'System.Math' Exp 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Exp'! 

FloatD method! 
ln

	<static: 'System.Math' Log 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Ln'! 

FloatD method! 
log: operand

	^self _log: operand asFloatD.! 

Annotation key: 'ist.runtime.native-name' value: 'Log'! 

FloatD method! 
_log: operand

	<static: 'System.Math' Log 'System.Double' 'System.Double'>! 

FloatD method! 
rounded

	" Optimization "
	self < self class zero
		ifTrue: [ ^(self - 0.5) truncated ]
		ifFalse: [ ^(self + 0.5) truncated ].! 

Annotation key: 'ist.runtime.native-name' value: 'Rounded'! 

FloatD method! 
sqrt

	<static: 'System.Math' Sqrt 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'Sqrt'! 

FloatD method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Double' ToString this 'System.String' 'System.IFormatProvider'>! 

FloatD method! 
printString

	^self _toPrintString: $d.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

FloatD method! 
_floor 

	<static: 'System.Math' Floor 'System.Double'>! 


" FloatE Class Methods " ! 
FloatE classMethod! 
radix
	
	" System.Single uses IEEE 754 binary32 floats "
	^2.! 

Annotation key: 'ist.runtime.native-name' value: 'Radix'! 

FloatE classMethod! 
emin
	" System.Single uses IEEE 754 binary32 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^-125.! 

Annotation key: 'ist.runtime.native-name' value: 'Emin'! 

FloatE classMethod! 
emax
	" System.Single uses IEEE 754 binary32 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^128.! 

Annotation key: 'ist.runtime.native-name' value: 'Emax'! 

FloatE classMethod! 
fmax

	<get_field: 'System.Single' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Fmax'! 

FloatE classMethod! 
precision
	
	" System.Duble uses IEEE 754 binary64 floats "
	^24 " 23 + 1 ".! 

Annotation key: 'ist.runtime.native-name' value: 'Precision'! 


" FloatE Instance Methods " ! 
FloatE method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^410.! 

FloatE method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asFloatE.! 

FloatE method! 
= comparand

	<primitive: FloatEquals 'System.Single' 'System.Single'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

FloatE method! 
> operand

	<primitive: FloatGreatherThan 'System.Single' 'System.Single'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

FloatE method! 
_asBigInteger

	<ctor: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Single'>! 

FloatE method! 
asFloatE

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatE'! 

FloatE method! 
_asHigherPrecision

	^self asFloatD.! 

FloatE method! 
- operand

	<primitive: FloatSubtract 'System.Single' 'System.Single'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

FloatE method! 
* operand

	<primitive: FloatMultiply 'System.Single' 'System.Single'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

FloatE method! 
>= operand

	<primitive: FloatGreatherThanOrEqual 'System.Single' 'System.Single'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

FloatE method! 
<= operand

	<primitive: FloatLessThanOrEqual 'System.Single' 'System.Single'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

FloatE method! 
< operand

	<primitive: FloatLessThan 'System.Single' 'System.Single'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

FloatE method! 
+ operand

	<primitive: FloatAdd 'System.Single' 'System.Single'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

FloatE method! 
negated

	<primitive: FloatNegate 'System.Single'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

FloatE method! 
/ operand

	<primitive: FloatDivide 'System.Single' 'System.Single'>

	^super / operand.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

FloatE method! 
asInteger

	^self rounded.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

FloatE method! 
arcCos

	^self asFloatD arcCos asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcCos'! 

FloatE method! 
arcSin

	^self asFloatD arcSin asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcSin'! 

FloatE method! 
arcTan

	^self asFloatD arcTan asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'ArcTan'! 

FloatE method! 
cos

	^self asFloatD cos asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Cos'! 

FloatE method! 
tan

	^self asFloatD tan asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Tan'! 

FloatE method! 
sin

	^self asFloatD sin asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Sin'! 

FloatE method! 
ln

	^self asFloatD ln asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Ln'! 

FloatE method! 
exp

	^self asFloatD exp asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Exp'! 

FloatE method! 
log: operand

	^(self asFloatD log: operand) asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'Log'! 

FloatE method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Single' ToString this 'System.String' 'System.IFormatProvider'>! 

FloatE method! 
printString

	^self _toPrintString: $e.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 


" Fraction Class Methods " ! 
Fraction classMethod! 
numerator: top denominator: bottom

	| gcd |
	bottom = 1
		ifTrue: [ ^top ].
	top = bottom
		ifTrue: [ ^1 ].
	top = 0
		ifTrue: [ ^0 ].

	gcd := top gcd: bottom.

	gcd = bottom
		ifTrue: [ ^top // bottom ].

	^self basicNew
		_numerator: top // gcd denominator: bottom // gcd;
		yourself.! 

Annotation key: 'ist.runtime.native-name' value: 'Numerator'! 


" Fraction Instance Methods " ! 
Fraction method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^300.! 

Fraction method! 
_numerator: top denominator: bottom

	bottom = 0 
		ifTrue: [ ^self _divideByZero ].
	bottom negative ifTrue: [
		numerator := top negated.
		denominator := bottom negated.
	] ifFalse: [
		numerator := top.
		denominator := bottom.
	].! 

Fraction method! 
printString

	^numerator printString, '/', denominator printString.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Fraction method! 
denominator

	^denominator.! 

Annotation key: 'ist.runtime.native-name' value: 'Denominator'! 

Fraction method! 
numerator

	^numerator.! 

Annotation key: 'ist.runtime.native-name' value: 'Numerator'! 

Fraction method! 
asNativeDecimal

	^numerator asNativeDecimal / denominator asNativeDecimal.! 

Annotation key: 'ist.runtime.native-name' value: 'AsNativeDecimal'! 

Fraction method! 
< operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator < operand numerator ].
		^(numerator * operand denominator) < (operand numerator * denominator).
	].

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Fraction method! 
<= operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator <= operand numerator ].
		^(numerator * operand denominator) <= (operand numerator * denominator).
	].

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Fraction method! 
> operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator > operand numerator ].
		^(numerator * operand denominator) > (operand numerator * denominator).
	].

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Fraction method! 
>= operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator >= operand numerator ].
		^(numerator * operand denominator) >= (operand numerator * denominator).
	].

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Fraction method! 
= comparand

	comparand isNumber ifFalse: [ ^false ].

	comparand isRational ifTrue: [
		" NB: Both rationals are already reduced, so we can do direct compare. "
		^denominator = comparand denominator and: [ numerator = comparand numerator ].
	].

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Fraction method! 
* operand

	operand isRational 
		ifTrue: [ ^(numerator * operand numerator) / (denominator * operand denominator) ].

	^super * operand! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Fraction method! 
+ operand

	operand isRational ifTrue: [ 
		^((numerator * operand denominator) + (operand numerator * denominator)) 
			/ (denominator * operand denominator).
	].

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Fraction method! 
- operand

	operand isRational ifTrue: [ 
		^((numerator * operand denominator) - (operand numerator * denominator)) 
			/ (denominator * operand denominator).
	].

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Fraction method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 

	"
	aNumber isInteger ifTrue: [
		" NB: An integer will always coerce to an integer if sent #asFraction,
			however, we need a Fraction object so _coercionWeight etc. works. "
		^self class basicNew
			_numerator: aNumber denominator: 1;
			yourself.
	].
	^aNumber asFraction.! 

Fraction method! 
/ operand

	operand isRational 
		ifTrue: [ ^(numerator * operand denominator) / (denominator * operand numerator) ].

	^super / operand! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

Fraction method! 
// operand

	operand isRational 
		ifTrue: [ ^(numerator * operand denominator) // (denominator * operand numerator) ].

	^super // operand! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Fraction method! 
truncated

	^numerator quo: denominator.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 

Fraction method! 
_asHigherPrecision

	^self error: 'Unexpected!!'.! 

Fraction method! 
asInt32

	^self asInteger asInt32.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt32'! 

Fraction method! 
asInt64

	^self asInteger asInt64.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt64'! 

Fraction method! 
asInt16

	^self asInteger asInt16.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt16'! 

Fraction method! 
asUInt16

	^self asInteger asUInt16.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt16'! 

Fraction method! 
asUInt32

	^self asInteger asUInt32.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt32'! 

Fraction method! 
asUInt64

	^self asInteger asUInt64.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt64'! 

Fraction method! 
asSByte

	^self asInteger asSByte.! 

Annotation key: 'ist.runtime.native-name' value: 'AsSByte'! 

Fraction method! 
asByte

	^self asInteger asByte.! 

Annotation key: 'ist.runtime.native-name' value: 'AsByte'! 

Fraction method! 
asBigInteger

	^self asInteger asBigInteger.! 

Annotation key: 'ist.runtime.native-name' value: 'AsBigInteger'! 

Fraction method! 
asScaledDecimal: scale

	^(numerator asScaledDecimal: scale) / (denominator asScaledDecimal: scale).! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

Fraction method! 
asInteger

	^self rounded.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

Fraction method! 
asFraction

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

Fraction method! 
asFloatD

	^numerator asFloatD / denominator asFloatD.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Fraction method! 
asFloatE

	^numerator asFloatE / denominator asFloatE.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatE'! 

Fraction method! 
isRational

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsRational'! 


" IdentityDictionary Class Methods " ! 

" IdentityDictionary Instance Methods " ! 

" ImmutableString Class Methods " ! 
ImmutableString classMethod! 
new

	<get_field: 'System.String' Empty>! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

ImmutableString classMethod! 
new: count

	^self new: Space count: count.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

ImmutableString classMethod! 
new: char count: count

	<ctor: 'System.String' char int>! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" ImmutableString Instance Methods " ! 
ImmutableString method! 
, operand

	<static: 'System.String' Concat 'System.String' 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: ','! 

ImmutableString method! 
copyReplacing: targetElement withObject: replacementElement

	<call: 'System.String' Replace this 'System.Char' 'System.Char'>! 

Annotation key: 'ist.runtime.native-name' value: 'CopyReplacing'! 

ImmutableString method! 
copyReplaceAll: targetElements with: replacementElements

	<call: 'System.String' Replace this 'System.String' 'System.String'>

	" TO - DO - Fallback "
	self error: 'TO-DO'.! 

Annotation key: 'ist.runtime.native-name' value: 'CopyReplaceAll'! 

ImmutableString method! 
_indexOf: target

	<call: 'System.String' IndexOf this 'System.Char'>
	^-1. " -1 to get it to 0-based index "! 

ImmutableString method! 
indexOf: target

	^(self _indexOf: target) + 1. " +1 0-based to 1-based "! 

Annotation key: 'ist.runtime.native-name' value: 'IndexOf'! 

ImmutableString method! 
includes: target

	^(self _indexOf: target) >= 0.! 

Annotation key: 'ist.runtime.native-name' value: 'Includes'! 

ImmutableString method! 
asString

	<ctor: _SmalltalkString 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsString'! 

ImmutableString method! 
at: index

	<get_property: 'System.String' this int char>! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 

ImmutableString method! 
asUppercase

	<call: 'System.String' ToUpper this>! 

Annotation key: 'ist.runtime.native-name' value: 'AsUppercase'! 

ImmutableString method! 
asLowercase

	<call: 'System.String' ToLower this>! 

Annotation key: 'ist.runtime.native-name' value: 'AsLowercase'! 


" InitializableCollection Class Methods " ! 

" InitializableCollection Instance Methods " ! 

" Int16 Class Methods " ! 
Int16 classMethod! 
min

	<get_field: 'System.Int16' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

Int16 classMethod! 
max

	<get_field: 'System.Int16' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" Int16 Instance Methods " ! 
Int16 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^120.! 

Int16 method! 
asInt16

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt16'! 

Int16 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asInt16.! 

Int16 method! 
= comparand

	<primitive: IntegerEquals 'System.Int16' 'System.Int16'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Int16 method! 
> operand

	<primitive: IntegerGreatherThan 'System.Int16' 'System.Int16'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Int16 method! 
+ operand

	<primitive: IntegerAdd 'System.Int16' 'System.Int16'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Int16 method! 
_asHigherPrecision

	^self asInt32.! 

Int16 method! 
- operand

	<primitive: IntegerSubtract 'System.Int16' 'System.Int16'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Int16 method! 
* operand

	<primitive: IntegerMultiply 'System.Int16' 'System.Int16'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Int16 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.Int16' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

Int16 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.Int16' 'System.Int16'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Int16 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.Int16' 'System.Int16'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Int16 method! 
< operand

	<primitive: IntegerLessThan 'System.Int16' 'System.Int16'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Int16 method! 
negated

	<primitive: IntegerNegate 'System.Int16'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Int16 method! 
// operand

	<primitive: IntegerDivideFloor 'System.Int16' 'System.Int16'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Int16 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.Int16' 'System.Int16'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

Int16 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.Int16' 'System.Int16'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Int16 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.Int16' 'System.Int16'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Int16 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Int16' ToString this 'System.String' 'System.IFormatProvider'>! 

Int16 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.Int16' 'System.Int16'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

Int16 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.Int16' 'System.Int16'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

Int16 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.Int16' 'System.Int16'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" Int32 Class Methods " ! 
Int32 classMethod! 
max

	<get_field: 'System.Int32' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 

Int32 classMethod! 
min

	<get_field: 'System.Int32' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 


" Int32 Instance Methods " ! 
Int32 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^130.! 

Int32 method! 
- operand

	<primitive: IntegerSubtract 'System.Int32' 'System.Int32'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Int32 method! 
+ operand

	<primitive: IntegerAdd 'System.Int32' 'System.Int32'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Int32 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.Int32' 'System.Int32'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Int32 method! 
> operand

	<primitive: IntegerGreatherThan 'System.Int32' 'System.Int32'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Int32 method! 
= comparand

	<primitive: IntegerEquals 'System.Int32' 'System.Int32'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Int32 method! 
asByte

	<primitive: ConvertChecked 'System.Byte'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsByte'! 

Int32 method! 
asSByte

	<primitive: ConvertChecked 'System.SByte'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsSByte'! 

Int32 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asInt32.! 

Int32 method! 
* operand

	<primitive: IntegerMultiply 'System.Int32' 'System.Int32'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Int32 method! 
_asHigherPrecision

	^self asInt64.! 

Int32 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.Int32' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

Int32 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.Int32' 'System.Int32'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Int32 method! 
< operand

	<primitive: IntegerLessThan 'System.Int32' 'System.Int32'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Int32 method! 
// operand

	<primitive: IntegerDivideFloor 'System.Int32' 'System.Int32'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Int32 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.Int32' 'System.Int32'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

Int32 method! 
negated

	<primitive: IntegerNegate 'System.Int32'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Int32 method! 
gcd: operand

	" Not really needed to do this in primitive, but speeds up a little "
	<static: _RuntimeHelper GCD 'System.Int32' 'System.Int32'>

	^super gcd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Gcd'! 

Int32 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.Int32' 'System.Int32'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Int32 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.Int32' 'System.Int32'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Int32 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Int32' ToString this 'System.String' 'System.IFormatProvider'>! 

Int32 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.Int32' 'System.Int32'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

Int32 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.Int32' 'System.Int32'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

Int32 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.Int32' 'System.Int32'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 

Int32 method! 
asInt32

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt32'! 


" Int64 Class Methods " ! 
Int64 classMethod! 
min

	<get_field: 'System.Int64' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

Int64 classMethod! 
max

	<get_field: 'System.Int64' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" Int64 Instance Methods " ! 
Int64 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^140.! 

Int64 method! 
asInt64

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInt64'! 

Int64 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asInt64.! 

Int64 method! 
= comparand

	<primitive: IntegerEquals 'System.Int64' 'System.Int64'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Int64 method! 
> operand

	<primitive: IntegerGreatherThan 'System.Int64' 'System.Int64'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Int64 method! 
_asHigherPrecision

	^self asBigInteger.! 

Int64 method! 
- operand

	<primitive: IntegerSubtract 'System.Int64' 'System.Int64'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Int64 method! 
* operand

	<primitive: IntegerMultiply 'System.Int64' 'System.Int64'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Int64 method! 
+ operand

	<primitive: IntegerAdd 'System.Int64' 'System.Int64'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Int64 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.Int64' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

Int64 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.Int64' 'System.Int64'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Int64 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.Int64' 'System.Int64'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Int64 method! 
< operand

	<primitive: IntegerLessThan 'System.Int64' 'System.Int64'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Int64 method! 
negated

	<primitive: IntegerNegate 'System.Int64'>

	^super negated.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Int64 method! 
// operand

	<primitive: IntegerDivideFloor 'System.Int64' 'System.Int64'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Int64 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.Int64' 'System.Int64'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

Int64 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.Int64' 'System.Int64'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Int64 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.Int64' 'System.Int64'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Int64 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.Int64' ToString this 'System.String' 'System.IFormatProvider'>! 

Int64 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.Int64' 'System.Int64'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

Int64 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.Int64' 'System.Int64'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

Int64 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.Int64' 'System.Int64'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" Integer Class Methods " ! 

" Integer Instance Methods " ! 
Integer method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^100.! 

Integer method! 
factorial

    self > 1 ifTrue: [ ^(self - 1) factorial * self ].
    self < 0 ifTrue: [ ^self error: 'Invalid input' ].
    ^1.! 

Annotation key: 'ist.runtime.native-name' value: 'Factorial'! 

Integer method! 
bitShift: shift

	" 1. Are we doing negative shifting? "
	self negative
		ifTrue: [ ^(self abs bitShift: shift) negated ].

	" 2. Good chance we are overflowing "
	shift class = Int32
		ifTrue: [ ^self _asHigherPrecision bitShift: shift ].

	" 3. The primitive accept only Int32 as shift argument "
	shift _coercionWeight <= 0 _coercionWeight
		ifTrue: [ ^self bitShift: shift asInt32 ].

	" 4. shift must be very large!! "
	" I don't see idea of trying to shift 2.2e9 bits - we will run out of mem anyway. "
	^self error: 'Overflow'.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

Integer method! 
floor

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Floor'! 

Integer method! 
ceiling

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Ceiling'! 

Integer method! 
rounded

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Rounded'! 

Integer method! 
truncated

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 

Integer method! 
gcd: operand

	| a b r |
	(self = 0 and: [ operand = 0 ])
		ifTrue: [ ^0 ].

	self positive
		ifTrue: [ a := self ]
		ifFalse: [ a := self negated ].
	operand positive
		ifTrue: [ b := operand ]
		ifFalse: [ b := operand negated ].
	[ b = 0 ] whileFalse: [
		r := a \\ b.
		a := b.
		b := r.
	].

	^a.! 

Annotation key: 'ist.runtime.native-name' value: 'Gcd'! 

Integer method! 
/ operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) / operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self / (self _coerce: operand) ].
	^Fraction numerator: self denominator: operand.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

Integer method! 
asFraction

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

Integer method! 
asScaledDecimal: scale

	^(self _asScaledDecimal asScaledDecimal: scale).! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

Integer method! 
_asScaledDecimal
	" 
	If I read X3J20 correctly, the scale should be set to 0 for integers.
	"
	<primitive: ConvertUnchecked _BigDecimal>! 

Annotation key: 'ist.runtime.native-name' value: ''! 

Integer method! 
asInteger

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

Integer method! 
denominator

	^1.! 

Annotation key: 'ist.runtime.native-name' value: 'Denominator'! 

Integer method! 
numerator

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Numerator'! 

Integer method! 
odd

	^(self \\ 2) = 1.! 

Annotation key: 'ist.runtime.native-name' value: 'Odd'! 

Integer method! 
even

	^(self \\ 2) = 0.! 

Annotation key: 'ist.runtime.native-name' value: 'Even'! 

Integer method! 
integerPart

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'IntegerPart'! 

Integer method! 
fractionPart

	^self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'FractionPart'! 

Integer method! 
isRational

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsRational'! 

Integer method! 
isInteger

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsInteger'! 

Integer method! 
quo: operand

	" Just some opttimization ... we'll give another try with integer operations "
	operand isInteger ifTrue: [
		self _coercionWeight < operand _coercionWeight
			ifTrue: [ ^(operand _coerce: self) quo:  operand ].
		self _coercionWeight > operand _coercionWeight
			ifTrue: [ ^self quo:  (self _coerce: operand) ].
	].

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Integer method! 
rem: operand

	" Just some opttimization ... we'll give another try with integer operations "
	operand isInteger ifTrue: [
		self _coercionWeight < operand _coercionWeight
			ifTrue: [ ^(operand _coerce: self) rem: operand ].
		self _coercionWeight > operand _coercionWeight
			ifTrue: [ ^self rem: (self _coerce: operand) ].
	].

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Integer method! 
_toString: format formatProvider: formatProvider

	^self subclassResponsibility.! 

Integer method! 
_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.! 

Integer method! 
printString

	^self _toString: 'D' formatProvider: CultureInfo invariantCulture.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Integer method! 
bitAnd: operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitAnd: operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self bitAnd: (self _coerce: operand) ].
	^self error: 'Implementation bug!!'.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

Integer method! 
bitOr: operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitOr: operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self bitOr: (self _coerce: operand) ].
	^self error: 'Implementation bug!!'.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

Integer method! 
bitXor: operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitXor: operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self bitXor: (self _coerce: operand) ].
	^self error: 'Implementation bug!!'.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 

Integer method! 
anyMask: mask

	^(self bitAnd: mask) ~= 0.! 

Annotation key: 'ist.runtime.native-name' value: 'AnyMask'! 

Integer method! 
allMask: mask

	^(self bitAnd: mask) = mask.! 

Annotation key: 'ist.runtime.native-name' value: 'AllMask'! 

Integer method! 
bitAt: index

	| mask |
	index < 1 
		ifTrue: [ ^self error: 'Invalid index' ].
	mask := 1 bitShift: index - 1.
	(self bitAnd: mask) = 0
		ifTrue: [ ^0 ]
		ifFalse: [ ^1 ].! 

Annotation key: 'ist.runtime.native-name' value: 'BitAt'! 

Integer method! 
bitAt: index put: value

	| mask |
	index < 1 
		ifTrue: [ ^self error: 'Invalid index' ].
	mask := 1 bitShift: index - 1.
	(value bitAnd: 1) = 0 ifTrue: [
		" Turn off the bit "
		(self bitAnd: mask) = 0
			ifTrue: [ ^self ]
			ifFalse: [ ^self - mask " OK, cause not defined for negative numbers " ].
	] ifFalse: [
		" Turn on the bit " 
		(self bitAnd: mask) = 0
			ifTrue: [ ^self bitOr: mask ]
			ifFalse: [ ^self ].
	].! 

Annotation key: 'ist.runtime.native-name' value: 'BitAt'! 

Integer method! 
highBit

	| bits val |
	self < 0 ifTrue: [ ^self error: 'Negative number' ].
	bits := 0.
	val := self.
	" Naïve algorithm :-/ "
	[ val > 0 ] whileTrue: [
		val := val bitShift: -1.
		bits := bits + 1.
	].
	^bits.! 

Annotation key: 'ist.runtime.native-name' value: 'HighBit'! 

Integer method! 
noMask: mask

	^(self bitAnd: mask) = 0.! 

Annotation key: 'ist.runtime.native-name' value: 'NoMask'! 

Integer method! 
lcm: operand

	| a b |
	(self = 0 and: [ operand = 0 ])
		ifTrue: [ ^0 ].
	self < 0 
		ifTrue: [ a := self negated ]
		ifFalse: [ a := self ].
	operand < 0 
		ifTrue: [ b := operand negated ]
		ifFalse: [ b := operand ].
	^a * b // (a gcd: b).! 

Annotation key: 'ist.runtime.native-name' value: 'Lcm'! 

Integer method! 
fibonacci

	^self fibonacciIterative: 1 b: 0.! 

Annotation key: 'ist.runtime.native-name' value: 'Fibonacci'! 

Integer method! 
fibonacciIterative: a b: b

	^self = 0
		ifTrue: [ b ]
		ifFalse: [ (self - 1) fibonacciIterative: a+b b: a ].! 

Annotation key: 'ist.runtime.native-name' value: 'FibonacciIterative'! 

Integer method! 
fibonacciRecursive

	self < 2 
		ifTrue: [ ^self ]
		ifFalse: [ ^(self - 1) fibonacciRecursive + (self - 2) fibonacciRecursive ].! 

Annotation key: 'ist.runtime.native-name' value: 'FibonacciRecursive'! 


" Interval Class Methods " ! 
Interval classMethod! 
with: element1

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

Interval classMethod! 
with: element1 with: element2

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

Interval classMethod! 
with: element1 with: element2 with: element3

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

Interval classMethod! 
with: element1 with: element2 with: element3 with: element4

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

Interval classMethod! 
withAll: newElements

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'WithAll'! 

Interval classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

Interval classMethod! 
new: count

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

Interval classMethod! 
from: start to: stop

	^self from: start to: stop by: 1.! 

Annotation key: 'ist.runtime.native-name' value: 'From'! 

Interval classMethod! 
from: start to: stop by: step

	^self basicNew
		_from: start to: stop by: step;
		yourself.! 

Annotation key: 'ist.runtime.native-name' value: 'From'! 


" Interval Instance Methods " ! 
Interval method! 
_from: startArg to: stopArg by: stepArg

	start := startArg.
	stop := stopArg.
	step := stepArg.! 

Interval method! 
printString

	^start printString.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 


" Magnitude Class Methods " ! 

" Magnitude Instance Methods " ! 
Magnitude method! 
between: min and: max

	^min <= self and: [ self <= max ].! 

Annotation key: 'ist.runtime.native-name' value: 'Between'! 

Magnitude method! 
max: operand

	self > operand
		ifTrue: [ ^self ]
		ifFalse: [ ^operand ].! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 

Magnitude method! 
min: operand

	self < operand 
		ifTrue: [ ^self ]
		ifFalse: [ ^operand ].! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

Magnitude method! 
< operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Magnitude method! 
<= operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Magnitude method! 
> operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Magnitude method! 
>= operand

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 


" MessageNotUnderstood Class Methods " ! 

" MessageNotUnderstood Instance Methods " ! 
MessageNotUnderstood method! 
isResumable

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsResumable'! 

MessageNotUnderstood method! 
message

	^message.! 

Annotation key: 'ist.runtime.native-name' value: 'Message'! 

MessageNotUnderstood method! 
receiver

	^receiver.! 

Annotation key: 'ist.runtime.native-name' value: 'Receiver'! 


" MonadicBlock Class Methods " ! 

" MonadicBlock Instance Methods " ! 
MonadicBlock method! 
value: argument

	<static: _RuntimeHelper BlockValue 'System.Func`2[[System.Object], [System.Object]]' 'System.Object'>! 

Annotation key: 'ist.runtime.native-name' value: 'Value'! 

MonadicBlock method! 
argumentCount

	^1.! 

Annotation key: 'ist.runtime.native-name' value: 'ArgumentCount'! 


" NativeArray Class Methods " ! 

" NativeArray Instance Methods " ! 

" NativeObject Class Methods " ! 
NativeObject classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" NativeObject Instance Methods " ! 
NativeObject method! 
= comparand

	<static: object Equals object object>! 

Annotation key: 'ist.runtime.native-name' value: '='! 


" NiladicBlock Class Methods " ! 

" NiladicBlock Instance Methods " ! 
NiladicBlock method! 
value

	<static: _RuntimeHelper BlockValue 'System.Func`1[[System.Object]]'>! 

Annotation key: 'ist.runtime.native-name' value: 'Value'! 

NiladicBlock method! 
_timeToRun

	| start end |
	start := SimpleDateTime now.
	self value.
	end := SimpleDateTime now.
	^(end - start) asMilliseconds.! 

NiladicBlock method! 
argumentCount

	^0.! 

Annotation key: 'ist.runtime.native-name' value: 'ArgumentCount'! 

NiladicBlock method! 
whileFalse
	"
	This method will get inlined.
	"
	[ self value ] whileFalse: [ ].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'WhileFalse'! 

NiladicBlock method! 
whileTrue
	"
	This method will get inlined.
	"
	[ self value ] whileTrue: [ ].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'WhileTrue'! 

NiladicBlock method! 
whileFalse: iterationBlock
	"
	This method will get inlined.
	"
	[ self value ] whileFalse: [ iterationBlock value ].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'WhileFalse'! 

NiladicBlock method! 
whileTrue: iterationBlock
	"
	This method will get inlined.
	"
	[ self value ] whileTrue: [ iterationBlock value ].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'WhileTrue'! 


" Notification Class Methods " ! 

" Notification Instance Methods " ! 
Notification method! 
isResumable

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsResumable'! 

Notification method! 
defaultAction

	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'DefaultAction'! 


" Number Class Methods " ! 
Number classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

Number classMethod! 
_divideByZero

	^self error: 'Zero Division'.! 

Number classMethod! 
zero

	^zero.! 

Annotation key: 'ist.runtime.native-name' value: 'Zero'! 

Number classMethod! 
one

	^one.! 

Annotation key: 'ist.runtime.native-name' value: 'One'! 


" Number Instance Methods " ! 
Number method! 
to: stop by: step do: operation
	" Normally, this is inlined "
	| i |
	step = 0 ifTrue: [ self error: 'step = 0' ].
	i := self.
	step > 0 ifTrue: [
		[ i <= stop ] whileTrue: [
			operation value: i.
			i := i + step.
		].
	] ifFalse: [
		[ stop <= i ] whileTrue: [
			operation value: i.
			i := i + step.
		].
	].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'To'! 

Number method! 
to: stop do: operation
	" Normally, this is inlined "
	| i |
	i := self.
	[ i <= stop ] whileTrue: [
		operation value: i.
		i := i + 1.
	].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'To'! 

Number method! 
squared

	^self * self.! 

Annotation key: 'ist.runtime.native-name' value: 'Squared'! 

Number method! 
strictlyPositive

	^self > self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'StrictlyPositive'! 

Number method! 
negative

	 ^self < self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'Negative'! 

Number method! 
abs

	self < self class zero
		ifTrue: [ ^self negated ]
		ifFalse: [ ^self ].! 

Annotation key: 'ist.runtime.native-name' value: 'Abs'! 

Number method! 
sign

	self > self class zero ifTrue: [ ^1 ].
	self < self class zero ifTrue: [ ^-1 ].
	^0.! 

Annotation key: 'ist.runtime.native-name' value: 'Sign'! 

Number method! 
positive

	^self >= self class zero.! 

Annotation key: 'ist.runtime.native-name' value: 'Positive'! 

Number method! 
asFloat

	^self asFloatD.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloat'! 

Number method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^self subclassResponsibility.! 

Number method! 
asFloatQ

	^self asFloatD.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatQ'! 

Number method! 
< operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) < operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self < (self _coerce: operand) ].
	^self _asHigherPrecision < operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

Number method! 
asInt16

	<primitive: ConvertChecked 'System.Int16'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asByte

	^self asInt32 asByte.! 

Annotation key: 'ist.runtime.native-name' value: 'AsByte'! 

Number method! 
asInt32

	<primitive: ConvertChecked 'System.Int32'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asInt64

	<primitive: ConvertChecked 'System.Int64'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asUInt16

	<primitive: ConvertChecked 'System.UInt16'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asUInt32

	<primitive: ConvertChecked 'System.UInt32'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asUInt64

	<primitive: ConvertChecked 'System.UInt64'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asSByte

	^self asInt32 asSByte.! 

Annotation key: 'ist.runtime.native-name' value: 'AsSByte'! 

Number method! 
asFloatD

	<primitive: ConvertUnchecked 'System.Double'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatD'! 

Number method! 
asFloatE

	<primitive: ConvertUnchecked 'System.Single'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatE'! 

Number method! 
asFraction

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'AsFraction'! 

Number method! 
asInteger

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'AsInteger'! 

Number method! 
asScaledDecimal: scale

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'AsScaledDecimal'! 

Number method! 
asBigInteger

	<primitive: ConvertUnchecked 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsBigInteger'! 

Number method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^self subclassResponsibility.! 

Number method! 
isNumber
	"
	Answer true if the receiver is a number.
	"
	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsNumber'! 

Number method! 
timesRepeat: operation 
	" 
	Normally, this is inlined.
	Usually, this is implemented on Integer,
	but I see no problem on having it on Number,
	for example two-and-a-half times repeat
	will perform the block 2 times.
	"
	| i |
	i := 1.
	[ i <= self ] whileTrue: [
		operation value.
		i := i + 1.
	].
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'TimesRepeat'! 

Number method! 
= comparand

	comparand isNumber ifFalse: [ ^false ].

	self _coercionWeight < comparand _coercionWeight
		ifTrue: [ ^(comparand _coerce: self) = comparand ].
	self _coercionWeight > comparand _coercionWeight
		ifTrue: [ ^self = (self _coerce: comparand) ].
	^self _asHigherPrecision = comparand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

Number method! 
> operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) > operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self > (self _coerce: operand) ].
	^self _asHigherPrecision > operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

Number method! 
_asHigherPrecision
	"
	This converts the receiver to numeric class that can contain larger numbers 
	than the receiver's class. For example:
	SByte	=> Int16	
	Byte	=> Int16	NB: Notice for unsigned, we go to signed so aritmetics can be done!!
	Int16	=> Int32
	UInt16	=> Int32
	Int32	=> Int64
	UInt32	=> Int64
	Int64	=> BigInteger
	UInt64	=> BigInteger
	BigInteger => !!!!ERROR!!!!   ... this is already unlimited precision, so we won't need larger!!
	FloatE	=> FloatD
	FloatD	=> !!!!ERROR!!!!   ... we don't have anything else than Double (64-bit floats).
	Decimal => BigDecimal
	BigDecimal => !!!!ERROR!!!!   ... this is already unlimited precision, so we won't need larger!!

	A type of number never changes to another type, e.g. Integer will not change to Float!!
	"
	^self subclassResponsibility.! 

Number method! 
+ operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) + operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self + (self _coerce: operand) ].
	^self _asHigherPrecision + operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

Number method! 
- operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) - operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self - (self _coerce: operand) ].
	^self _asHigherPrecision - operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

Number method! 
* operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) * operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self * (self _coerce: operand) ].
	^self _asHigherPrecision * operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

Number method! 
<= operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) <= operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self <= (self _coerce: operand) ].
	^self _asHigherPrecision <= operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

Number method! 
>= operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) >= operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self >= (self _coerce: operand) ].
	^self _asHigherPrecision >= operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

Number method! 
// operand

	operand = self class zero
		ifTrue: [ ^self _divideByZero ].
	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) // operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self // (self _coerce: operand) ].
	^self error: 'Implementation bug!!'.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

Number method! 
\\ operand
	" (receiver // operand) * operand + (receiver \\ operand) = receiver "
	^self - ((self // operand) * operand).! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

Number method! 
_divideByZero

	^self class _divideByZero.! 

Number method! 
to: stop

	^Interval from: self to: stop.! 

Annotation key: 'ist.runtime.native-name' value: 'To'! 

Number method! 
to: stop by: step

	^Interval from: self to: stop by: step.! 

Annotation key: 'ist.runtime.native-name' value: 'To'! 

Number method! 
negated

	^self class zero - self.! 

Annotation key: 'ist.runtime.native-name' value: 'Negated'! 

Number method! 
/ operand

	self _coercionWeight < operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) / operand ].
	self _coercionWeight > operand _coercionWeight
		ifTrue: [ ^self / (self _coerce: operand) ].
	^self _asHigherPrecision / operand _asHigherPrecision.! 

Annotation key: 'ist.runtime.native-name' value: '/'! 

Number method! 
asNativeDecimal

	<primitive: ConvertUnchecked 'System.Decimal'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsFloatQ'! 

Number method! 
floor

	^self // self class one.! 

Annotation key: 'ist.runtime.native-name' value: 'Floor'! 

Number method! 
ceiling

	| val |
	val := self // self class one.
	val = self ifTrue: [ ^val ].
	^val + self class one.! 

Annotation key: 'ist.runtime.native-name' value: 'Ceiling'! 

Number method! 
isRational

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsRational'! 

Number method! 
reciprocal

	^self class one / self.! 

Annotation key: 'ist.runtime.native-name' value: 'Reciprocal'! 

Number method! 
truncated

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Truncated'! 

Number method! 
fractionPart

	^self - self integerPart.! 

Annotation key: 'ist.runtime.native-name' value: 'FractionPart'! 

Number method! 
integerPart

	^self _coerce: self truncated.! 

Annotation key: 'ist.runtime.native-name' value: 'IntegerPart'! 

Number method! 
quo: operand

	^(self / operand) truncated.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

Number method! 
raisedTo: operand

	operand isInteger ifTrue: [ ^self raisedToInteger: operand ].
	^(self asFloat ln * operand) exp.! 

Annotation key: 'ist.runtime.native-name' value: 'RaisedTo'! 

Number method! 
raisedToInteger: operand

	| result |
	operand isInteger
		ifFalse: [ ^self error: '#raisedToInteger: requires an integer operand' ].

	operand < 0 ifTrue: [ ^(self raisedToInteger: operand negated) reciprocal ].
	operand = 0 ifTrue: [ ^self class one ].
	operand = 1 ifTrue: [ ^self ].

	result := self.
	2 to: operand do: [ :i | result := result * self ].
	^result.! 

Annotation key: 'ist.runtime.native-name' value: 'RaisedToInteger'! 

Number method! 
rem: operand

	^self - ((self quo: operand) * operand).! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

Number method! 
rounded

	self < self class zero
		ifTrue: [ ^(self - (self class one / 2)) truncated ]
		ifFalse: [ ^(self + (self class one / 2)) truncated ].! 

Annotation key: 'ist.runtime.native-name' value: 'Rounded'! 

Number method! 
roundTo: factor

	^(self / factor) rounded * factor.! 

Annotation key: 'ist.runtime.native-name' value: 'RoundTo'! 

Number method! 
sqrt

	^self asFloatD sqrt.! 

Annotation key: 'ist.runtime.native-name' value: 'Sqrt'! 

Number method! 
truncateTo: factor

	^(self quo: factor) * factor.! 

Annotation key: 'ist.runtime.native-name' value: 'TruncateTo'! 

Number method! 
printString

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Number method! 
between: min and: max

	^min <= self and: [ self <= max ].! 

Annotation key: 'ist.runtime.native-name' value: 'Between'! 


" NumberFormatInfo Class Methods " ! 

" NumberFormatInfo Instance Methods " ! 

" Object Class Methods " ! 
Object classMethod! 
new

	<call: _SmalltalkClass NewObject this>! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" Object Instance Methods " ! 
Object method! 
yourself

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Yourself'! 

Object method! 
isNil

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsNil'! 

Object method! 
notNil

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'NotNil'! 

Object method! 
hash

	<call: object GetHashCode this>! 

Annotation key: 'ist.runtime.native-name' value: 'Hash'! 

Object method! 
identityHash

	<call: object GetHashCode this>! 

Annotation key: 'ist.runtime.native-name' value: 'IdentityHash'! 

Object method! 
printString

	<call: object ToString this>! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

Object method! 
printOn: target

	target nextPutAll: self printString.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintOn'! 

Object method! 
subclassResponsibility

	self error: 'My subclass should have overridden one of my messages.'.! 

Annotation key: 'ist.runtime.native-name' value: 'SubclassResponsibility'! 

Object method! 
class

	<primitive: ObjectClass>! 

Annotation key: 'ist.runtime.native-name' value: 'Class'! 

Object method! 
_doesNotUnderstand: selector arguments: arguments

	^self doesNotUnderstand: (FailedMessage _selector: selector arguments: arguments).! 

Annotation key: 'ist.runtime.native-name' value: ''! 

Object method! 
invalidMessage

	self error: 'Invalid message'.! 

Annotation key: 'ist.runtime.native-name' value: 'InvalidMessage'! 

Object method! 
isNumber
	"
	Answer true if the receiver is a number.
	"
	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsNumber'! 

Object method! 
__createException: signalerText

	<ctor: 'System.ApplicationException' 'System.String'>! 

Object method! 
__error: exception

	<static: _RuntimeHelper Throw 'System.Exception'>! 

Object method! 
error: signalerText

	self __error: (self __createException: signalerText).! 

Annotation key: 'ist.runtime.native-name' value: 'Error'! 

Object method! 
isInteger

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'IsInteger'! 

Object method! 
doesNotUnderstand: message

	^self error: self printString, ' does not understand #', message selector asString.! 

Annotation key: 'ist.runtime.native-name' value: 'DoesNotUnderstand'! 

Object method! 
isMemberOf: candidateClass

	^self class = candidateClass.! 

Annotation key: 'ist.runtime.native-name' value: 'IsMemberOf'! 


" OrderedCollection Class Methods " ! 

" OrderedCollection Instance Methods " ! 

" ReadStream Class Methods " ! 

" ReadStream Instance Methods " ! 

" ReadWriteStream Class Methods " ! 

" ReadWriteStream Instance Methods " ! 

" SByte Class Methods " ! 
SByte classMethod! 
min

	<get_field: 'System.SByte' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

SByte classMethod! 
max

	<get_field: 'System.SByte' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" SByte Instance Methods " ! 
SByte method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^110.! 

SByte method! 
asSByte

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsSByte'! 

SByte method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asSByte.! 

SByte method! 
= comparand

	<primitive: IntegerEquals 'System.SByte' 'System.SByte'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

SByte method! 
> operand

	<primitive: IntegerGreatherThan 'System.SByte' 'System.SByte'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

SByte method! 
+ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

SByte method! 
_asHigherPrecision

	^self asInt16.! 

SByte method! 
- operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

SByte method! 
* operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

SByte method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.SByte' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

SByte method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.SByte' 'System.SByte'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

SByte method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.SByte' 'System.SByte'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

SByte method! 
< operand

	<primitive: IntegerLessThan 'System.SByte' 'System.SByte'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

SByte method! 
// operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

SByte method! 
\\ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

SByte method! 
quo: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

SByte method! 
rem: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

SByte method! 
_toString: format formatProvider: formatProvider

	<call: 'System.SByte' ToString this 'System.String' 'System.IFormatProvider'>! 

SByte method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.SByte' 'System.SByte'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

SByte method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.SByte' 'System.SByte'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

SByte method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.SByte' 'System.SByte'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" ScaledDecimal Class Methods " ! 

" ScaledDecimal Instance Methods " ! 
ScaledDecimal method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^200.! 

ScaledDecimal method! 
scale

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'Scale'! 


" SequencedCollection Class Methods " ! 

" SequencedCollection Instance Methods " ! 

" SequencedReadableCollection Class Methods " ! 

" SequencedReadableCollection Instance Methods " ! 
SequencedReadableCollection method! 
do: operation

	1 to: self size do: [ :idx |
		operation value: (self at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'Do'! 

SequencedReadableCollection method! 
_ivalidIndex: index

	^self error: 'Index ', index asString, ' does not exist.'.! 

SequencedReadableCollection method! 
first

	^self at: 1.! 

Annotation key: 'ist.runtime.native-name' value: 'First'! 

SequencedReadableCollection method! 
last

	^self at: self size.! 

Annotation key: 'ist.runtime.native-name' value: 'Last'! 

SequencedReadableCollection method! 
with: otherCollection do: operation

	self size = otherCollection size
		ifFalse: [ ^self error: 'Collections must have same size' ].
	1 to: self size do: [ :idx |
		operation value: (self at: idx) value: (otherCollection at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

SequencedReadableCollection method! 
reverseDo: operation

	self size to: 1 by: -1 do: [ :idx |
		operation value: (self at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'ReverseDo'! 

SequencedReadableCollection method! 
indexOf: target

	1 to: self size do: [ :idx |
		(self at: idx) = target ifTrue: [ ^idx ].
	].
	^0.! 

Annotation key: 'ist.runtime.native-name' value: 'IndexOf'! 

SequencedReadableCollection method! 
indexOf: target ifAbsent: exceptionHandler

	| idx |
	idx := self indexOf: target.
	idx = 0 ifFalse: [ ^idx ].
	^exceptionHandler value.! 

Annotation key: 'ist.runtime.native-name' value: 'IndexOf'! 

SequencedReadableCollection method! 
from: start to: stop do: operation

	start to: stop do: [ :idx |
		operation value: (self at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'From'! 

SequencedReadableCollection method! 
from: start to: stop keysAndValuesDo: operation

	start to: stop do: [ :idx |
		operation value: idx value: (self at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'From'! 

SequencedReadableCollection method! 
keysAndValuesDo: operation

	1 to: self size do: [ :idx |
		operation value: idx value: (self at: idx).
	].! 

Annotation key: 'ist.runtime.native-name' value: 'KeysAndValuesDo'! 

SequencedReadableCollection method! 
findFirst: discriminator

	1 to: self size do: [ :idx |
		(discriminator value: (self at: idx)) ifTrue: [ ^idx ].
	].
	^0.! 

Annotation key: 'ist.runtime.native-name' value: 'FindFirst'! 

SequencedReadableCollection method! 
findLast: discriminator

	self size to: 1 by: -1 do: [ :idx |
		(discriminator value: (self at: idx)) ifTrue: [ ^idx ].
	].
	^0.! 

Annotation key: 'ist.runtime.native-name' value: 'FindLast'! 

SequencedReadableCollection method! 
at: index

	^self subclassResponsibility.! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 

SequencedReadableCollection method! 
at: index ifAbsent: exceptionBlock

	(index between: 1 and: self size)
		ifTrue: [ ^self at: index ]
		ifFalse: [ ^exceptionBlock value ].! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 

SequencedReadableCollection method! 
before: target ifAbsent: exceptionBlock

	| index |
	index := self indexOf: target.
	(index between: 2 and: self size)
		ifTrue: [ ^self at: index - 1 ]
		ifFalse: [ ^exceptionBlock value ].! 

Annotation key: 'ist.runtime.native-name' value: 'Before'! 

SequencedReadableCollection method! 
before: target

	^self before: target ifAbsent: [ self error: 'Element was not found in the collection' ].! 

Annotation key: 'ist.runtime.native-name' value: 'Before'! 

SequencedReadableCollection method! 
after: target ifAbsent: exceptionBlock

	| index |
	index := self indexOf: target.
	(index between: 1 and: self size - 1)
		ifTrue: [ ^self at: index + 1 ]
		ifFalse: [ ^exceptionBlock value ].! 

Annotation key: 'ist.runtime.native-name' value: 'After'! 

SequencedReadableCollection method! 
after: target

	^self after: target ifAbsent: [ self error: 'Element was not found in the collection' ].! 

Annotation key: 'ist.runtime.native-name' value: 'After'! 

SequencedReadableCollection method! 
= comparand

	self class = comparand class 
		ifFalse: [ ^false ].
	self size = comparand size 
		ifFalse: [ ^false ].
	1 to: self size do: [ :idx |
		(self at: idx) = (comparand at: idx)
			ifFalse: [ ^false ].
	].
	^true.! 

Annotation key: 'ist.runtime.native-name' value: '='! 


" Set Class Methods " ! 

" Set Instance Methods " ! 

" SignedInteger Class Methods " ! 

" SignedInteger Instance Methods " ! 

" SimpleDateTime Class Methods " ! 
SimpleDateTime classMethod! 
now

	<get_property: 'System.DateTime' Now 'System.DateTime'>! 

Annotation key: 'ist.runtime.native-name' value: 'Now'! 

SimpleDateTime classMethod! 
year: year month: month day: dayOfMonth hour: hour minute: minute second: second

	<ctor: 'System.DateTime' int int int int int int>! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

SimpleDateTime classMethod! 
year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: offset

	self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

SimpleDateTime classMethod! 
year: year day: dayOfYear hour: hour minute: minute second: second offset: offset

	self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

SimpleDateTime classMethod! 
year: year day: dayOfYear hour: hour minute: minute second: second

	| monthStartDay |
	monthStartDay := 0.
	1 to: 12 do: [ :month |
		| daysInMonth |
		daysInMonth := self _daysIn: year month: month.
		dayOfYear <= (monthStartDay + daysInMonth) ifTrue: [
			| day |
			day := dayOfYear - monthStartDay.
			^self year: year month: month day: day hour: hour minute: minute second: second.
		].
		monthStartDay := monthStartDay + daysInMonth.
	].
	^self error: 'Invalid dayOfYear'.! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

SimpleDateTime classMethod! 
_daysIn: year month: month

	<static: 'System.DateTime' DaysInMonth int int>! 

SimpleDateTime classMethod! 
isLeapYear: year

	<static: 'System.DateTime' IsLeapYear int>! 

Annotation key: 'ist.runtime.native-name' value: 'IsLeapYear'! 

SimpleDateTime classMethod! 
clockPrecision
	"
	According to MSDN (See System.DateTime::Now):
	The resolution of this property depends on the system timer.
		System: Windows NT 3.5 and later
		Approximate Resolution: 10 milliseconds
	"
	^Duration days: 0 hours: 0 minutes: 0 seconds: 0 milliseconds: 10.! 

Annotation key: 'ist.runtime.native-name' value: 'ClockPrecision'! 

SimpleDateTime classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" SimpleDateTime Instance Methods " ! 
SimpleDateTime method! 
= comparand

	<primitive: Equals 'System.DateTime' 'System.DateTime'>

	comparand class = DateTime 
		ifFalse: [ ^super = comparand ]
		ifTrue: [ ^self asDateTime = comparand ].! 

Annotation key: 'ist.runtime.native-name' value: '='! 

SimpleDateTime method! 
month

	<get_property: 'System.DateTime' Month int>! 

Annotation key: 'ist.runtime.native-name' value: 'Month'! 

SimpleDateTime method! 
asDateTime

	<ctor: 'System.DateTimeOffset' 'System.DateTime'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsDateTime'! 

SimpleDateTime method! 
hour

	<get_property: 'System.DateTime' Hour int>! 

Annotation key: 'ist.runtime.native-name' value: 'Hour'! 

SimpleDateTime method! 
hour24

	<get_property: 'System.DateTime' Hour int>! 

Annotation key: 'ist.runtime.native-name' value: 'Hour24'! 

SimpleDateTime method! 
year

	<get_property: 'System.DateTime' Year int>! 

Annotation key: 'ist.runtime.native-name' value: 'Year'! 

SimpleDateTime method! 
dayOfMonth

	<get_property: 'System.DateTime' Day int>! 

Annotation key: 'ist.runtime.native-name' value: 'DayOfMonth'! 

SimpleDateTime method! 
dayOfYear

	<get_property: 'System.DateTime' DayOfYear int>! 

Annotation key: 'ist.runtime.native-name' value: 'DayOfYear'! 

SimpleDateTime method! 
second

	<get_property: 'System.DateTime' Second int>! 

Annotation key: 'ist.runtime.native-name' value: 'Second'! 

SimpleDateTime method! 
minute

	<get_property: 'System.DateTime' Minute int>! 

Annotation key: 'ist.runtime.native-name' value: 'Minute'! 

SimpleDateTime method! 
isLeapYear

	^self class isLeapYear: self year.! 

Annotation key: 'ist.runtime.native-name' value: 'IsLeapYear'! 

SimpleDateTime method! 
hour12

	| hour |
	hour := self hour24.
	hour = 0 ifTrue: [ ^12 ].
	hour > 12 ifTrue: [ ^hour - 12 ].
	^hour.! 

Annotation key: 'ist.runtime.native-name' value: 'Hour12'! 

SimpleDateTime method! 
- operand

	<primitive: Subtract 'System.DateTime' 'System.DateTime'>! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

SimpleDateTime method! 
< operand

	<primitive: LessThan 'System.DateTime' 'System.DateTime'>

	^self asDateTime < operand asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

SimpleDateTime method! 
<= operand

	<primitive: LessThanOrEqual 'System.DateTime' 'System.DateTime'>

	^self asDateTime <= operand asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

SimpleDateTime method! 
>= operand

	<primitive: GreatherThanOrEqual 'System.DateTime' 'System.DateTime'>

	^self asDateTime >= operand asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

SimpleDateTime method! 
> operand

	<primitive: GreatherThan 'System.DateTime' 'System.DateTime'>

	^self asDateTime > operand asDateTime.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

SimpleDateTime method! 
+ operand

	<primitive: Add 'System.DateTime' 'System.TimeSpan'>! 

Annotation key: 'ist.runtime.native-name' value: '+'! 


" SmalltalkRuntime Class Methods " ! 

" SmalltalkRuntime Instance Methods " ! 
SmalltalkRuntime method! 
getSmalltalkClassForType: aType
	" 
	DANGER!!
	Extreme care must be taken here not to do something 
	that will require this method to be re-enteres with 
	the same parameters, or we will end in endless recursion.
	"
	aType isArray 
		ifTrue: [ ^NativeArray ].
	((SystemType getType: 'System.Collections.IEnumerable') isAssignableFrom: aType)
		ifTrue: [ ^Enumerable ].
	
	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'GetSmalltalkClassForType'! 


" SortedCollection Class Methods " ! 

" SortedCollection Instance Methods " ! 

" String Class Methods " ! 
String classMethod! 
new

	^self new: 0.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

String classMethod! 
_new: count

	<ctor: _SmalltalkString int>! 

String classMethod! 
new: count

	^self new: count asInt32.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 

String classMethod! 
with: element1

	<ctor: _SmalltalkString char>! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

String classMethod! 
with: element1 with: element2

	<ctor: _SmalltalkString char char>! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

String classMethod! 
with: element1 with: element2 with: element3

	<ctor: _SmalltalkString char char char>! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

String classMethod! 
with: element1 with: element2 with: element3 with: element4

	<ctor: _SmalltalkString char char char char>! 

Annotation key: 'ist.runtime.native-name' value: 'With'! 

String classMethod! 
withAll: newElements copyContents: copyContents
	
	| result |
	" Try to optimize ... if we got the collection as char-array "
	<ctor: _SmalltalkString 'System.Char[]' bool>

	" Fallback "
	result := self new: newElements size.
	1 to: newElements size do: [ :idx |
		result at: idx put: (newElements at: idx).
	].

	^result.! 

Annotation key: 'ist.runtime.native-name' value: 'WithAll'! 

String classMethod! 
withAll: newElements

	^self withAll: newElements copyContents: true.! 

Annotation key: 'ist.runtime.native-name' value: 'WithAll'! 


" String Instance Methods " ! 
String method! 
asString

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsString'! 

String method! 
asImmutableString

	<primitive: ConvertUnchecked string>! 

Annotation key: 'ist.runtime.native-name' value: 'AsImmutableString'! 

String method! 
_contents

	<get_field: _SmalltalkString Contents>! 

String method! 
at: index put: newElement

	<set_property: _SmalltalkString this int char>! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 

String method! 
asLowercase

	<call: _SmalltalkString ToLower this>! 

Annotation key: 'ist.runtime.native-name' value: 'AsLowercase'! 

String method! 
asUppercase

	<call: _SmalltalkString ToUpper this>! 

Annotation key: 'ist.runtime.native-name' value: 'AsUppercase'! 

String method! 
at: index

	<get_property: _SmalltalkString this int char>! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 

String method! 
at: index ifAbsent: exceptionBlock

	| _exception |
	<get_property: _SmalltalkString this int char>
	^_exception.! 

Annotation key: 'ist.runtime.native-name' value: 'At'! 


" Symbol Class Methods " ! 

" Symbol Instance Methods " ! 
Symbol method! 
asSymbol

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsSymbol'! 

Symbol method! 
asString

	<primitive: ConvertChecked 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'AsString'! 


" SystemType Class Methods " ! 
SystemType classMethod! 
delimiter

	<get_field: 'System.Type' Delimiter>! 

Annotation key: 'ist.runtime.native-name' value: 'Delimiter'! 

SystemType classMethod! 
emptyTypes 

	<get_field: 'System.Type' EmptyTypes>! 

Annotation key: 'ist.runtime.native-name' value: 'EmptyTypes'! 

SystemType classMethod! 
missing 

	<get_field: 'System.Type' Missing>! 

Annotation key: 'ist.runtime.native-name' value: 'Missing'! 

SystemType classMethod! 
reflectionOnlyGetType: typeName throwIfNotFound: throwIfNotFound ignoreCase: ignoreCase 

	<static: 'System.Type' ReflectionOnlyGetType string bool bool>! 

Annotation key: 'ist.runtime.native-name' value: 'ReflectionOnlyGetType'! 

SystemType classMethod! 
getTypeFromProgID: progID server: server throwOnError: throwOnError 

	<static: 'System.Type' GetTypeFromProgID string string bool>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromProgID'! 

SystemType classMethod! 
getTypeFromProgID: progID server: server 

	<static: 'System.Type' GetTypeFromProgID string string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromProgID'! 

SystemType classMethod! 
getTypeFromProgID: progID throwOnError: throwOnError 

	<static: 'System.Type' GetTypeFromProgID string bool>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromProgID'! 

SystemType classMethod! 
getTypeFromProgID: progID 

	<static: 'System.Type' GetTypeFromProgID string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromProgID'! 

SystemType classMethod! 
getTypeFromCLSID: clsid server: server throwOnError: throwOnError 

	<static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.String' 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromCLSID'! 

SystemType classMethod! 
getTypeFromCLSID: clsid server: server 

	<static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromCLSID'! 

SystemType classMethod! 
getTypeFromCLSID: clsid  

	<static: 'System.Type' GetTypeFromCLSID 'System.Guid'>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromCLSID'! 

SystemType classMethod! 
getTypeFromCLSID: clsid throwOnError: throwOnError 

	<static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeFromCLSID'! 

SystemType classMethod! 
getTypeCode: aType

	<static: 'System.Type' GetTypeCode 'System.Type'>! 

Annotation key: 'ist.runtime.native-name' value: 'GetTypeCode'! 

SystemType classMethod! 
getType: typeName throwOnError: throwOnError ignoreCase: ignoreCase

	<static: 'System.Type' GetType string bool bool>! 

Annotation key: 'ist.runtime.native-name' value: 'GetType'! 

SystemType classMethod! 
getType: typeName throwOnError: throwOnError

	<static: 'System.Type' GetType string bool>! 

Annotation key: 'ist.runtime.native-name' value: 'GetType'! 

SystemType classMethod! 
getType: typeName 

	<static: 'System.Type' GetType string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetType'! 


" SystemType Instance Methods " ! 
SystemType method! 
assemblyQualifiedName

	<get_property: 'System.Type' AssemblyQualifiedName 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'AssemblyQualifiedName'! 

SystemType method! 
baseType

	<get_property: 'System.Type' BaseType 'System.Type'>! 

Annotation key: 'ist.runtime.native-name' value: 'BaseType'! 

SystemType method! 
containsGenericParameters 

	<get_property: 'System.Type' ContainsGenericParameters 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'ContainsGenericParameters'! 

SystemType method! 
declaringType 

	<get_property: 'System.Type' DeclaringType 'System.Type'>! 

Annotation key: 'ist.runtime.native-name' value: 'DeclaringType'! 

SystemType method! 
fullName 

	<get_property: 'System.Type' FullName 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'FullName'! 

SystemType method! 
guid

	<get_property: 'System.Type' GUID 'System.Guid'>! 

Annotation key: 'ist.runtime.native-name' value: 'Guid'! 

SystemType method! 
hasElementType 

	<get_property: 'System.Type' HasElementType 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'HasElementType'! 

SystemType method! 
isAbstract 

	<get_property: 'System.Type' IsAbstract 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsAbstract'! 

SystemType method! 
isArray

	<get_property: 'System.Type' IsArray 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsArray'! 

SystemType method! 
isByRef

	<get_property: 'System.Type' IsByRef 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsByRef'! 

SystemType method! 
isClass

	<get_property: 'System.Type' IsClass 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsClass'! 

SystemType method! 
isCOMObject

	<get_property: 'System.Type' IsCOMObject 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsCOMObject'! 

SystemType method! 
isEnum

	<get_property: 'System.Type' IsEnum 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsEnum'! 

SystemType method! 
isGenericParameter

	<get_property: 'System.Type' IsGenericParameter 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsGenericParameter'! 

SystemType method! 
isGenericType

	<get_property: 'System.Type' IsGenericType 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsGenericType'! 

SystemType method! 
isGenericTypeDefinition

	<get_property: 'System.Type' IsGenericTypeDefinition 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsGenericTypeDefinition'! 

SystemType method! 
isInterface

	<get_property: 'System.Type' IsInterface 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsInterface'! 

SystemType method! 
isNested

	<get_property: 'System.Type' IsNested 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNested'! 

SystemType method! 
isNestedAssembly

	<get_property: 'System.Type' IsNestedAssembly 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedAssembly'! 

SystemType method! 
isNestedFamily

	<get_property: 'System.Type' IsNestedFamily 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedFamily'! 

SystemType method! 
isNestedPublic

	<get_property: 'System.Type' IsNestedPublic 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedPublic'! 

SystemType method! 
isNestedPrivate

	<get_property: 'System.Type' IsNestedPrivate 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedPrivate'! 

SystemType method! 
isNestedFamORAssem

	<get_property: 'System.Type' IsNestedFamORAssem 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedFamORAssem'! 

SystemType method! 
isNotPublic

	<get_property: 'System.Type' IsNotPublic 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNotPublic'! 

SystemType method! 
isPointer

	<get_property: 'System.Type' IsPointer 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsPointer'! 

SystemType method! 
isPrimitive

	<get_property: 'System.Type' IsPrimitive 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsPrimitive'! 

SystemType method! 
isPublic

	<get_property: 'System.Type' IsPublic 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsPublic'! 

SystemType method! 
isSealed

	<get_property: 'System.Type' IsSealed 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsSealed'! 

SystemType method! 
isSerializable

	<get_property: 'System.Type' IsSerializable 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsSerializable'! 

SystemType method! 
isSpecialName

	<get_property: 'System.Type' IsSpecialName 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsSpecialName'! 

SystemType method! 
isValueType

	<get_property: 'System.Type' IsValueType 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsValueType'! 

SystemType method! 
isVisible

	<get_property: 'System.Type' IsVisible 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsVisible'! 

SystemType method! 
name

	<get_property: 'System.Type' Name 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'Name'! 

SystemType method! 
namespace

	<get_property: 'System.Type' Namespace 'System.String'>! 

Annotation key: 'ist.runtime.native-name' value: 'Namespace'! 

SystemType method! 
isNestedFamANDAssem

	<get_property: 'System.Type' IsNestedFamANDAssem 'System.Boolean'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsNestedFamANDAssem'! 

SystemType method! 
isSubclassOf: aType

	<call: 'System.Type' IsSubclassOf this 'System.Type'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsSubclassOf'! 

SystemType method! 
getInterfaces

	<call: 'System.Type' GetInterfaces this>! 

Annotation key: 'ist.runtime.native-name' value: 'GetInterfaces'! 

SystemType method! 
getInterface: name

	<call: 'System.Type' GetInterface this string>! 

Annotation key: 'ist.runtime.native-name' value: 'GetInterface'! 

SystemType method! 
getInterface: name ignoreCase: ignoreCase 

	<call: 'System.Type' GetInterface this string bool>! 

Annotation key: 'ist.runtime.native-name' value: 'GetInterface'! 

SystemType method! 
isAssignableFrom: aType

	<call: 'System.Type' IsAssignableFrom this 'System.Type'>! 

Annotation key: 'ist.runtime.native-name' value: 'IsAssignableFrom'! 

SystemType method! 
getGenericTypeDefinition 

	<call: 'System.Type' GetGenericTypeDefinition this>! 

Annotation key: 'ist.runtime.native-name' value: 'GetGenericTypeDefinition'! 

SystemType method! 
getDefaultMembers

	<call: 'System.Type' GetDefaultMembers this>! 

Annotation key: 'ist.runtime.native-name' value: 'GetDefaultMembers'! 


" True Class Methods " ! 

" True Instance Methods " ! 
True method! 
& operand

	^operand.! 

Annotation key: 'ist.runtime.native-name' value: '&'! 

True method! 
| operand

	^true.! 

Annotation key: 'ist.runtime.native-name' value: '|'! 

True method! 
and: operand

	^operand value.! 

Annotation key: 'ist.runtime.native-name' value: 'And'! 

True method! 
eqv: operand

	^operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Eqv'! 

True method! 
ifFalse: operand

	^nil.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

True method! 
ifFalse: falseOperand ifTrue: trueOperand

	^trueOperand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfFalse'! 

True method! 
ifTrue: trueOperand ifFalse: falseOperand

	^trueOperand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

True method! 
ifTrue: operand

	^operand value.! 

Annotation key: 'ist.runtime.native-name' value: 'IfTrue'! 

True method! 
not

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'Not'! 

True method! 
or: operand

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'Or'! 

True method! 
printString

	^'true'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

True method! 
xor: operand

	^operand not.! 

Annotation key: 'ist.runtime.native-name' value: 'Xor'! 

True method! 
printOn: target

	target nextPutAll: 'true'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintOn'! 


" UInt16 Class Methods " ! 
UInt16 classMethod! 
min

	<get_field: 'System.UInt16' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

UInt16 classMethod! 
max

	<get_field: 'System.UInt16' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" UInt16 Instance Methods " ! 
UInt16 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^120.! 

UInt16 method! 
asUInt16

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt16'! 

UInt16 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asUInt16.! 

UInt16 method! 
= comparand

	<primitive: IntegerEquals 'System.UInt16' 'System.UInt16'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

UInt16 method! 
> operand

	<primitive: IntegerGreatherThan 'System.UInt16' 'System.UInt16'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

UInt16 method! 
_asHigherPrecision

	^self asInt32.! 

UInt16 method! 
- operand

	<primitive: IntegerSubtract 'System.UInt16' 'System.UInt16'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

UInt16 method! 
* operand

	<primitive: IntegerMultiply 'System.UInt16' 'System.UInt16'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

UInt16 method! 
+ operand

	<primitive: IntegerAdd 'System.UInt16' 'System.UInt16'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

UInt16 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.UInt16' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

UInt16 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.UInt16' 'System.UInt16'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

UInt16 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.UInt16' 'System.UInt16'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

UInt16 method! 
< operand

	<primitive: IntegerLessThan 'System.UInt16' 'System.UInt16'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

UInt16 method! 
// operand

	<primitive: IntegerDivideFloor 'System.UInt16' 'System.UInt16'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

UInt16 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.UInt16' 'System.UInt16'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

UInt16 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.UInt16' 'System.UInt16'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

UInt16 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.UInt16' 'System.UInt16'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

UInt16 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.UInt16' ToString this 'System.String' 'System.IFormatProvider'>! 

UInt16 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.UInt16' 'System.UInt16'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

UInt16 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.UInt16' 'System.UInt16'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

UInt16 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.UInt16' 'System.UInt16'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" UInt32 Class Methods " ! 
UInt32 classMethod! 
min

	<get_field: 'System.UInt32' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

UInt32 classMethod! 
max

	<get_field: 'System.UInt32' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" UInt32 Instance Methods " ! 
UInt32 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^130.! 

UInt32 method! 
asUInt32

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt32'! 

UInt32 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asUInt32.! 

UInt32 method! 
= comparand

	<primitive: IntegerEquals 'System.UInt32' 'System.UInt32'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

UInt32 method! 
> operand

	<primitive: IntegerGreatherThan 'System.UInt32' 'System.UInt32'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

UInt32 method! 
_asHigherPrecision

	^self asInt64.! 

UInt32 method! 
- operand

	<primitive: IntegerSubtract 'System.UInt32' 'System.UInt32'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

UInt32 method! 
* operand

	<primitive: IntegerMultiply 'System.UInt32' 'System.UInt32'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

UInt32 method! 
+ operand

	<primitive: IntegerAdd 'System.UInt32' 'System.UInt32'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

UInt32 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.UInt32' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

UInt32 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.UInt32' 'System.UInt32'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

UInt32 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.UInt32' 'System.UInt32'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

UInt32 method! 
< operand

	<primitive: IntegerLessThan 'System.UInt32' 'System.UInt32'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

UInt32 method! 
// operand

	<primitive: IntegerDivideFloor 'System.UInt32' 'System.UInt32'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

UInt32 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.UInt32' 'System.UInt32'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

UInt32 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.UInt32' 'System.UInt32'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

UInt32 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.UInt32' 'System.UInt32'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

UInt32 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.UInt32' ToString this 'System.String' 'System.IFormatProvider'>! 

UInt32 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.UInt32' 'System.UInt32'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

UInt32 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.UInt32' 'System.UInt32'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

UInt32 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.UInt32' 'System.UInt32'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" UInt64 Class Methods " ! 
UInt64 classMethod! 
min

	<get_field: 'System.UInt64' MinValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Min'! 

UInt64 classMethod! 
max

	<get_field: 'System.UInt64' MaxValue>! 

Annotation key: 'ist.runtime.native-name' value: 'Max'! 


" UInt64 Instance Methods " ! 
UInt64 method! 
_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^140.! 

UInt64 method! 
asUInt64

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'AsUInt64'! 

UInt64 method! 
_coerce: aNumber
	"
	Converts <aNumber> to the same class as the receiver. 
	"
	^aNumber asUInt64.! 

UInt64 method! 
= comparand

	<primitive: IntegerEquals 'System.UInt64' 'System.UInt64'>

	^super = comparand.! 

Annotation key: 'ist.runtime.native-name' value: '='! 

UInt64 method! 
> operand

	<primitive: IntegerGreatherThan 'System.UInt64' 'System.UInt64'>

	^super > operand.! 

Annotation key: 'ist.runtime.native-name' value: '>'! 

UInt64 method! 
_asHigherPrecision

	^self asBigInteger.! 

UInt64 method! 
- operand

	<primitive: IntegerSubtract 'System.UInt64' 'System.UInt64'>

	^super - operand.! 

Annotation key: 'ist.runtime.native-name' value: '-'! 

UInt64 method! 
* operand

	<primitive: IntegerMultiply 'System.UInt64' 'System.UInt64'>

	^super * operand.! 

Annotation key: 'ist.runtime.native-name' value: '*'! 

UInt64 method! 
+ operand

	<primitive: IntegerAdd 'System.UInt64' 'System.UInt64'>

	^super + operand.! 

Annotation key: 'ist.runtime.native-name' value: '+'! 

UInt64 method! 
bitShift: shift

	<primitive: IntegerBitShift 'System.UInt64' 'System.Int32'>

	^super bitShift: shift.! 

Annotation key: 'ist.runtime.native-name' value: 'BitShift'! 

UInt64 method! 
>= operand

	<primitive: IntegerGreatherThanOrEqual 'System.UInt64' 'System.UInt64'>

	^super >= operand.! 

Annotation key: 'ist.runtime.native-name' value: '>='! 

UInt64 method! 
<= operand

	<primitive: IntegerLessThanOrEqual 'System.UInt64' 'System.UInt64'>

	^super <= operand.! 

Annotation key: 'ist.runtime.native-name' value: '<='! 

UInt64 method! 
< operand

	<primitive: IntegerLessThan 'System.UInt64' 'System.UInt64'>

	^super < operand.! 

Annotation key: 'ist.runtime.native-name' value: '<'! 

UInt64 method! 
// operand

	<primitive: IntegerDivideFloor 'System.UInt64' 'System.UInt64'>

	^super // operand.! 

Annotation key: 'ist.runtime.native-name' value: '//'! 

UInt64 method! 
\\ operand

	<primitive: IntegerRemainderFloor 'System.UInt64' 'System.UInt64'>

	^super \\ operand.! 

Annotation key: 'ist.runtime.native-name' value: '\\'! 

UInt64 method! 
quo: operand

	<primitive: IntegerDivideTruncate 'System.UInt64' 'System.UInt64'>

	^super quo: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Quo'! 

UInt64 method! 
rem: operand

	<primitive: IntegerRemainderTruncate 'System.UInt64' 'System.UInt64'>

	^super rem: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'Rem'! 

UInt64 method! 
_toString: format formatProvider: formatProvider

	<call: 'System.UInt64' ToString this 'System.String' 'System.IFormatProvider'>! 

UInt64 method! 
bitAnd: operand

	<primitive: IntegerBitAnd 'System.UInt64' 'System.UInt64'>

	^super bitAnd: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitAnd'! 

UInt64 method! 
bitOr: operand

	<primitive: IntegerBitOr 'System.UInt64' 'System.UInt64'>

	^super bitOr: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitOr'! 

UInt64 method! 
bitXor: operand

	<primitive: IntegerBitXor 'System.UInt64' 'System.UInt64'>

	^super bitXor: operand.! 

Annotation key: 'ist.runtime.native-name' value: 'BitXor'! 


" UndefinedObject Class Methods " ! 
UndefinedObject classMethod! 
new

	^self invalidMessage.! 

Annotation key: 'ist.runtime.native-name' value: 'New'! 


" UndefinedObject Instance Methods " ! 
UndefinedObject method! 
isNil

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsNil'! 

UndefinedObject method! 
notNil

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'NotNil'! 

UndefinedObject method! 
hash

	^19761214.! 

Annotation key: 'ist.runtime.native-name' value: 'Hash'! 

UndefinedObject method! 
identityHash

	^19761214.! 

Annotation key: 'ist.runtime.native-name' value: 'IdentityHash'! 

UndefinedObject method! 
copy

	^self.! 

Annotation key: 'ist.runtime.native-name' value: 'Copy'! 

UndefinedObject method! 
printString

	^'nil'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintString'! 

UndefinedObject method! 
printOn: target

	target nextPutAll: 'nil'.! 

Annotation key: 'ist.runtime.native-name' value: 'PrintOn'! 


" UnsignedInteger Class Methods " ! 

" UnsignedInteger Instance Methods " ! 
UnsignedInteger method! 
negative

	^false.! 

Annotation key: 'ist.runtime.native-name' value: 'Negative'! 

UnsignedInteger method! 
positive

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'Positive'! 


" Warning Class Methods " ! 

" Warning Instance Methods " ! 

" WriteStream Class Methods " ! 

" WriteStream Instance Methods " ! 

" ZeroDivide Class Methods " ! 

" ZeroDivide Instance Methods " ! 
ZeroDivide method! 
isResumable

	^true.! 

Annotation key: 'ist.runtime.native-name' value: 'IsResumable'! 

ZeroDivide method! 
dividend

	^dividend.! 

Annotation key: 'ist.runtime.native-name' value: 'Dividend'! 


" Initializers (in execution sorted order) " ! 
BigDecimal initializer! 
zero := 0s.
one := 1s.! 

DateAndTime initializer! 
DateTime! 

BigInteger initializer! 
zero := 0 asBigInteger.
one := 1 asBigInteger.! 

Byte initializer! 
zero := 0 asByte.
one := 1 asByte.! 

CharacterConstants initializerFor: 'Ack'! 
Character codePoint: 6! 

CharacterConstants initializerFor: 'Backspace'! 
Character codePoint: 8! 

CharacterConstants initializerFor: 'Bel'! 
Character codePoint: 7! 

CharacterConstants initializerFor: 'Bell'! 
Character codePoint: 7! 

CharacterConstants initializerFor: 'Bs'! 
Character codePoint: 8! 

CharacterConstants initializerFor: 'Can'! 
Character codePoint: 24! 

CharacterConstants initializerFor: 'Cr'! 
Character codePoint: 13! 

CharacterConstants initializerFor: 'Dc1'! 
Character codePoint: 17! 

CharacterConstants initializerFor: 'Dc2'! 
Character codePoint: 18! 

CharacterConstants initializerFor: 'Dc3'! 
Character codePoint: 19! 

CharacterConstants initializerFor: 'Dc4'! 
Character codePoint: 20! 

CharacterConstants initializerFor: 'Del'! 
Character codePoint: 127! 

CharacterConstants initializerFor: 'Dle'! 
Character codePoint: 16! 

CharacterConstants initializerFor: 'Em'! 
Character codePoint: 25! 

CharacterConstants initializerFor: 'Enq'! 
Character codePoint: 5! 

CharacterConstants initializerFor: 'Eot'! 
Character codePoint: 4! 

CharacterConstants initializerFor: 'Esc'! 
Character codePoint: 27! 

CharacterConstants initializerFor: 'Etb'! 
Character codePoint: 23! 

CharacterConstants initializerFor: 'Etx'! 
Character codePoint: 3! 

CharacterConstants initializerFor: 'Ff'! 
Character codePoint: 12! 

CharacterConstants initializerFor: 'Fs'! 
Character codePoint: 28! 

CharacterConstants initializerFor: 'Gs'! 
Character codePoint: 29! 

CharacterConstants initializerFor: 'Ht'! 
Character codePoint: 9! 

CharacterConstants initializerFor: 'Lf'! 
Character codePoint: 10! 

CharacterConstants initializerFor: 'Nak'! 
Character codePoint: 21! 

CharacterConstants initializerFor: 'Nul'! 
Character codePoint: 0! 

CharacterConstants initializerFor: 'Null'! 
Character codePoint: 0! 

CharacterConstants initializerFor: 'Rs'! 
Character codePoint: 30! 

CharacterConstants initializerFor: 'Si'! 
Character codePoint: 15! 

CharacterConstants initializerFor: 'So'! 
Character codePoint: 14! 

CharacterConstants initializerFor: 'Soh'! 
Character codePoint: 1! 

CharacterConstants initializerFor: 'Space'! 
Character codePoint: 32! 

CharacterConstants initializerFor: 'Stx'! 
Character codePoint: 2! 

CharacterConstants initializerFor: 'Sub'! 
Character codePoint: 26! 

CharacterConstants initializerFor: 'Syn'! 
Character codePoint: 22! 

CharacterConstants initializerFor: 'Tab'! 
Character codePoint: 9! 

CharacterConstants initializerFor: 'Us'! 
Character codePoint: 31! 

CharacterConstants initializerFor: 'VerticalTab'! 
Character codePoint: 11! 

CharacterConstants initializerFor: 'Vt'! 
Character codePoint: 11! 

Decimal initializer! 
zero := 0 asNativeDecimal.
one := 1 asNativeDecimal.! 

Float initializer! 
FloatD! 

Fraction initializer! 
zero := 0.
one := 1.! 

Int16 initializer! 
zero := 0 asInt16.
one := 1 asInt16.! 

Int32 initializer! 
zero := 0 asInt32.
one := 1 asInt32.! 

Int64 initializer! 
zero := 0 asInt64.
one := 1 asInt64.! 

SByte initializer! 
zero := 0 asSByte.
one := 1 asSByte.! 

UInt16 initializer! 
zero := 0 asUInt16.
one := 1 asUInt16.! 

UInt32 initializer! 
zero := 0 asUInt32.
one := 1 asUInt32.! 

UInt64 initializer! 
zero := 0 asUInt64.
one := 1 asUInt64.! 

FloatD initializer! 
zero := 0.0d0 asFloatD.
one := 1.0d0 asFloatD.! 

FloatE initializer! 
zero := 0.0e0 asFloatE.
one := 1.0e0 asFloatE.! 

Transcript initializer! 
Console " ... Console class implements the Transcript protocol "! 

FloatQ initializer! 
FloatD! 

Class named: 'AConstancts'
	superclass: 'Object'
	indexedInstanceVariables: #'none'
	instanceVariableNames: ''
	classVariableNames: ''
	sharedPools: ''
	classInstanceVariableNames: ''! 

	
AConstancts method! 
array1

	^#().! 
	
AConstancts method! 
array2a

	^#(123).! 	
	
AConstancts method! 
array2b

	^#('ABC').! 
	
AConstancts method! 
array3

	^#(123 'ABC').! 
	
AConstancts method! 
array4

	^#(123 'ABC' #(456.78)).! 	
	
AConstancts method! 
array5

	^#(123 #ABC #(456.78)).!
	
AConstancts method! 
array6

	^#(123 'ABC' #('DEF')).!	
	
AConstancts method! 
array7

	^#(true false #true #false nil #(#nil)).!		
	
AConstancts method! 
true

	^true.!	
	
AConstancts method! 
false

	^false.!	

AConstancts method! 
string

	^'ABC'.!	
	
AConstancts method! 
smallInt

	^1.!
	
AConstancts method! 
smallInt2

	^1234567.!	

AConstancts method! 
dec1

	^123.45s.!	
	
AConstancts method! 
dec2

	^0s.!	
	
AConstancts method! 
dec3

	^1s.!	

AConstancts method! 
dec4

	^123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789.45s.!		

AConstancts method! 
nil

	^nil.!	
	
AConstancts method! 
largeInt

	^1234567889012345.!	
	
AConstancts method! 
float

	^123.45.!	
	
AConstancts method! 
float0

	^0.0.!		
	
AConstancts method! 
floatE

	^123.45e1!	
	
AConstancts method! 
floatE0

	^0.0e1!		

AConstancts method! 
floatD

	^123.45d1!		
	
AConstancts method! 
floatD0

	^0.0d1!		
	
AConstancts method! 
char

	^$T!	

AConstancts method! 
char1

	^$д !		
	
AConstancts method! 
symbol1

	^#ABC!		
	
AConstancts method! 
symbol2

	^#'Iron Smalltalk'!		
	
AConstancts method! 
symbol3

	^#Array!	
	
AConstancts method! 
symbol4

	^#Array!	
	
Global constant: 'GlobalConst'! 

Global variable: 'GlobalVar'! 

AConstancts method! 
globalConst

	^GlobalConst!
	
AConstancts method! 
globalVar

	^GlobalVar!	
	
AConstancts method! 
setGlobalVar

	GlobalVar := 1.!
	
Global initializer!

	Transcript show: 'Hello World'.!