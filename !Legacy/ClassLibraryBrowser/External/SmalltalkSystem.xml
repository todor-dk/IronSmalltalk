<?xml version="1.0" encoding="utf-8"?>
<SmalltalkSystem xmlns="http://schemas.ironsmalltalk.org/version1.0/Tools/SmalltalkSystem.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="SmalltalkSystem.xsd">
  <SystemDescription xmlns="http://schemas.ironsmalltalk.org/version1.0/Tools/SystemDescription.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="SystemDescription.xsd">
    <Protocol name="Object" docId="5.3.1" abstract="false">
      <ConformsTo protocol="ANY" />
      <Description>This protocol describe the behavior that is common to all objects.</Description>
      <StandardGlobal name="Integer">
        <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies integer objects.</Description>
      </StandardGlobal>
      <StandardGlobal name="Number">
        <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies number objects.</Description>
      </StandardGlobal>
      <StandardGlobal name="ScaledDecimal">
        <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies scaled decimal objects.</Description>
      </StandardGlobal>
      <StandardGlobal name="Symbol">
        <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies objects that conform to the protocol &amp;lt;symbol&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="=" docId="5.3.1.1" refined="false">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="==" docId="5.3.1.2" refined="false">
        <Synopsis>Object identity test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are the same object. Return &lt;em&gt;true&lt;/em&gt; if the receiver is the same object as &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver == comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand == receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver == comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;identity hash value&lt;/em&gt; s. Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver == comparand receiver identityHash = comparand identityHash&lt;/p&gt;</Definition>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="~=" docId="5.3.1.3" refined="false">
        <Synopsis>Object inequality test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are not &lt;em&gt;equivalent&lt;/em&gt; objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is not &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The result must be &lt;em&gt;equivalent&lt;/em&gt; to the Boolean negation of the result of sending the message &lt;code&gt;#=&lt;/code&gt; to the receiver with &lt;code&gt;comparand&lt;/code&gt; as the argument.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver ~= comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand ~= receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="~~" docId="5.3.1.4" refined="false">
        <Synopsis>Negated object identity test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are different objects. Return &lt;em&gt;true&lt;/em&gt; if the receiver is not the same object as &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The result must be equivalent to the Boolean negation of the result of sending the message &lt;code&gt;#==&lt;/code&gt; to the receiver with &lt;code&gt;comparand&lt;/code&gt; as the argument.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver ~~ comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand ~~ receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="class" docId="5.3.1.5" refined="false">
        <Synopsis>Determine the class of the receiver.</Synopsis>
        <Definition protocol="Object">If the receiver is an instance object, return the &lt;em&gt;class object&lt;/em&gt; defined by the &lt;em&gt;class definition&lt;/em&gt; that defines the behavior of the receiver. If the receiver is itself a &lt;em&gt;class object&lt;/em&gt; , the result is unspecified except that it must conform to the protocol &amp;lt;classDescription&amp;gt;.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="classDescription" />
        </ReturnValue>
      </Message>
      <Message selector="copy" docId="5.3.1.6" refined="false">
        <Synopsis>Return a copy of the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Return a new object that must be as similar as possible to the receiver in its initial state and behavior. Any operation that changes the state of the new object should not as a side-effect change the state or behavior of the receiver. Similarly, any change to the receiver should not as a side-effect change the new object.&lt;/p&gt;&lt;p&gt; If the receiver is an &lt;em&gt;identity object&lt;/em&gt; , return the receiver.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="doesNotUnderstand:" docId="5.3.1.7" refined="false">
        <Synopsis>A message was sent to the receiver for which the receiver has no behavior.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A message was sent to the receiver for which the receiver has no behavior. Signal a MessageNotUnderstood exception corresponding to the failed message. If the exception resumes, the resumption value is returned as the value of this message.&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message to perform some action other than signaling the exception.&lt;/p&gt;</Definition>
        <Parameter name="message" aliasing="unspecified">
          <Protocol name="failedMessage" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="error:" docId="5.3.1.8" refined="false">
        <Synopsis>Announce an error</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message is used the announce the occurrence of some type of error condition. The argument should describe the nature of the error. The default behavior is to raise an Error exception as if the message &lt;code&gt;#signal:&lt;/code&gt; had been sent to the global Error with &lt;code&gt;signalerText&lt;/code&gt; as the argument.&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message to perform some action other than signaling the exception.&lt;/p&gt;</Definition>
        <Parameter name="signalerText" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
      </Message>
      <Message selector="hash" docId="5.3.1.9" refined="false">
        <Synopsis>Return an integer hash code that can be used in conjunction with an &lt;code&gt;#=&lt;/code&gt; comparison.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;An integer value that can be used as a hash code for the receiver is returned. The hash code is intended for use in conjunction with an &lt;code&gt;#=&lt;/code&gt; comparison.&lt;/p&gt;&lt;p&gt; The range, minimum, and maximum values of the result is implementation defined.&lt;/p&gt;&lt;p&gt; Any two objects that are considered &lt;em&gt;equivalent&lt;/em&gt; using the &lt;code&gt;#=&lt;/code&gt; message must have the same hash value. More formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The &lt;em&gt;hash value&lt;/em&gt; of an object need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#hash&lt;/code&gt; with the same receiver may not always yield the same results. Note that collections that use &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose  hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="identityHash" docId="5.3.1.10" refined="false">
        <Synopsis>Return an integer hash code that can be used in conjunction with an &lt;code&gt;#==&lt;/code&gt; (identity) comparison.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;An integer value that can be used as a hash code for the receiver is returned. The hash code is intended for use in conjunction with an &lt;code&gt;#==&lt;/code&gt; comparison.&lt;/p&gt;&lt;p&gt; The range, minimum, or maximum values of the result is implementation defined.&lt;/p&gt;&lt;p&gt; The identity hash of an object must be &lt;em&gt;temporally invariant&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="isKindOf:" docId="5.3.1.11" refined="false">
        <Synopsis>Classify an object.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver is an instance of &lt;code&gt;candidateClass&lt;/code&gt; or is an instance of a &lt;em&gt;general&lt;/em&gt; &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;candidateClass&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The return value is unspecified if the receiver is a &lt;em&gt;class object&lt;/em&gt; or &lt;code&gt;candidateClass&lt;/code&gt; is not a &lt;em&gt;class&lt;/em&gt; &lt;em&gt;object&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="candidateClass" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isMemberOf:" docId="5.3.1.12" refined="false">
        <Synopsis>Determine whether the receiver is an instance of the argument.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver is an instance of &lt;code&gt;candidateClass&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The return value is unspecified if the receiver is a &lt;em&gt;class object&lt;/em&gt; or &lt;code&gt;candidateClass&lt;/code&gt; is not a &lt;em&gt;class&lt;/em&gt; &lt;em&gt;object&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="candidateClass" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isNil" docId="5.3.1.13" refined="false">
        <Synopsis>Determine if the receiver is the value of the reserved identifier &lt;em&gt;nil&lt;/em&gt; .</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Determine if the receiver is the same object as the value of the reserved identifier &lt;em&gt;nil&lt;/em&gt; . Return &lt;em&gt;true&lt;/em&gt; if it is, &lt;em&gt;false&lt;/em&gt; if it is not.&lt;/p&gt;&lt;p&gt; The messages &lt;code&gt;#isNil&lt;/code&gt; and &lt;code&gt;#notNil&lt;/code&gt; must be implemented to produce consistent results. For a given receiver if the result of &lt;code&gt;#isNil&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the result of &lt;code&gt;#notNil&lt;/code&gt; must be &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="notNil" docId="5.3.1.14" refined="false">
        <Synopsis>Determine if the receiver is not the value of the reserved identifier &lt;em&gt;nil&lt;/em&gt; .</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Determine if the receiver is the same object as the value of the reserved identifier &lt;em&gt;nil&lt;/em&gt; . Return &lt;em&gt;false&lt;/em&gt; if it is, &lt;em&gt;true&lt;/em&gt; if it is not.&lt;/p&gt;&lt;p&gt; The messages &lt;code&gt;#isNil&lt;/code&gt; and &lt;code&gt;#notNil&lt;/code&gt; must be implemented to produce consistent results. For a given receiver if the result of &lt;code&gt;#isNil&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the result of &lt;code&gt;#notNil&lt;/code&gt; must be &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="perform:" docId="5.3.1.15" refined="false">
        <Synopsis>Send a message using a computed message selector.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Send to the receiver a message whose selector is &lt;code&gt;selector&lt;/code&gt; and whose arguments are &lt;code&gt;argument1&lt;/code&gt; , &lt;code&gt;argument2&lt;/code&gt; , etc. Return the value of that message.&lt;/p&gt;&lt;p&gt; If the receiver does not have a method for &lt;code&gt;selector&lt;/code&gt; normal &amp;quot;message not understood&amp;quot; processing is performed as if the computed message hand been sent using a message send expression. If this occurs, &lt;code&gt;selector and the arguments&lt;/code&gt; may be captured.&lt;/p&gt;&lt;p&gt; The perform messages and &lt;code&gt;#respondsTo:&lt;/code&gt; must be implemented to produce consistent results. A message to perform a selector, &lt;code&gt;selector&lt;/code&gt; , for a given receiver will result in a &amp;quot;message not understood&amp;quot; condition if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver respondsTo: selector&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Behavior is undefined if the number of arguments does not match that implicitly required by  the syntactic form of the &lt;code&gt;selector&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="unspecified">
          <Protocol name="selector" />
        </Parameter>
        <Parameter name="argument1" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument2" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument3" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
          <Description>The protocol specification of the returned value of this method is not really useful for any sort of static analysis. In practice the returned value will be treated as conforming to the return type of the message that is dynamically constructed.</Description>
        </ReturnValue>
      </Message>
      <Message selector="perform:with:" docId="5.3.1.15" refined="false">
        <Synopsis>Send a message using a computed message selector.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Send to the receiver a message whose selector is &lt;code&gt;selector&lt;/code&gt; and whose arguments are &lt;code&gt;argument1&lt;/code&gt; , &lt;code&gt;argument2&lt;/code&gt; , etc. Return the value of that message.&lt;/p&gt;&lt;p&gt; If the receiver does not have a method for &lt;code&gt;selector&lt;/code&gt; normal &amp;quot;message not understood&amp;quot; processing is performed as if the computed message hand been sent using a message send expression. If this occurs, &lt;code&gt;selector and the arguments&lt;/code&gt; may be captured.&lt;/p&gt;&lt;p&gt; The perform messages and &lt;code&gt;#respondsTo:&lt;/code&gt; must be implemented to produce consistent results. A message to perform a selector, &lt;code&gt;selector&lt;/code&gt; , for a given receiver will result in a &amp;quot;message not understood&amp;quot; condition if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver respondsTo: selector&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Behavior is undefined if the number of arguments does not match that implicitly required by  the syntactic form of the &lt;code&gt;selector&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="unspecified">
          <Protocol name="selector" />
        </Parameter>
        <Parameter name="argument1" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument2" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument3" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
          <Description>The protocol specification of the returned value of this method is not really useful for any sort of static analysis. In practice the returned value will be treated as conforming to the return type of the message that is dynamically constructed.</Description>
        </ReturnValue>
      </Message>
      <Message selector="perform:with:with:" docId="5.3.1.15" refined="false">
        <Synopsis>Send a message using a computed message selector.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Send to the receiver a message whose selector is &lt;code&gt;selector&lt;/code&gt; and whose arguments are &lt;code&gt;argument1&lt;/code&gt; , &lt;code&gt;argument2&lt;/code&gt; , etc. Return the value of that message.&lt;/p&gt;&lt;p&gt; If the receiver does not have a method for &lt;code&gt;selector&lt;/code&gt; normal &amp;quot;message not understood&amp;quot; processing is performed as if the computed message hand been sent using a message send expression. If this occurs, &lt;code&gt;selector and the arguments&lt;/code&gt; may be captured.&lt;/p&gt;&lt;p&gt; The perform messages and &lt;code&gt;#respondsTo:&lt;/code&gt; must be implemented to produce consistent results. A message to perform a selector, &lt;code&gt;selector&lt;/code&gt; , for a given receiver will result in a &amp;quot;message not understood&amp;quot; condition if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver respondsTo: selector&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Behavior is undefined if the number of arguments does not match that implicitly required by  the syntactic form of the &lt;code&gt;selector&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="unspecified">
          <Protocol name="selector" />
        </Parameter>
        <Parameter name="argument1" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument2" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument3" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
          <Description>The protocol specification of the returned value of this method is not really useful for any sort of static analysis. In practice the returned value will be treated as conforming to the return type of the message that is dynamically constructed.</Description>
        </ReturnValue>
      </Message>
      <Message selector="perform:with:with:with:" docId="5.3.1.15" refined="false">
        <Synopsis>Send a message using a computed message selector.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Send to the receiver a message whose selector is &lt;code&gt;selector&lt;/code&gt; and whose arguments are &lt;code&gt;argument1&lt;/code&gt; , &lt;code&gt;argument2&lt;/code&gt; , etc. Return the value of that message.&lt;/p&gt;&lt;p&gt; If the receiver does not have a method for &lt;code&gt;selector&lt;/code&gt; normal &amp;quot;message not understood&amp;quot; processing is performed as if the computed message hand been sent using a message send expression. If this occurs, &lt;code&gt;selector and the arguments&lt;/code&gt; may be captured.&lt;/p&gt;&lt;p&gt; The perform messages and &lt;code&gt;#respondsTo:&lt;/code&gt; must be implemented to produce consistent results. A message to perform a selector, &lt;code&gt;selector&lt;/code&gt; , for a given receiver will result in a &amp;quot;message not understood&amp;quot; condition if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver respondsTo: selector&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Behavior is undefined if the number of arguments does not match that implicitly required by  the syntactic form of the &lt;code&gt;selector&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="unspecified">
          <Protocol name="selector" />
        </Parameter>
        <Parameter name="argument1" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument2" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument3" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
          <Description>The protocol specification of the returned value of this method is not really useful for any sort of static analysis. In practice the returned value will be treated as conforming to the return type of the message that is dynamically constructed.</Description>
        </ReturnValue>
      </Message>
      <Message selector="perform:withArguments:" docId="5.3.1.16" refined="false">
        <Synopsis>Send a message using a computed message selector and a collection of arguments.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;Send to the receiver a message whose selector is &lt;code&gt;selector&lt;/code&gt; and whose arguments are the elements of &lt;code&gt;arguments&lt;/code&gt; . Return the value of that message. The first element of &lt;code&gt;arguments&lt;/code&gt; is the first argument, the second element is the second argument, and so on.&lt;/p&gt;&lt;p&gt; If the receiver does not have a method for the &lt;code&gt;selector&lt;/code&gt; normal &amp;quot;message not understood&amp;quot; processing is performed as if the computed message hand been sent using a message send expression. If this occurs, &lt;code&gt;selector&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; could be captured.&lt;/p&gt;&lt;p&gt; The perform messages and &lt;code&gt;#respondsTo:&lt;/code&gt; must be implemented to produce consistent results. A message to perform a selector, &lt;code&gt;selector&lt;/code&gt; , for a given receiver will result in a &amp;quot;message not understood&amp;quot; condition if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver respondsTo: selector&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Behavior is undefined if the number of elements in &lt;code&gt;arguments&lt;/code&gt; does not match that implicitly required by  the syntactic form of the &lt;code&gt;selector&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="unspecified">
          <Protocol name="selector" />
        </Parameter>
        <Parameter name="arguments" aliasing="unspecified">
          <Protocol name="Array" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
          <Description>The protocol specification of the returned value of this method is not really useful for any sort of static analysis. In practice the returned value will be treated as conforming to the return type of the message that is dynamically constructed.</Description>
        </ReturnValue>
      </Message>
      <Message selector="printOn:" docId="5.3.1.17" refined="false">
        <Synopsis>Write a textual description of the receiver to a stream.</Synopsis>
        <Definition protocol="Object">The string of characters that would be the result of sending the message &lt;code&gt;#printString&lt;/code&gt; to the receiver is written to &lt;code&gt;target&lt;/code&gt; . The characters appear on the stream as if each character was, in sequence, written to the stream using the message &lt;code&gt;#nextPut:&lt;/code&gt; .</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="puttableStream" />
        </Parameter>
      </Message>
      <Message selector="printString" docId="5.3.1.18" refined="false">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="respondsTo:" docId="5.3.1.19" refined="false">
        <Synopsis>Determine if the receiver can respond to a specific message selector.</Synopsis>
        <Definition protocol="Object">Return &lt;em&gt;true&lt;/em&gt; if the receiver has a method in its behavior that has the &lt;em&gt;message selector&lt;/em&gt; &lt;code&gt;selector&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .</Definition>
        <Parameter name="selector" aliasing="uncaptured">
          <Protocol name="selector" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="yourself" docId="5.3.1.20" refined="false">
        <Synopsis>No operation. Return the receiver as the result.</Synopsis>
        <Definition protocol="Object">Return the receiver of the message.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="nil" docId="5.3.2" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior that is unique to the distinguished immutable, &lt;em&gt;identity object&lt;/em&gt; that is the value of the reserved identifier &amp;quot;nil&amp;quot;.</Description>
      <Message selector="printString" docId="5.3.2.1" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="nil">Return a string with the same characters as the string &lt;code&gt;'nil'&lt;/code&gt; .</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="boolean" docId="5.3.3" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>&lt;p&gt;This protocol describes the behavior of the objects that are the values of the reserved identifiers &amp;quot;true&amp;quot; and &amp;quot;false&amp;quot;.  These objects are &lt;em&gt;identity objects&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Several message specifications include a truth table describing the result of the binary operation implemented by that message. In each table, the value of the receiver is used to locate a row and the value of the argument is used to locate a column, the result being located at the intersection of the row and column.&lt;/p&gt;</Description>
      <StandardGlobal name="Boolean">
        <Description>
          &lt;P&gt;This class describes the behavior of the objects that are the values of the reserved identifiers "true" and "false". These objects are &lt;EM&gt;identity objects&lt;/EM&gt; .&lt;/P&gt;
          &lt;P&gt;Several message specifications include a truth table describing the result of the binary operation implemented by that message. In each table, the value of the receiver is used to locate a row and the value of the argument is used to locate a column, the result being located at the intersection of the row and column.&lt;/P&gt;
        </Description>
        <Class superclass="Object" instaneState="none" />
      </StandardGlobal>
      <StandardGlobal name="True">
        <Class superclass="Boolean" instaneState="none" />
      </StandardGlobal>
      <StandardGlobal name="False" />
      <Message selector="&amp;" docId="5.3.3.1" refined="false">
        <Synopsis>Logical and -- Boolean conjunction.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;Return the Boolean conjunction of the receiver and &lt;code&gt;operand&lt;/code&gt; . The value returned is determined by the following truth table: &amp;amp; true false&lt;/p&gt;&lt;p&gt; true true false false false false&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="boolean" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="|" docId="5.3.3.2" refined="false">
        <Synopsis>Logical or -- Boolean disjunction.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;Return the Boolean disjunction of the receiver and &lt;code&gt;operand&lt;/code&gt; . The value returned is determined by the following truth table: | true false&lt;/p&gt;&lt;p&gt; true true true false true false&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="boolean" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="and:" docId="5.3.3.3" refined="false">
        <Synopsis>&amp;quot;Short circuit&amp;quot; logical and.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;If the receiver is &lt;em&gt;false&lt;/em&gt; , return &lt;em&gt;false&lt;/em&gt; . Otherwise, return the &amp;lt;boolean&amp;gt; result of sending the message &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the result of sending &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; is not a &amp;lt;boolean&amp;gt;.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="eqv:" docId="5.3.3.4" refined="false">
        <Synopsis>Boolean equivalence.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;Return the Boolean disjunction of the receiver and &lt;code&gt;operand&lt;/code&gt; . The value returned is determined by the following truth table:&lt;/p&gt;&lt;p&gt; eqv: true false&lt;/p&gt;&lt;p&gt; true true false false false true&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="boolean" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="ifFalse:" docId="5.3.3.5" refined="false">
        <Synopsis>Evaluate the argument if receiver is &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;If the receiver is &lt;em&gt;false&lt;/em&gt; return the result of sending the message &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The return value is unspecified if the receiver is &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="ifFalse:ifTrue:" docId="5.3.3.6" refined="false">
        <Synopsis>Selectively evaluate one of the arguments.</Synopsis>
        <Definition protocol="boolean">If the receiver is &lt;em&gt;false&lt;/em&gt; return the result return the result as if the message &lt;code&gt;#value&lt;/code&gt; was sent to &lt;code&gt;falseOperand&lt;/code&gt; , otherwise return the result as if the message &lt;code&gt;#value&lt;/code&gt; was sent to &lt;code&gt;trueOperand&lt;/code&gt; .</Definition>
        <Parameter name="falseOperand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <Parameter name="trueOperand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="ifTrue:" docId="5.3.3.7" refined="false">
        <Synopsis>Evaluate the argument if the receiver is &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;If the receiver is &lt;em&gt;true&lt;/em&gt; , return the result of sending the message &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The return value is unspecified if the receiver is &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="ifTrue:ifFalse:" docId="5.3.3.8" refined="false">
        <Synopsis>Selectively evaluate one of the arguments.</Synopsis>
        <Definition protocol="boolean">If the receiver is &lt;em&gt;true&lt;/em&gt; return the result of sending the message &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;trueOperand&lt;/code&gt; , otherwise return the result of sending &lt;code&gt;#value&lt;/code&gt; to the &lt;code&gt;falseOperand&lt;/code&gt; .</Definition>
        <Parameter name="trueOperand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <Parameter name="falseOperand" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="not" docId="5.3.3.9" refined="false">
        <Synopsis>Logical not -- Boolean negation.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;Return the Boolean negation of the receiver.&lt;/p&gt;&lt;p&gt; If the receiver is &lt;em&gt;true&lt;/em&gt; the return value is &lt;em&gt;false&lt;/em&gt; , if the receiver is &lt;em&gt;false&lt;/em&gt; the return value is &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="or:" docId="5.3.3.10" refined="false">
        <Synopsis>&amp;quot;Short circuit&amp;quot; logical or.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;If the receiver is &lt;em&gt;true&lt;/em&gt; , return &lt;em&gt;true&lt;/em&gt; . Otherwise, return the Boolean result of sending the message &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the result of sending &lt;code&gt;#value&lt;/code&gt; to &lt;code&gt;operand&lt;/code&gt; is not a &amp;lt;boolean&amp;gt;.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
          <Description>UNSPECIFIED</Description>
        </ReturnValue>
      </Message>
      <Message selector="printString" docId="5.3.3.11" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="boolean">If the receiver is &lt;em&gt;true&lt;/em&gt; , return a string with the same characters as the string &lt;code&gt;'true'&lt;/code&gt; , otherwise return a string with the same characters as the string &lt;code&gt;'false'&lt;/code&gt; .</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="xor:" docId="5.3.3.12" refined="false">
        <Synopsis>Boolean exclusive or.</Synopsis>
        <Definition protocol="boolean">&lt;p&gt;Return the Boolean exclusive or of the receiver and &lt;code&gt;operand&lt;/code&gt; . The value returned is determined by the following truth table:&lt;/p&gt;&lt;p&gt; xor: true false&lt;/p&gt;&lt;p&gt; true false true false true false&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="boolean" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Character" docId="5.3.4" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>&lt;p&gt;This protocol describes the behavior that is common to character objects. Character objects serve as the element value for Smalltalk strings. The Smalltalk language provides a literal syntax for character objects. Character objects represent individual elements of an implementation defined execution character set whose individual elements are identified by integer values. These integers are called &lt;em&gt;code points&lt;/em&gt; .  Each character object has an associated code point.&lt;/p&gt;&lt;p&gt; It is unspecified whether or not each code point is uniquely associated with a unique character object.&lt;/p&gt;&lt;p&gt; The execution character set is the character set used by an implementation during execution of a Smalltalk program.  It need not be the same as the character set used by that implementation to encode the definition of Smalltalk programs.&lt;/p&gt;</Description>
      <Message selector="=" docId="5.3.4.1" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Refinement protocol="Character">&lt;p&gt;Two characters are considered equivalent if they have the same code point. In other words&lt;/p&gt;&lt;p&gt; &lt;code&gt;character1 = character2&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if&lt;/p&gt;&lt;p&gt; &lt;code&gt;character1 codePoint = character2 codePoint&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is also &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="asLowercase" docId="5.3.4.2" refined="false">
        <Synopsis>Return a character which is equivalent to the lowercase representation of the receiver.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;If the receiver is equal to the value of a character literal in the &amp;quot;receiver&amp;quot; row of the following table, the result object must be equal to the value of the corresponding character literal in the &amp;quot;result&amp;quot; row.&lt;/p&gt;&lt;p&gt; receiver $A $B $C $D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S $T $U $V $W $X $Y $Z&lt;/p&gt;&lt;p&gt; result $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p $q $r $s $t $u $v $w $x $y $z&lt;/p&gt;&lt;p&gt; An implemention may define other #asLowercase mappings. If the receiver does not correspond to a character in the &amp;quot;receiver&amp;quot; row of the table and does not have an implementation defined mapping the receiver is returned as the result.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="asString" docId="5.3.4.3" refined="false">
        <Synopsis>Return a new string whose sole element is equivalent to the receiver.</Synopsis>
        <Definition protocol="Character">Return a new string of size one (1) whose sole element is equivalent to the receiver. The new string is created using the same constraints as defined by the &lt;code&gt;#new:&lt;/code&gt; message defined in &amp;lt;String factory&amp;gt;. It is unspecified whether the resulting string captures a reference to the receiver.</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
      </Message>
      <Message selector="asUppercase" docId="5.3.4.4" refined="false">
        <Synopsis>Return a character equivalent to the uppercase representation of the receiver.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;If the receiver is equal to the value of a character literal in the &amp;quot;receiver&amp;quot; row of the following table, the result object must be equal to the value of the corresponding character literal in the &amp;quot;result&amp;quot; row.&lt;/p&gt;&lt;p&gt; receiver $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p $q $r $s $t $u $v $w $x $y $z&lt;/p&gt;&lt;p&gt; result $A $B $C $D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S $T $U $V $W $X $Y $Z&lt;/p&gt;&lt;p&gt; An implemention may define other #asUppercase mappings. If the receiver does not correspond to a character in the &amp;quot;receiver&amp;quot; row of the table and does not have an implementation defined mapping the receiver is returned as the result.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="codePoint" docId="5.3.4.5" refined="false">
        <Synopsis>Return the encoding value of the receiver.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return the encoding value of the receiver in the implementation defined execution character set.&lt;/p&gt;&lt;p&gt; The following invariant must hold:&lt;/p&gt;&lt;p&gt; &lt;code&gt;(charFactory codePoint: x) codePoint = x&lt;/p&gt;&lt;p&gt;&lt;/code&gt; where &lt;code&gt;charFactory&lt;/code&gt; is an object that implements &amp;lt;Character factory&amp;gt; and &lt;code&gt;x&lt;/code&gt; is an &amp;lt;integer&amp;gt;.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="isAlphaNumeric" docId="5.3.4.6" refined="false">
        <Synopsis>Test whether the receiver is a letter or digit.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver is either a letter or digit. Otherwise return &lt;em&gt;false&lt;/em&gt; . In other words&lt;/p&gt;&lt;p&gt; &lt;code&gt;character isAlphaNumeric&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if either&lt;/p&gt;&lt;p&gt; &lt;code&gt;character isLetter&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; or&lt;/p&gt;&lt;p&gt; &lt;code&gt;character isDigit&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isDigit" docId="5.3.4.7" refined="false">
        <Synopsis>Test whether the receiver is a digit.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver represents a digit. Otherwise return &lt;em&gt;false&lt;/em&gt; . The receiver is a digit if it is equal to the value of one of the following character literals:&lt;/p&gt;&lt;p&gt; &lt;code&gt;$0 $1 $2 $3 $4 $5 $6 $7 $8 $9&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isLetter" docId="5.3.4.8" refined="false">
        <Synopsis>Test whether the receiver is a letter.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver corresponds to an alphabetic character, ignoring case. Otherwise return &lt;em&gt;false&lt;/em&gt; . The receiver is an alphabetic character if it is equal to the value of one of the following character literals:&lt;/p&gt;&lt;p&gt; &lt;code&gt;$A $B $C $D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S $T $U $V $W $X $Y $Z $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p $q $r $s $t $u $v $w $x $y $z&lt;/p&gt;&lt;p&gt;&lt;/code&gt; Implementations may define other characters to be alphabetic characters. Any such characters will return &lt;em&gt;true&lt;/em&gt; when set this message.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isLowercase" docId="5.3.4.9" refined="false">
        <Synopsis>Test whether the receiver is a lowercase letter.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver corresponds to a lowercase letter. Otherwise return &lt;em&gt;false&lt;/em&gt; . The receiver is an lowercase letter if it is equal to the value of one of the following character literals:&lt;/p&gt;&lt;p&gt; &lt;code&gt;$a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p $q $r $s $t $u $v $w $x $y $z&lt;/p&gt;&lt;p&gt;&lt;/code&gt; Implementations may define other characters to be lowercase characters. Any such characters will return &lt;em&gt;true&lt;/em&gt; when set this message.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isUppercase" docId="5.3.4.10" refined="false">
        <Synopsis>Test whether the receiver is an uppercase letter.</Synopsis>
        <Definition protocol="Character">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the receiver corresponds to a uppercase letter. Otherwise return &lt;em&gt;false&lt;/em&gt; . The receiver is an uppercase letter if it is equal to the value of one of the following character literals:&lt;/p&gt;&lt;p&gt; &lt;code&gt;$A $B $C $D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S $T $U $V $W $X $Y $Z&lt;/p&gt;&lt;p&gt;&lt;/code&gt; Implementations may define other characters to be lowercase characters. Any such characters will return &lt;em&gt;true&lt;/em&gt; when set this message.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Character factory" docId="5.3.5" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior for accessing character objects.</Description>
      <StandardGlobal name="Character">
        <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global is a factory for for creating or accessing objects that conform to &amp;lt;Character&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="codePoint:" docId="5.3.5.1" refined="false">
        <Synopsis>Return a character whose encoding value is &lt;code&gt;integer&lt;/code&gt; .</Synopsis>
        <Definition protocol="Character factory">&lt;p&gt;Return a character whose encoding value in the implementation defined execution character set is &lt;code&gt;integer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the encoding value is not a valid encoding value in the implementation defined character set.&lt;/p&gt;</Definition>
        <Parameter name="integer" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="cr" docId="5.3.5.2" refined="false">
        <Synopsis>Return a character representing a carriage-return.</Synopsis>
        <Definition protocol="Character factory">Return a character representing a carriage-return. The code point of the resulting character is implementation defined.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="lf" docId="5.3.5.3" refined="false">
        <Synopsis>Return a character representing a line feed.</Synopsis>
        <Definition protocol="Character factory">Return a character representing a line feed. The code point of the resulting character is implementation defined.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="space" docId="5.3.5.4" refined="false">
        <Synopsis>Return a character representing a space.</Synopsis>
        <Definition protocol="Character factory">Return a character representing a space. The code point of the resulting character is implementation defined.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
      <Message selector="tab" docId="5.3.5.5" refined="false">
        <Synopsis>Return a character representing a tab.</Synopsis>
        <Definition protocol="Character factory">Return a character representing a tab. The code point of the resulting character is implementation defined.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Character" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="failedMessage" docId="5.3.6" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior of objects that represent a message that was sent to an object, but was not understood by that object.</Description>
      <Message selector="arguments" docId="5.3.6.1" refined="false">
        <Synopsis>Answer the arguments of the message that could not be sent.</Synopsis>
        <Definition protocol="failedMessage">Return a collection containing the arguments of the message that could not be sent. The elements of the collection are ordered, from the first element to the last element, in the same order as the arguments of the message, from left to right. If the message had no arguments, the collection will be empty.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="selector" docId="5.3.6.2" refined="false">
        <Synopsis>Answer the selector of the message that could not be sent.</Synopsis>
        <Definition protocol="failedMessage">Answer the selector of the message that could not be sent.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="selector" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="selector" docId="5.3.7" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>Defines the protocol supported by literal message selectors. No behavior is defined by this protocols but objects that conform to is can be used to perform dynamically generated message sends  using &amp;lt;Object&amp;gt; #perform: and related messages.</Description>
    </Protocol>
    <Protocol name="classDescription" docId="5.3.8" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior of &lt;em&gt;class objects&lt;/em&gt; . It provides messages for identifying and locating &lt;em&gt;class objects&lt;/em&gt; within the class hierarchy.</Description>
      <Message selector="allSubclasses" docId="5.3.8.1" refined="false">
        <Synopsis>Return all subclasses of a class.</Synopsis>
        <Definition protocol="classDescription">&lt;p&gt;If the receiver is a &lt;em&gt;class object&lt;/em&gt; , return a collection containing all of the &lt;em&gt;class objects&lt;/em&gt; whose &lt;em&gt;class&lt;/em&gt; &lt;em&gt;definitions&lt;/em&gt; inherit either directly or indirectly from the &lt;em&gt;class definition&lt;/em&gt; of the receiver.&lt;/p&gt;&lt;p&gt; If the receiver is not a &lt;em&gt;class object&lt;/em&gt; , the result is unspecified.&lt;/p&gt;&lt;p&gt; Each element of the result collection supports the protocol &amp;lt;classDescription&amp;gt;. The order of &lt;em&gt;class&lt;/em&gt; &lt;em&gt;objects&lt;/em&gt; within the collection is unspecified.&lt;/p&gt;&lt;p&gt; &amp;lt;collection&amp;gt; unspecified&lt;/p&gt;</Definition>
      </Message>
      <Message selector="allSuperclasses" docId="5.3.8.2" refined="false">
        <Synopsis>Return all superclasses of a class.</Synopsis>
        <Definition protocol="classDescription">&lt;p&gt;If the receiver is a &lt;em&gt;class object&lt;/em&gt; , return a collection containing all of the &lt;em&gt;class objects&lt;/em&gt; defined by the &lt;em&gt;class definitions&lt;/em&gt; from which the &lt;em&gt;class definition&lt;/em&gt; of the receiver inherits, either directly or indirectly. If the &lt;em&gt;class definition&lt;/em&gt; of the receiver has no superclasses, return an empty collection.&lt;/p&gt;&lt;p&gt; If the receiver is not a &lt;em&gt;class object&lt;/em&gt; , the result is unspecified.&lt;/p&gt;&lt;p&gt; Each element of the result collection supports the protocol &amp;lt;classDescription&amp;gt;. The order of &lt;em&gt;class&lt;/em&gt; &lt;em&gt;objects&lt;/em&gt; within the collection is unspecified.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="collection" />
        </ReturnValue>
      </Message>
      <Message selector="name" docId="5.3.8.3" refined="false">
        <Synopsis>Return the name of a class.</Synopsis>
        <Definition protocol="classDescription">Return a string containing the global name of the receiver. The global name of a &lt;em&gt;class object&lt;/em&gt; is the global identifier that is bound to the &lt;em&gt;class object&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="subclasses" docId="5.3.8.4" refined="false">
        <Synopsis>Return direct subclasses of a class.</Synopsis>
        <Definition protocol="classDescription">&lt;p&gt;If the receiver is a &lt;em&gt;class object&lt;/em&gt; , return a collection containing all of the &lt;em&gt;class objects&lt;/em&gt; whose &lt;em&gt;class&lt;/em&gt; &lt;em&gt;definitions&lt;/em&gt; inherit directly from the &lt;em&gt;class definition&lt;/em&gt; of the receiver. If there are no &lt;em&gt;class definitions&lt;/em&gt; that inherit from the &lt;em&gt;class definition&lt;/em&gt; of the receiver, return an empty collection.&lt;/p&gt;&lt;p&gt; If the receiver is not a &lt;em&gt;class object&lt;/em&gt; , the result is unspecified.&lt;/p&gt;&lt;p&gt; Each element of the result collection supports the protocol &amp;lt;classDescription&amp;gt;. The order of &lt;em&gt;class&lt;/em&gt; &lt;em&gt;objects&lt;/em&gt; within the collection is unspecified.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="collection" />
        </ReturnValue>
      </Message>
      <Message selector="superclass" docId="5.3.8.5" refined="false">
        <Synopsis>Return the immediate superclass of a class.</Synopsis>
        <Definition protocol="classDescription">&lt;p&gt;If the receiver is a &lt;em&gt;class object&lt;/em&gt; , return the &lt;em&gt;class objects&lt;/em&gt; defined by the &lt;em&gt;class definitions&lt;/em&gt; from which the &lt;em&gt;class definition&lt;/em&gt; of the receiver directly inherits. If the &lt;em&gt;class definition&lt;/em&gt; of the receiver has no superclasses, return &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If the receiver is not a &lt;em&gt;class object&lt;/em&gt; , the result is unspecified.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="classDescription" />
          <Description>&amp;lt;nil&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="instantiator" docId="5.3.9" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol defines the behavior of objects that can be used to create other objects without requiring any additional information.</Description>
      <Message selector="new" docId="5.3.9.1" refined="false">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Object class" docId="5.3.10" abstract="false">
      <ConformsTo protocol="classDescription" />
      <ConformsTo protocol="instantiator" />
      <Description>&lt;p&gt;This protocol describes the behavior the &lt;em&gt;class object&lt;/em&gt; whose global identifier is 'Object', which is the traditional root of the class hierarchy.&lt;/p&gt;&lt;p&gt; This class must be implemented in such a way that it is not fragile. A class is said to be fragile if it is implemented in such a way that subclasses of that class can change the behavior of any standard-specified method without overriding the implementation of those methods. This can happen when a method is implemented to use an auxiliary method that is not specified in the standard, which the subclass then (possibly unintentionally) overrides. The inherited method will then invoke the subclass' implementation of the auxiliary method rather than the expected implementation in the superclass.&lt;/p&gt;&lt;p&gt; One way to ensure that the implementation of a class is not fragile is to ensure that any message sent to self is either part of the specified behavior for that class or has a selector that begins with an underscore. Alternatively, an implementation may use implementation-specific means to implement these methods in a way that makes them non-fragile.&lt;/p&gt;</Description>
      <StandardGlobal name="Object">
        <Description>Conforms to the protocol &amp;lt;Object class&amp;gt;. It is a class object and the name of a class definition.</Description>
        <Class instaneState="none" />
      </StandardGlobal>
      <Message selector="new" docId="5.3.10.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="Object class">Return a newly created instance of the receiver.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="valuable" docId="5.4.1" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior for objects that can be evaluated using variants of the &lt;code&gt;#value&lt;/code&gt; message.</Description>
      <Message selector="argumentCount" docId="5.4.1.1" refined="false">
        <Synopsis>Answers the number of arguments needed to evaluate the receiver.</Synopsis>
        <Definition protocol="valuable">The number of arguments needed to evaluate the receiver is returned.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="valueWithArguments:" docId="5.4.1.2" refined="false">
        <Synopsis>Answers the &lt;em&gt;value&lt;/em&gt; of the receiver when applied to the arguments in &lt;code&gt;argumentArray&lt;/code&gt; .</Synopsis>
        <Definition protocol="valuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language with the elements of &lt;code&gt;argumentArray&lt;/code&gt; bound in sequence to the receiver's arguments.&lt;/p&gt;&lt;p&gt; The result is as defined by the receiver.&lt;/p&gt;&lt;p&gt; The results are undefined if the size of &lt;code&gt;argumentArray&lt;/code&gt; does not equal the receiver's argument count.&lt;/p&gt;</Definition>
        <Parameter name="argumentArray" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="niladicValuable" docId="5.4.2" abstract="true">
      <ConformsTo protocol="valuable" />
      <Description>This protocol describes the behavior for objects supporting the &lt;code&gt;#value&lt;/code&gt; selector.</Description>
      <Message selector="argumentCount" docId="5.4.2.1" refined="true">
        <Synopsis>Answers the number of arguments needed to evaluate the receiver.</Synopsis>
        <Definition protocol="valuable">The number of arguments needed to evaluate the receiver is returned.</Definition>
        <Refinement protocol="niladicValuable">Returns 0.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="value" docId="5.4.2.2" refined="false">
        <Synopsis>Answers the &lt;em&gt;value&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="niladicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; The result is as defined by the receiver.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="whileFalse" docId="5.4.2.3" refined="false">
        <Synopsis>Evaluates the receiver until it evaluates to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="niladicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , the evaluation is defined by the language.&lt;/p&gt;&lt;p&gt; If this evaluation results in &lt;em&gt;false&lt;/em&gt; the process repeats.&lt;/p&gt;&lt;p&gt; If and when the evaluation of the receiver results in &lt;em&gt;true&lt;/em&gt; , the method terminates.&lt;/p&gt;&lt;p&gt; The results are undefined if the receiver is not a &lt;em&gt;block&lt;/em&gt; which evaluates to a Boolean value.&lt;/p&gt;</Definition>
      </Message>
      <Message selector="whileFalse:" docId="5.4.2.4" refined="false">
        <Synopsis>Evaluates &lt;code&gt;iterationBlock&lt;/code&gt; zero or more times until the receiver evaluates to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="niladicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language.&lt;/p&gt;&lt;p&gt; If this evaluation results in &lt;em&gt;false&lt;/em&gt; , the argument is evaluated and the process repeats.&lt;/p&gt;&lt;p&gt; If and when the evaluation of the receiver results in &lt;em&gt;true&lt;/em&gt; , the method terminates.&lt;/p&gt;&lt;p&gt; The results are undefined if the receiver is not a &lt;em&gt;block&lt;/em&gt; which evaluates to a Boolean value.&lt;/p&gt;</Definition>
        <Parameter name="iterationBlock" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
      </Message>
      <Message selector="whileTrue" docId="5.4.2.5" refined="false">
        <Synopsis>Evaluates the receiver until it evaluates to &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="niladicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language.&lt;/p&gt;&lt;p&gt; If this evaluation results in &lt;em&gt;true&lt;/em&gt; the process repeats.&lt;/p&gt;&lt;p&gt; If and when the evaluation of the receiver results in &lt;em&gt;false&lt;/em&gt; , the method terminates.&lt;/p&gt;&lt;p&gt; The results are undefined if the receiver is not a &lt;em&gt;block&lt;/em&gt; which evaluates to a Boolean value.&lt;/p&gt;</Definition>
      </Message>
      <Message selector="whileTrue:" docId="5.4.2.6" refined="false">
        <Synopsis>Evaluates &lt;code&gt;iterationBlock&lt;/code&gt; zero or more times until the receiver evaluates to &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="niladicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language.&lt;/p&gt;&lt;p&gt; If this evaluation results in &lt;em&gt;true&lt;/em&gt; , the argument is evaluated and the process repeats.&lt;/p&gt;&lt;p&gt; If and when the evaluation of the receiver results in &lt;em&gt;false&lt;/em&gt; , the method terminates.&lt;/p&gt;&lt;p&gt; The results are undefined if the receiver is not a &lt;em&gt;block&lt;/em&gt; which evaluates to a Boolean value.&lt;/p&gt;</Definition>
        <Parameter name="iterationBlock" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
      </Message>
    </Protocol>
    <Protocol name="niladicBlock" docId="5.4.3" abstract="true">
      <ConformsTo protocol="niladicValuable" />
      <Description>&lt;p&gt;This protocol describes the behavior for blocks with no arguments.&lt;/p&gt;&lt;p&gt; Objects conforming to this protocol can be created only by the block constructor construct of the Smalltalk language.&lt;/p&gt;</Description>
      <Message selector="ensure:" docId="5.4.3.1" refined="false">
        <Synopsis>Evaluate a termination block after evaluating the receiver.</Synopsis>
        <Definition protocol="niladicBlock">&lt;p&gt;Evaluate the receiver and return its result. Immediately after successful evaluation of the receiver but before returning its result, evaluate &lt;code&gt;terminationBlock&lt;/code&gt; . If &lt;em&gt;abnormal termination&lt;/em&gt; of the receiver occurs, &lt;code&gt;terminationBlock&lt;/code&gt; is evaluated. In either case, the value returned from the evaluation of &lt;code&gt;terminationBlock&lt;/code&gt; is discarded.&lt;/p&gt;&lt;p&gt; Activation of an exception handler from within the receiver is not in and of itself an &lt;em&gt;abnormal&lt;/em&gt; &lt;em&gt;termination&lt;/em&gt; . However, if the &lt;em&gt;exception handler&lt;/em&gt; for an exception that is not &lt;em&gt;resumable&lt;/em&gt; results in termination of the receiver or if its &lt;em&gt;handler block&lt;/em&gt; contains a return statement that results in &lt;em&gt;abnormal termination&lt;/em&gt; of the receiver, then &lt;code&gt;terminationBlock&lt;/code&gt; will be evaluated after evaluation of the &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If an &lt;em&gt;abnormal termination&lt;/em&gt; results in the termination of multiple blocks which were evaluated using either &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; the respective &lt;code&gt;terminationBlocks&lt;/code&gt; will be executed in the reverse of the order in which the corresponding receiver blocks were evaluated.&lt;/p&gt;</Definition>
        <Parameter name="terminationBlock" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="ifCurtailed:" docId="5.4.3.2" refined="false">
        <Synopsis>Evaluating the receiver with an abnormal termination action.</Synopsis>
        <Definition protocol="niladicBlock">&lt;p&gt;Evaluate the receiver and return its result. If &lt;em&gt;abnormal termination&lt;/em&gt; of the receiver occurs, &lt;code&gt;terminationBlock&lt;/code&gt; is evaluated. The value returned from the evaluation of &lt;code&gt;terminationBlock&lt;/code&gt; is discarded.&lt;/p&gt;&lt;p&gt; Activation of an exception handler from within the receiver is not in and of itself an &lt;em&gt;abnormal&lt;/em&gt; &lt;em&gt;termination&lt;/em&gt; . However, if the &lt;em&gt;exception handler&lt;/em&gt; for an exception that is not &lt;em&gt;resumable&lt;/em&gt; results in&lt;/p&gt;&lt;p&gt; termination of the receiver or if its &lt;em&gt;handler block&lt;/em&gt; contains a return statement that results in &lt;em&gt;abnormal termination&lt;/em&gt; of the receiver, then &lt;code&gt;terminationBlock&lt;/code&gt; will be evaluated after evaluation of the &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If an &lt;em&gt;abnormal termination&lt;/em&gt; result in the termination of multiple blocks which were evaluated using either &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; the respective &lt;code&gt;terminationBlocks&lt;/code&gt; will be executed in the reverse of the order in which the corresponding receiver blocks were evaluated.&lt;/p&gt;</Definition>
        <Parameter name="terminationBlock" aliasing="uncaptured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
      <Message selector="on:do:" docId="5.4.3.3" refined="false">
        <Synopsis>Evaluate the receiver in the scope of an exception handler.</Synopsis>
        <Definition protocol="niladicBlock">&lt;p&gt;The receiver is evaluated such that if during its evaluation an exception corresponding to &lt;code&gt;selector&lt;/code&gt; is signaled then &lt;code&gt;action&lt;/code&gt; will be evaluated. The result of evaluating the receiver is returned.&lt;/p&gt;&lt;p&gt; Before evaluating the receiver the current state of the &lt;em&gt;exception environment&lt;/em&gt; is captured as the &lt;em&gt;handler environment&lt;/em&gt; . Then a new &lt;em&gt;exception handler&lt;/em&gt; is created with &lt;code&gt;selector&lt;/code&gt; as its &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;selector&lt;/em&gt; and &lt;code&gt;action&lt;/code&gt; as its &lt;em&gt;handler block&lt;/em&gt; . The new handler is pushed onto the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If evaluation of the receiver terminates normally then the &lt;em&gt;exception environment&lt;/em&gt; is reset to the &lt;em&gt;handler environment&lt;/em&gt; before returning to the sender of the &lt;code&gt;#on:do:&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; If signaling of an exception results in evaluation of &lt;code&gt;action&lt;/code&gt; the evaluation will occur in the context of the &lt;em&gt;handler environment&lt;/em&gt; . The argument to the action will be an object that conforms to the protocol &amp;lt;signaledException&amp;gt;.&lt;/p&gt;</Definition>
        <Parameter name="selector" aliasing="uncaptured">
          <Protocol name="exceptionSelector" />
        </Parameter>
        <Parameter name="action" aliasing="uncaptured">
          <Protocol name="monadicBlock" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="monadicValuable" docId="5.4.4" abstract="true">
      <ConformsTo protocol="valuable" />
      <Description>This protocol describes the behavior for objects supporting the value: selector.</Description>
      <Message selector="argumentCount" docId="5.4.4.1" refined="true">
        <Synopsis>Answers the number of arguments needed to evaluate the receiver.</Synopsis>
        <Definition protocol="valuable">The number of arguments needed to evaluate the receiver is returned.</Definition>
        <Refinement protocol="monadicValuable">Returns 1.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="value:" docId="5.4.4.2" refined="false">
        <Synopsis>Answers the &lt;em&gt;value&lt;/em&gt; of the receiver when applied to the argument.</Synopsis>
        <Definition protocol="monadicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language with &lt;code&gt;argument&lt;/code&gt; bound to the &lt;em&gt;block&lt;/em&gt; 's only argument.&lt;/p&gt;&lt;p&gt; The result is as defined by the receiver.&lt;/p&gt;</Definition>
        <Parameter name="argument" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="monadicBlock" docId="5.4.5" abstract="true">
      <ConformsTo protocol="monadicValuable" />
      <Description>&lt;p&gt;This protocol describes the behavior for blocks with one argument.&lt;/p&gt;&lt;p&gt; Objects conforming to this protocol can be created only by the block constructor construct of the Smalltalk language.&lt;/p&gt;</Description>
    </Protocol>
    <Protocol name="dyadicValuable" docId="5.4.6" abstract="true">
      <ConformsTo protocol="valuable" />
      <Description>This protocol describes the behavior for objects supporting the &lt;code&gt;#value:value:&lt;/code&gt; selector.</Description>
      <Message selector="argumentCount" docId="5.4.6.1" refined="true">
        <Synopsis>Answers the number of arguments needed to evaluate the receiver.</Synopsis>
        <Definition protocol="valuable">The number of arguments needed to evaluate the receiver is returned.</Definition>
        <Refinement protocol="dyadicValuable">Returns 2.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="value:value:" docId="5.4.6.2" refined="false">
        <Synopsis>Answers the value of the receiver when applied to the arguments.</Synopsis>
        <Definition protocol="dyadicValuable">&lt;p&gt;The receiver is evaluated as defined by the receiver.&lt;/p&gt;&lt;p&gt; Note that in the case that the receiver is a &lt;em&gt;block&lt;/em&gt; , that the evaluation is defined by the language with &lt;code&gt;argument1&lt;/code&gt; bound to the &lt;em&gt;block&lt;/em&gt; 's first argument, and &lt;code&gt;argument2&lt;/code&gt; bound to the &lt;em&gt;block&lt;/em&gt; 's second argument.&lt;/p&gt;&lt;p&gt; The result is as defined by the receiver.&lt;/p&gt;</Definition>
        <Parameter name="argument1" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <Parameter name="argument2" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ANY" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="exceptionDescription" docId="5.5.1" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describe the messages that may be used to obtain information about an occurrence of an exception.</Description>
      <Message selector="defaultAction" docId="5.5.1.1" refined="false">
        <Synopsis>The default action taken if the exception is signaled.</Synopsis>
        <Definition protocol="exceptionDescription">&lt;p&gt;If the exception described by the receiver is signaled and the current &lt;em&gt;exception environment&lt;/em&gt; does not contain a handler for the exception this method will be executed.&lt;/p&gt;&lt;p&gt; The exact behavior and result of this method is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="description" docId="5.5.1.2" refined="false">
        <Synopsis>Return a textual description of the exception.</Synopsis>
        <Definition protocol="exceptionDescription">Return text that describes in a human readable form an occurrence of an exception. If an explicit message text was provided by the signaler of the exception, that text should be incorporated into the description.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readable" />
        </ReturnValue>
      </Message>
      <Message selector="isResumable" docId="5.5.1.3" refined="false">
        <Synopsis>Determine whether an exception is resumable.</Synopsis>
        <Definition protocol="exceptionDescription">This message is used to determine whether the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is &lt;em&gt;resumable&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="messageText" docId="5.5.1.4" refined="false">
        <Synopsis>Return an exception's message text.</Synopsis>
        <Definition protocol="exceptionDescription">Return the signaler message text of the receiver. If the signaler has not provided any message text, return &lt;em&gt;nil&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
          <Description>&amp;lt;nil&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="tag" docId="5.5.1.5" refined="false">
        <Synopsis>Return an exception's tag value.</Synopsis>
        <Definition protocol="exceptionDescription">&lt;p&gt;Return the tag value provided by the signaler of the receiver. If the signaler has not provided a tag value, return the same value was would be returned as if #message Text was sent to the receiver of this message. If the signaler has provided neither a tag value nor a message text, return &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Exception tags are intended for use in situations where a particular occurrence of an exception needs to be identified and a textual description is not appropriate. For example, the message text might vary according to the locale and thus could not be used to identify the exception.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
          <Description>&amp;lt;nil&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="exceptionSignaler" docId="5.5.2" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describes the behavior of signaling an exceptional condition, locating an &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; , and executing an &lt;em&gt;exception action&lt;/em&gt; .</Description>
      <Message selector="signal" docId="5.5.2.1" refined="false">
        <Synopsis>Signal the occurrence of an exceptional condition.</Synopsis>
        <Definition protocol="exceptionSignaler">&lt;p&gt;Associated with the receiver is an &amp;lt;exceptionDescription&amp;gt; called the &lt;em&gt;signaled exception&lt;/em&gt; . The current &lt;em&gt;exception environment&lt;/em&gt; is searched for an &lt;em&gt;exception handler&lt;/em&gt; whose &lt;em&gt;exception selector&lt;/em&gt; matches the &lt;em&gt;signaled exception&lt;/em&gt; . The search proceeds from the most recently created &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; to the oldest &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; A matching handler is defined to be one which would return &lt;em&gt;true&lt;/em&gt; if the message &lt;code&gt;#handles:&lt;/code&gt; was sent to its &lt;em&gt;exception selector&lt;/em&gt; with the &lt;em&gt;signaled exception&lt;/em&gt; as the argument.&lt;/p&gt;&lt;p&gt; If a matching handler is found, the &lt;em&gt;exception action&lt;/em&gt; of the handler is evaluated in the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; that was current when the handler was created and the state of the current &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; is preserved as the &lt;em&gt;signaling environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;exception action&lt;/em&gt; is evaluated as if the message &lt;code&gt;#value:&lt;/code&gt; were sent to it with a &amp;lt;signaledException&amp;gt; passed as its argument. The &amp;lt;signaledException&amp;gt; is derived from the &lt;em&gt;signaled exception&lt;/em&gt; in an implementation dependent manner.&lt;/p&gt;&lt;p&gt; If the evaluation of the &lt;em&gt;exception action&lt;/em&gt; returns normally (as if it had returned from the &lt;code&gt;#value: message)&lt;/code&gt; , the &lt;em&gt;handler environment&lt;/em&gt; is restored and the value returned from the &lt;em&gt;exception action&lt;/em&gt; is returned as the value of the &lt;code&gt;#on:do:&lt;/code&gt; message that created the handler. Before returning, any active &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks created during evaluation of the receiver of the &lt;code&gt;#on:do:&lt;/code&gt; message are evaluated.&lt;/p&gt;&lt;p&gt; If a matching handler is not found when the &lt;em&gt;exception environment&lt;/em&gt; is searched, the &lt;em&gt;default action&lt;/em&gt; for the &lt;em&gt;signaled exception&lt;/em&gt; is performed. This is accomplished as if the message &lt;code&gt;#defaultAction&lt;/code&gt; were sent to the &amp;lt;signaledException&amp;gt;  object derived from the &lt;em&gt;signaled exception&lt;/em&gt; . The &lt;code&gt;#defaultAction&lt;/code&gt; method is executed in the context of the &lt;em&gt;signaling environment&lt;/em&gt; . If the &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; is &lt;em&gt;resumable&lt;/em&gt; the value returned from the &lt;code&gt;#defaultAction&lt;/code&gt; method is returned as the value of the &lt;code&gt;#signal&lt;/code&gt; message. If the &lt;em&gt;signaled exception&lt;/em&gt; is not &lt;em&gt;resumable&lt;/em&gt; the action taken upon completion of the #defaultAction method is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="signal:" docId="5.5.2.2" refined="false">
        <Synopsis>Signal the occurrence of an exceptional condition with a specified textual description.</Synopsis>
        <Definition protocol="exceptionSignaler">&lt;p&gt;Associated with the receiver is an &amp;lt;exceptionDescription&amp;gt; called the &lt;em&gt;signaled exception&lt;/em&gt; . The message text of the signaled exception is set to the value of &lt;code&gt;signalerText&lt;/code&gt; , and then the exception is signaled in the same manner as if the message &lt;code&gt;#signal&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; Note that this message does not return in some circumstances. The situations in which it does return and the returned value, if any, are the same as specified for the &lt;code&gt;#signal&lt;/code&gt; message.&lt;/p&gt;</Definition>
        <Parameter name="signalerText" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="exceptionBuilder" docId="5.5.3" abstract="true">
      <ConformsTo protocol="exceptionDescription" />
      <ConformsTo protocol="exceptionSignaler" />
      <Description>This protocol describes the messages that may be used to set the information about an occurrence of an exception. This information may be retrieved using &amp;lt;exceptionDescription&amp;gt;  protocol. If an object conforming to this protocol is signaled as an exception, any information set in that object using this protocol's messages will also be available for retrival from the &lt;em&gt;signaled exception&lt;/em&gt; that is passed to a &lt;em&gt;handler block&lt;/em&gt; .</Description>
      <Message selector="messageText:" docId="5.5.3.1" refined="false">
        <Synopsis>Set an exception's message text.</Synopsis>
        <Definition protocol="exceptionBuilder">&lt;p&gt;Set the signaler message text of the receiver. Subsequent sends of the message &lt;code&gt;#messgeText&lt;/code&gt; to the receiver will return this value. Subseqent sends of of the message &lt;code&gt;#messgeText&lt;/code&gt; to a &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; generated by sending the message &lt;code&gt;#signal&lt;/code&gt; to the receiver of this message will also return this value.&lt;/p&gt;&lt;p&gt; Return the receiver as the result of the message.&lt;/p&gt;</Definition>
        <Parameter name="signalerText" aliasing="captured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="signaledException" docId="5.5.4" abstract="true">
      <ConformsTo protocol="exceptionDescription" />
      <Description>This protocol describes the messages that may be sent to the argument of a &lt;em&gt;handler block&lt;/em&gt; . These message are used to explicitly control how execution will continue when it leaves the &lt;em&gt;handler block&lt;/em&gt; .</Description>
      <Message selector="isNested" docId="5.5.4.1" refined="false">
        <Synopsis>Determine whether the current exception handler is within the scope of another handler for the same exception.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;em&gt;handler environment&lt;/em&gt; for the current exception handler contains an &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; that will &lt;em&gt;handle&lt;/em&gt; the receiver. Answer &lt;em&gt;false&lt;/em&gt; if it does not.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;default action&lt;/em&gt; for an exception is not considered to be an enclosing handler. Only the existence of a handler explicitly established using &lt;code&gt;#on:do:&lt;/code&gt; will result in this method returning &lt;em&gt;true&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="outer" docId="5.5.4.2" refined="false">
        <Synopsis>Evaluate the enclosing &lt;em&gt;exception action&lt;/em&gt; for the receiver and return.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;If the &lt;em&gt;handler environment&lt;/em&gt; for the current exception handler contains an &lt;em&gt;exception handler&lt;/em&gt; that will &lt;em&gt;handle&lt;/em&gt; the receiver, evaluate that handler's &lt;em&gt;exception action&lt;/em&gt; with the receiver as the argument to its &lt;em&gt;handler block&lt;/em&gt; . If there is no enclosing handler, send the message &lt;code&gt;#defaultAction&lt;/code&gt; to the receiver. The #defaultAction method is evaluated using the current &lt;em&gt;exception environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If the receiver is &lt;em&gt;resumable&lt;/em&gt; and the evaluated &lt;em&gt;exception action&lt;/em&gt; resumes then the result returned from &lt;code&gt;#outer&lt;/code&gt; will be the &lt;em&gt;resumption value&lt;/em&gt; of the evaluated &lt;em&gt;exception action&lt;/em&gt; . If the receiver is not &lt;em&gt;resumable&lt;/em&gt; or if the &lt;em&gt;exception action&lt;/em&gt; does not resume then this message will not return.&lt;/p&gt;&lt;p&gt; For exceptions that are not &lt;em&gt;resumable&lt;/em&gt; , &lt;code&gt;#outer&lt;/code&gt; is equivalent to &lt;code&gt;#pass&lt;/code&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>It is erroneous  to directly or indirectly send this message from within a &amp;lt;exceptionDescription&amp;gt; &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver  of the &lt;code&gt;#defaultAction&lt;/code&gt; message.</Errors>
      </Message>
      <Message selector="pass" docId="5.5.4.3" refined="false">
        <Synopsis>Yield control to the enclosing &lt;em&gt;exception action&lt;/em&gt; for the receiver.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;If the &lt;em&gt;handler environment&lt;/em&gt; for the current exception handler contains an enclosing &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; for the receiver, activate that handler's &lt;em&gt;exception action&lt;/em&gt; in place of the current &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;action&lt;/em&gt; . If there is no enclosing handler, execute the &lt;em&gt;default action&lt;/em&gt; for the receiver as if no handler had been found when the exception was originally signaled. The default action is evaluated in the context of the signaling environment.&lt;/p&gt;&lt;p&gt; Control does not return to the currently active &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Errors>It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.</Errors>
      </Message>
      <Message selector="resignalAs:" docId="5.5.4.4" refined="false">
        <Synopsis>Signal an alternative exception in place of the receiver.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;The active &lt;em&gt;exception action&lt;/em&gt; is aborted and the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the receiver was originally signaled. Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; After the restoration, signal the &lt;code&gt;replacementException&lt;/code&gt; and execute the &lt;em&gt;exception action&lt;/em&gt; as determined by the restored &lt;em&gt;exception environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; This message causes the &lt;code&gt;replacementException&lt;/code&gt; to be treated as if it had been originally signaled instead of the receiver.&lt;/p&gt;&lt;p&gt; If the &lt;code&gt;replacementException&lt;/code&gt; is &lt;em&gt;resumable&lt;/em&gt; and its &lt;em&gt;exception action&lt;/em&gt; resumes, control will ultimately return from the message that signaled the original exception.&lt;/p&gt;&lt;p&gt; Control does not return from this message to the currently active &lt;em&gt;exception action&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="replacementException" aliasing="unspecified">
          <Protocol name="exceptionDescription" />
        </Parameter>
      </Message>
      <Message selector="resume" docId="5.5.4.5" refined="false">
        <Synopsis>Return from the message that signaled the receiver.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;If the current &lt;em&gt;exception action&lt;/em&gt; was activated as the result of sending the message #outer to the receiver, return a resumption value as the value of the #outer message.&lt;/p&gt;&lt;p&gt; If the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception a resumption value is returned as the value of the message that signaled the receiver. Before returning, the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the receiver was originally signaled. Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; This message does not return to its point of invocation.&lt;/p&gt;&lt;p&gt; The resumption value is unspecified.&lt;/p&gt;</Definition>
        <Errors>&lt;p&gt;It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.&lt;/p&gt;&lt;p&gt; It is erroneous to send the message if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="resume:" docId="5.5.4.6" refined="false">
        <Synopsis>Return the argument as the value of the message that signaled the receiver.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;If the current &lt;em&gt;exception action&lt;/em&gt; was activated as the result of sending the message #outer to the receiver, return &lt;code&gt;resumptionValue&lt;/code&gt; as the value of the #outer message.&lt;/p&gt;&lt;p&gt; If the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception, the &lt;code&gt;resumptionValue&lt;/code&gt; is returned as the value of the message that signaled the receiver. Before returning, the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the receiver was originally signaled. Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; This message does not return to its point of invocation.&lt;/p&gt;</Definition>
        <Parameter name="resumptionValue" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>&lt;p&gt;It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.&lt;/p&gt;&lt;p&gt; It is erroneous to send the message if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="retry" docId="5.5.4.7" refined="false">
        <Synopsis>Abort an exception handler and re-evaluate its &lt;em&gt;protected block&lt;/em&gt; .</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;The active &lt;em&gt;exception action&lt;/em&gt; is aborted and the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the &lt;code&gt;#on:do:&lt;/code&gt; message that established the active handler was sent. Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; After the restoration, the &lt;code&gt;#on:do:&lt;/code&gt; method is re-evaluated with its original receiver and arguments.&lt;/p&gt;&lt;p&gt; Control does not return from this message to the currently active &lt;em&gt;exception action&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Errors>It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.</Errors>
      </Message>
      <Message selector="retryUsing:" docId="5.5.4.8" refined="false">
        <Synopsis>Abort an exception handler and evaluate a new block in place of the handler's &lt;em&gt;protected block&lt;/em&gt; .</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;The active &lt;em&gt;exception action&lt;/em&gt; is aborted and the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the &lt;code&gt;#on:do:&lt;/code&gt; message that established the active handler was sent. Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; blocks.&lt;/p&gt;&lt;p&gt; After the restoration, the &lt;code&gt;#on:do:&lt;/code&gt; method is re-evaluated with &lt;code&gt;alternativeBlock&lt;/code&gt; substituted for its original receiver. The original arguments are used for the re-evaluation.&lt;/p&gt;&lt;p&gt; Control does not return from this message to the currently active &lt;em&gt;exception action&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="alternativeBlock" aliasing="captured">
          <Protocol name="niladicBlock" />
        </Parameter>
        <Errors>It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.</Errors>
      </Message>
      <Message selector="return" docId="5.5.4.9" refined="false">
        <Synopsis>Return &lt;em&gt;nil&lt;/em&gt; as the value of the block protected by the active exception handler.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;&lt;em&gt;Nil&lt;/em&gt; is return as the value of the &lt;em&gt;protected block&lt;/em&gt; of the active &lt;em&gt;exception handler&lt;/em&gt; . Before returning, the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the active handler was created using &lt;code&gt;#on:do:&lt;/code&gt; . Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; This message does not return to its point of invocation.&lt;/p&gt;</Definition>
        <Errors>It is erroneous  to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.</Errors>
      </Message>
      <Message selector="return:" docId="5.5.4.10" refined="false">
        <Synopsis>Return the argument as the value of the block protected by the active exception handler.</Synopsis>
        <Definition protocol="signaledException">&lt;p&gt;The &lt;code&gt;returnValue&lt;/code&gt; is returned as the value of the &lt;em&gt;protected block&lt;/em&gt; of the active &lt;em&gt;exception handler&lt;/em&gt; . Before returning, the &lt;em&gt;exception environment&lt;/em&gt; and the &lt;em&gt;evaluation context&lt;/em&gt; are restored to the same states that were in effect when the active handler was created using &lt;code&gt;#on:do:&lt;/code&gt; . Restoring the &lt;em&gt;evaluation context&lt;/em&gt; may result in the execution of &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks.&lt;/p&gt;&lt;p&gt; This message does not return to its point of invocation.&lt;/p&gt;</Definition>
        <Parameter name="returnValue" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>It is erroneous to directly or indirectly send this message from within a &lt;code&gt;#defaultAction&lt;/code&gt; method to the receiver of the # &lt;code&gt;defaultAction&lt;/code&gt; method.</Errors>
      </Message>
    </Protocol>
    <Protocol name="exceptionSelector" docId="5.5.5" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>This protocol describe the behavior of objects that are used to select an &lt;em&gt;exception handler&lt;/em&gt; . In particular, objects that conform to this protocol may occur as the first argument to &lt;code&gt;#on:do:&lt;/code&gt; message sent to blocks.</Description>
      <Message selector="," docId="5.5.5.1" refined="false">
        <Synopsis>Create an exception set.</Synopsis>
        <Definition protocol="exceptionSelector">Return an exception set that contains the receiver and the argument exception. This is commonly used to specify a set of exception selectors for an &lt;em&gt;exception handler&lt;/em&gt; .</Definition>
        <Parameter name="anotherException" aliasing="captured">
          <Protocol name="exceptionSelector" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="exceptionSet" />
        </ReturnValue>
      </Message>
      <Message selector="handles:" docId="5.5.5.2" refined="false">
        <Synopsis>Determine whether an &lt;em&gt;exception handler&lt;/em&gt; will accept a &lt;em&gt;signaled exception&lt;/em&gt; .</Synopsis>
        <Definition protocol="exceptionSelector">This message determines whether the &lt;em&gt;exception handler&lt;/em&gt; associated with the receiver may be used to process the argument. Answer &lt;em&gt;true&lt;/em&gt; if an associated handler should be used to process &lt;code&gt;exception&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; if an associated handler may not be used to process the exception.</Definition>
        <Parameter name="exception" aliasing="unspecified">
          <Protocol name="exceptionDescription" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="exceptionInstantiator" docId="5.5.6" abstract="true">
      <ConformsTo protocol="exceptionSelector" />
      <ConformsTo protocol="exceptionSignaler" />
      <ConformsTo protocol="instantiator" />
      <Description>This protocol describes the instantiation behavior of objects that can create exceptions.</Description>
      <Message selector="new" docId="5.5.6.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="exceptionInstantiator">The object returned is an &amp;lt;exceptionBuilder&amp;gt; that may be used to signal an exception of the same type that would be signaled if the message &lt;code&gt;#signal&lt;/code&gt; is sent to the receiver.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="exceptionBuilder" />
        </ReturnValue>
      </Message>
      <Message selector="signal" docId="5.5.6.2" refined="true">
        <Synopsis>Signal the occurrence on an exceptional condition.</Synopsis>
        <Definition protocol="exceptionSignaler">&lt;p&gt;Associated with the receiver is an &amp;lt;exceptionDescription&amp;gt; called the &lt;em&gt;signaled exception&lt;/em&gt; . The current &lt;em&gt;exception environment&lt;/em&gt; is searched for an &lt;em&gt;exception handler&lt;/em&gt; whose &lt;em&gt;exception selector&lt;/em&gt; matches the &lt;em&gt;signaled exception&lt;/em&gt; . The search proceeds from the most recently created &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; to the oldest &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; A matching handler is defined to be one which would return &lt;em&gt;true&lt;/em&gt; if the message &lt;code&gt;#handles:&lt;/code&gt; was sent to its &lt;em&gt;exception selector&lt;/em&gt; with the &lt;em&gt;signaled exception&lt;/em&gt; as the argument.&lt;/p&gt;&lt;p&gt; If a matching handler is found, the &lt;em&gt;exception action&lt;/em&gt; of the handler is evaluated in the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; that was current when the handler was created and the state of the current &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; is preserved as the &lt;em&gt;signaling environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;exception action&lt;/em&gt; is evaluated as if the message &lt;code&gt;#value:&lt;/code&gt; were sent to it with a &amp;lt;signaledException&amp;gt; passed as its argument. The &amp;lt;signaledException&amp;gt; is derived from the &lt;em&gt;signaled exception&lt;/em&gt; in an implementation dependent manner.&lt;/p&gt;&lt;p&gt; If the evaluation of the &lt;em&gt;exception action&lt;/em&gt; returns normally (as if it had returned from the &lt;code&gt;#value: message)&lt;/code&gt; , the &lt;em&gt;handler environment&lt;/em&gt; is restored and the value returned from the &lt;em&gt;exception action&lt;/em&gt; is returned as the value of the &lt;code&gt;#on:do:&lt;/code&gt; message that created the handler. Before returning, any active &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks created during evaluation of the receiver of the &lt;code&gt;#on:do:&lt;/code&gt; message are evaluated.&lt;/p&gt;&lt;p&gt; If a matching handler is not found when the &lt;em&gt;exception environment&lt;/em&gt; is searched, the &lt;em&gt;default action&lt;/em&gt; for the &lt;em&gt;signaled exception&lt;/em&gt; is performed. This is accomplished as if the message &lt;code&gt;#defaultAction&lt;/code&gt; were sent to the &amp;lt;signaledException&amp;gt;  object derived from the &lt;em&gt;signaled exception&lt;/em&gt; . The &lt;code&gt;#defaultAction&lt;/code&gt; method is executed in the context of the &lt;em&gt;signaling environment&lt;/em&gt; . If the &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; is &lt;em&gt;resumable&lt;/em&gt; the value returned from the &lt;code&gt;#defaultAction&lt;/code&gt; method is returned as the value of the &lt;code&gt;#signal&lt;/code&gt; message. If the &lt;em&gt;signaled exception&lt;/em&gt; is not &lt;em&gt;resumable&lt;/em&gt; the action taken upon completion of the #defaultAction method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="exceptionInstantiator">An exception of the type associated with the receiver is signaled. The &amp;lt;signaledException&amp;gt; is initialized to its default state.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Exception class" docId="5.5.7" abstract="false">
      <ConformsTo protocol="classDescription" />
      <ConformsTo protocol="exceptionInstantiator" />
      <Description>&lt;p&gt;This protocol describe the behavior of &lt;em&gt;class objects&lt;/em&gt; that are used to create, signal, and select exceptions that exist within a specialization hierarchy.&lt;/p&gt;&lt;p&gt; The value of the standard global &lt;code&gt;Exception&lt;/code&gt; is a class object that conforms to this protocol. The class &lt;code&gt;Exception&lt;/code&gt; is explicitly specified  to be subclassable. Conforming implementations must implement its behaviors in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;</Description>
      <StandardGlobal name="Exception">
        <Description>A class name. Conforms to the protocol &amp;lt;Exception class&amp;gt;. Instances of this class conform to the protocol &amp;lt;Exception&amp;gt;.</Description>
        <Class superclass="Object" instaneState="none" />
      </StandardGlobal>
      <Message selector="handles:" docId="5.5.7.1" refined="true">
        <Synopsis />
        <Definition protocol="exceptionSelector">This message determines whether the &lt;em&gt;exception handler&lt;/em&gt; associated with the receiver may be used to process the argument. Answer &lt;em&gt;true&lt;/em&gt; if an associated handler should be used to process &lt;code&gt;exception&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; if an associated handler may not be used to process the exception.</Definition>
        <Refinement protocol="Exception class">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the class of &lt;code&gt;exception&lt;/code&gt; is the receiver or a general subclass of the receiver.&lt;/p&gt;&lt;p&gt; This definition implies that subclasses of an exception class are considered to be &lt;em&gt;subexception&lt;/em&gt; s of the type of exception defined by their superclass. An &lt;em&gt;exception handler&lt;/em&gt; that &lt;em&gt;handles&lt;/em&gt; an exception class will also handle any exceptions that are instances of the exception class's subclasses.&lt;/p&gt;</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="new" docId="5.5.7.2" refined="true">
        <Synopsis />
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="exceptionInstantiator">The object returned is an &amp;lt;exceptionBuilder&amp;gt; that may be used to signal an exception of the same type that would be signaled if the message &lt;code&gt;#signal&lt;/code&gt; is sent to the receiver.</Refinement>
        <Refinement protocol="Exception class">The object returned conforms to &amp;lt;Exception&amp;gt;</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Exception" />
        </ReturnValue>
      </Message>
      <Message selector="signal" docId="5.5.7.3" refined="true">
        <Synopsis />
        <Definition protocol="exceptionSignaler">&lt;p&gt;Associated with the receiver is an &amp;lt;exceptionDescription&amp;gt; called the &lt;em&gt;signaled exception&lt;/em&gt; . The current &lt;em&gt;exception environment&lt;/em&gt; is searched for an &lt;em&gt;exception handler&lt;/em&gt; whose &lt;em&gt;exception selector&lt;/em&gt; matches the &lt;em&gt;signaled exception&lt;/em&gt; . The search proceeds from the most recently created &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; to the oldest &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; A matching handler is defined to be one which would return &lt;em&gt;true&lt;/em&gt; if the message &lt;code&gt;#handles:&lt;/code&gt; was sent to its &lt;em&gt;exception selector&lt;/em&gt; with the &lt;em&gt;signaled exception&lt;/em&gt; as the argument.&lt;/p&gt;&lt;p&gt; If a matching handler is found, the &lt;em&gt;exception action&lt;/em&gt; of the handler is evaluated in the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; that was current when the handler was created and the state of the current &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; is preserved as the &lt;em&gt;signaling environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;exception action&lt;/em&gt; is evaluated as if the message &lt;code&gt;#value:&lt;/code&gt; were sent to it with a &amp;lt;signaledException&amp;gt; passed as its argument. The &amp;lt;signaledException&amp;gt; is derived from the &lt;em&gt;signaled exception&lt;/em&gt; in an implementation dependent manner.&lt;/p&gt;&lt;p&gt; If the evaluation of the &lt;em&gt;exception action&lt;/em&gt; returns normally (as if it had returned from the &lt;code&gt;#value: message)&lt;/code&gt; , the &lt;em&gt;handler environment&lt;/em&gt; is restored and the value returned from the &lt;em&gt;exception action&lt;/em&gt; is returned as the value of the &lt;code&gt;#on:do:&lt;/code&gt; message that created the handler. Before returning, any active &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks created during evaluation of the receiver of the &lt;code&gt;#on:do:&lt;/code&gt; message are evaluated.&lt;/p&gt;&lt;p&gt; If a matching handler is not found when the &lt;em&gt;exception environment&lt;/em&gt; is searched, the &lt;em&gt;default action&lt;/em&gt; for the &lt;em&gt;signaled exception&lt;/em&gt; is performed. This is accomplished as if the message &lt;code&gt;#defaultAction&lt;/code&gt; were sent to the &amp;lt;signaledException&amp;gt;  object derived from the &lt;em&gt;signaled exception&lt;/em&gt; . The &lt;code&gt;#defaultAction&lt;/code&gt; method is executed in the context of the &lt;em&gt;signaling environment&lt;/em&gt; . If the &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; is &lt;em&gt;resumable&lt;/em&gt; the value returned from the &lt;code&gt;#defaultAction&lt;/code&gt; method is returned as the value of the &lt;code&gt;#signal&lt;/code&gt; message. If the &lt;em&gt;signaled exception&lt;/em&gt; is not &lt;em&gt;resumable&lt;/em&gt; the action taken upon completion of the #defaultAction method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="Exception class">The exception signaled conforms to &amp;lt;Exception&amp;gt; with all of its &amp;lt;exceptionDescription&amp;gt; attributes set to their default values.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Exception" docId="5.5.8" abstract="false">
      <ConformsTo protocol="exceptionBuilder" />
      <ConformsTo protocol="signaledException" />
      <Description>&lt;p&gt;This protocol describes the behavior of instances of class &lt;code&gt;Exception&lt;/code&gt; . Typically, actual exceptions used by an application will be either direct or indirect subclasses of this class. Exception combines the behavior of &amp;lt;exceptionBuilder&amp;gt; and &amp;lt;signaledException&amp;gt;.  Instances are used to both supplied inform before an exception is signaled and to pass the information to an exception handler.&lt;/p&gt;&lt;p&gt; As &lt;code&gt;Exception&lt;/code&gt; is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;</Description>
    </Protocol>
    <Protocol name="Notification class" docId="5.5.9" abstract="false">
      <ConformsTo protocol="Exception class" />
      <Description>&lt;p&gt;This protocol describe the behavior of the global &lt;code&gt;Notification&lt;/code&gt; . The value of the standard global &lt;code&gt;Notification&lt;/code&gt; is a class object that conforms to this protocol. The class &lt;code&gt;Notification&lt;/code&gt; is&lt;/p&gt;&lt;p&gt; explicitly specified  to be subclassable in a standard conforming program. Conforming implementations must implement its behaviors in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;signaled exceptions&lt;/em&gt; generated by this type of object conform to the protocol &amp;lt;Notification&amp;gt;.&lt;/p&gt;</Description>
      <StandardGlobal name="Notification">
        <Description>A class name. Conforms to the protocol &amp;lt;Notification class&amp;gt;. &lt;CODE&gt;Notification&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Exception&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Notification&amp;gt;.</Description>
        <Class superclass="Exception" instaneState="none" />
      </StandardGlobal>
      <Message selector="new" docId="5.5.9.1" refined="true">
        <Synopsis />
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="exceptionInstantiator">The object returned is an &amp;lt;exceptionBuilder&amp;gt; that may be used to signal an exception of the same type that would be signaled if the message &lt;code&gt;#signal&lt;/code&gt; is sent to the receiver.</Refinement>
        <Refinement protocol="Exception class">The object returned conforms to &amp;lt;Exception&amp;gt;</Refinement>
        <Refinement protocol="Notification class">The object returned conforms to &amp;lt;Notification&amp;gt;.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Notification" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Notification" docId="5.5.10" abstract="false">
      <ConformsTo protocol="Exception" />
      <Description>&lt;p&gt;This protocol describes the behavior of instances of the class &lt;code&gt;Notification&lt;/code&gt; . These are used to represent exceptional conditions that may occur but which are not considered errors. Actual notification exceptions used by an application may be subclasses of this class.&lt;/p&gt;&lt;p&gt; As &lt;code&gt;Notification&lt;/code&gt; is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;</Description>
      <Message selector="defaultAction" docId="5.5.10.1" refined="true">
        <Synopsis />
        <Definition protocol="exceptionDescription">&lt;p&gt;If the exception described by the receiver is signaled and the current &lt;em&gt;exception environment&lt;/em&gt; does not contain a handler for the exception this method will be executed.&lt;/p&gt;&lt;p&gt; The exact behavior and result of this method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="Notification">No action is taken. The value &lt;em&gt;nil&lt;/em&gt; is returned as the value of the message that signaled the exception.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="nil" />
        </ReturnValue>
      </Message>
      <Message selector="isResumable" docId="5.5.10.2" refined="true">
        <Synopsis />
        <Definition protocol="exceptionDescription">This message is used to determine whether the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is &lt;em&gt;resumable&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .</Definition>
        <Refinement protocol="Notification">Answer &lt;em&gt;true&lt;/em&gt; . Notification exceptions by default are specified to be &lt;em&gt;resumable&lt;/em&gt; .</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Warning class" docId="5.5.11" abstract="false">
      <ConformsTo protocol="Notification class" />
      <Description>&lt;p&gt;This protocol describe the behavior of the global &lt;code&gt;Warning&lt;/code&gt; . The value of the standard global &lt;code&gt;Warning&lt;/code&gt; is a class object that conforms to this protocol. The class &lt;code&gt;Warning&lt;/code&gt; is explicitly specified to be subclassable in a standard conforming program.  Conforming implementations must implement its behaviors in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;signaled exceptions&lt;/em&gt; generated by this type of object conform to the protocol &amp;lt;Warning&amp;gt;.&lt;/p&gt;</Description>
      <StandardGlobal name="Warning">
        <Description>A class name. Conforms to the protocol &amp;lt;Warning class&amp;gt;. &lt;CODE&gt;Warning&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Notification&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Warning&amp;gt;.</Description>
        <Class superclass="Notification" instaneState="none" />
      </StandardGlobal>
      <Message selector="new" docId="5.5.11.1" refined="true">
        <Synopsis />
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="exceptionInstantiator">The object returned is an &amp;lt;exceptionBuilder&amp;gt; that may be used to signal an exception of the same type that would be signaled if the message &lt;code&gt;#signal&lt;/code&gt; is sent to the receiver.</Refinement>
        <Refinement protocol="Exception class">The object returned conforms to &amp;lt;Exception&amp;gt;</Refinement>
        <Refinement protocol="Warning class">The object returned conforms to &amp;lt;Warning&amp;gt;</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Warning" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Warning" docId="5.5.12" abstract="false">
      <ConformsTo protocol="Notification" />
      <Description>&lt;p&gt;This protocol describes the behavior of instances of class Warning. These are used to represent exceptional conditions that might occur that are not considered errors but which should be reported to the user. Typically, the actual warning exceptions used by an application will be subclasses of this class.&lt;/p&gt;&lt;p&gt; As &lt;code&gt;Warning&lt;/code&gt; is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;</Description>
      <Message selector="defaultAction" docId="5.5.12.1" refined="true">
        <Synopsis>The default action taken if the exception is signaled.</Synopsis>
        <Definition protocol="exceptionDescription">&lt;p&gt;If the exception described by the receiver is signaled and the current &lt;em&gt;exception environment&lt;/em&gt; does not contain a handler for the exception this method will be executed.&lt;/p&gt;&lt;p&gt; The exact behavior and result of this method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="Notification">No action is taken. The value &lt;em&gt;nil&lt;/em&gt; is returned as the value of the message that signaled the exception.</Refinement>
        <Refinement protocol="Warning">The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the &lt;code&gt;#signal:&lt;/code&gt; message.</Refinement>
      </Message>
    </Protocol>
    <Protocol name="Error class" docId="5.5.13" abstract="false">
      <ConformsTo protocol="Exception class" />
      <Description>&lt;p&gt;This protocol describe the behavior of the global &lt;code&gt;Error&lt;/code&gt; . The value of the standard global &lt;code&gt;Error&lt;/code&gt; is a class object that conforms to this protocol. The class &lt;code&gt;Error&lt;/code&gt; is explicitly specified  to be subclassable in a standard conforming program. Conforming implementations must implement its behaviors in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;signaled exceptions&lt;/em&gt; generated by this type of object conform to the protocol &amp;lt;Error&amp;gt;.&lt;/p&gt;</Description>
      <StandardGlobal name="Error">
        <Description>A class name. Conforms to the protocol &amp;lt;Error class&amp;gt;. &lt;CODE&gt;Error&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Exception&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Error&amp;gt;.</Description>
        <Class superclass="Exception" instaneState="none" />
      </StandardGlobal>
      <Message selector="new" docId="5.5.13.1" refined="true">
        <Synopsis />
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="exceptionInstantiator">The object returned is an &amp;lt;exceptionBuilder&amp;gt; that may be used to signal an exception of the same type that would be signaled if the message &lt;code&gt;#signal&lt;/code&gt; is sent to the receiver.</Refinement>
        <Refinement protocol="Exception class">The object returned conforms to &amp;lt;Exception&amp;gt;</Refinement>
        <Refinement protocol="Error class">The object returned conforms to &amp;lt;Error&amp;gt;</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Error" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Error" docId="5.5.14" abstract="false">
      <ConformsTo protocol="Exception" />
      <Description>&lt;p&gt;This protocol describes the behavior of instances of class Error. These are used to represent error conditions that prevent the normal continuation of processing. Actual error exceptions used by an application may be subclasses of this class.&lt;/p&gt;&lt;p&gt; As &lt;code&gt;Error&lt;/code&gt; is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non- &lt;em&gt;fragile&lt;/em&gt; manner.&lt;/p&gt;</Description>
      <Message selector="defaultAction" docId="5.5.14.1" refined="true">
        <Synopsis />
        <Definition protocol="exceptionDescription">&lt;p&gt;If the exception described by the receiver is signaled and the current &lt;em&gt;exception environment&lt;/em&gt; does not contain a handler for the exception this method will be executed.&lt;/p&gt;&lt;p&gt; The exact behavior and result of this method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="Error">The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated.</Refinement>
      </Message>
      <Message selector="isResumable" docId="5.5.14.2" refined="true">
        <Synopsis>Determine whether an exception is resumable.</Synopsis>
        <Definition protocol="exceptionDescription">This message is used to determine whether the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is &lt;em&gt;resumable&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .</Definition>
        <Refinement protocol="Error">Answer &lt;em&gt;false&lt;/em&gt; . Error exceptions by default are assumed to not be &lt;em&gt;resumable&lt;/em&gt; . Subclasses may over- ride this definition for situations where it is appropriate for an error to be resumable.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="ZeroDivide factory" docId="5.5.15" abstract="false">
      <ConformsTo protocol="exceptionInstantiator" />
      <Description>This protocol describe the behavior of the global &lt;code&gt;ZeroDivide&lt;/code&gt; . It is used to as an &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;selector&lt;/em&gt; to catch zero divide exceptions and can also be used to signal that a division by zero error has occured. Zero divide exceptions are resumable so any message in this protocol that signal such an exception may ultimately return to their sender. The &lt;em&gt;signaled exceptions&lt;/em&gt; generated by this type of object conform to the protocol &amp;lt;ZeroDivide&amp;gt;</Description>
      <StandardGlobal name="ZeroDivide">
        <Description>Unspecified language element type. Conforms to the protocol &amp;lt;ZeroDivide class&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="dividend:" docId="5.5.15.1" refined="false">
        <Synopsis>Signal the occurance of a division by zero.</Synopsis>
        <Refinement protocol="ZeroDivide factory">&lt;p&gt;Signal the occurance of a division by zero exception. Capture the number that was being divided such that it is available from the &lt;em&gt;signaled exception&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If the message &lt;code&gt;#dividend&lt;/code&gt; is subsequently sent to the &amp;lt;ZeroDivide&amp;gt; object that is the &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; the value of &lt;code&gt;argument&lt;/code&gt; is returned.&lt;/p&gt;</Refinement>
        <Parameter name="argument" aliasing="captured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="signal" docId="5.5.15.2" refined="true">
        <Synopsis />
        <Definition protocol="exceptionSignaler">&lt;p&gt;Associated with the receiver is an &amp;lt;exceptionDescription&amp;gt; called the &lt;em&gt;signaled exception&lt;/em&gt; . The current &lt;em&gt;exception environment&lt;/em&gt; is searched for an &lt;em&gt;exception handler&lt;/em&gt; whose &lt;em&gt;exception selector&lt;/em&gt; matches the &lt;em&gt;signaled exception&lt;/em&gt; . The search proceeds from the most recently created &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;handler&lt;/em&gt; to the oldest &lt;em&gt;exception handler&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; A matching handler is defined to be one which would return &lt;em&gt;true&lt;/em&gt; if the message &lt;code&gt;#handles:&lt;/code&gt; was sent to its &lt;em&gt;exception selector&lt;/em&gt; with the &lt;em&gt;signaled exception&lt;/em&gt; as the argument.&lt;/p&gt;&lt;p&gt; If a matching handler is found, the &lt;em&gt;exception action&lt;/em&gt; of the handler is evaluated in the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; that was current when the handler was created and the state of the current &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;environment&lt;/em&gt; is preserved as the &lt;em&gt;signaling environment&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;exception action&lt;/em&gt; is evaluated as if the message &lt;code&gt;#value:&lt;/code&gt; were sent to it with a &amp;lt;signaledException&amp;gt; passed as its argument. The &amp;lt;signaledException&amp;gt; is derived from the &lt;em&gt;signaled exception&lt;/em&gt; in an implementation dependent manner.&lt;/p&gt;&lt;p&gt; If the evaluation of the &lt;em&gt;exception action&lt;/em&gt; returns normally (as if it had returned from the &lt;code&gt;#value: message)&lt;/code&gt; , the &lt;em&gt;handler environment&lt;/em&gt; is restored and the value returned from the &lt;em&gt;exception action&lt;/em&gt; is returned as the value of the &lt;code&gt;#on:do:&lt;/code&gt; message that created the handler. Before returning, any active &lt;code&gt;#ensure:&lt;/code&gt; or &lt;code&gt;#ifCurtailed:&lt;/code&gt; termination blocks created during evaluation of the receiver of the &lt;code&gt;#on:do:&lt;/code&gt; message are evaluated.&lt;/p&gt;&lt;p&gt; If a matching handler is not found when the &lt;em&gt;exception environment&lt;/em&gt; is searched, the &lt;em&gt;default action&lt;/em&gt; for the &lt;em&gt;signaled exception&lt;/em&gt; is performed. This is accomplished as if the message &lt;code&gt;#defaultAction&lt;/code&gt; were sent to the &amp;lt;signaledException&amp;gt;  object derived from the &lt;em&gt;signaled exception&lt;/em&gt; . The &lt;code&gt;#defaultAction&lt;/code&gt; method is executed in the context of the &lt;em&gt;signaling environment&lt;/em&gt; . If the &lt;em&gt;signaled&lt;/em&gt; &lt;em&gt;exception&lt;/em&gt; is &lt;em&gt;resumable&lt;/em&gt; the value returned from the &lt;code&gt;#defaultAction&lt;/code&gt; method is returned as the value of the &lt;code&gt;#signal&lt;/code&gt; message. If the &lt;em&gt;signaled exception&lt;/em&gt; is not &lt;em&gt;resumable&lt;/em&gt; the action taken upon completion of the #defaultAction method is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="exceptionInstantiator">An exception of the type associated with the receiver is signaled. The &amp;lt;signaledException&amp;gt; is initialized to its default state.</Refinement>
        <Refinement protocol="ZeroDivide factory">The &lt;em&gt;signaled exception&lt;/em&gt; conforms to &amp;lt;ZeroDivide&amp;gt;  and all of its &amp;lt;exceptionDescription&amp;gt; attributes set to their default values.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="ZeroDivide" docId="5.5.16" abstract="false">
      <ConformsTo protocol="Error" />
      <Description>This protocol describes the behavior of exceptions that are signalled when an attempt is made to divide some number (the dividend) by zero.</Description>
      <Message selector="dividend" docId="5.5.16.1" refined="false">
        <Synopsis>Answer the number that was being divided by zero.</Synopsis>
        <Definition protocol="ZeroDivide">Answer the number that was being divided by zero.</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="number" />
        </ReturnValue>
      </Message>
      <Message selector="isResumable" docId="5.5.16.2" refined="true">
        <Synopsis>Determine whether an exception is resumable.</Synopsis>
        <Definition protocol="exceptionDescription">This message is used to determine whether the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is &lt;em&gt;resumable&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .</Definition>
        <Refinement protocol="Error">Answer &lt;em&gt;false&lt;/em&gt; . Error exceptions by default are assumed to not be &lt;em&gt;resumable&lt;/em&gt; . Subclasses may over- ride this definition for situations where it is appropriate for an error to be resumable.</Refinement>
        <Refinement protocol="ZeroDivide">Answer &lt;em&gt;true&lt;/em&gt; .</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="MessageNotUnderstoodSelector" docId="5.5.17" abstract="false">
      <ConformsTo protocol="exceptionSelector" />
      <Description>&lt;p&gt;This protocol describe the behavior of the value of the global named &lt;code&gt;MessageNotUnderstood&lt;/code&gt; . This object  is used to as an &lt;em&gt;exception selector&lt;/em&gt; to catch failed message sends. Message not understood exceptions are resumable so any message in this protocol that signal such an exception may ultimately return to their sender.&lt;/p&gt;&lt;p&gt; This object is not specifed as an &amp;lt;exceptionSignaler&amp;gt; or an &amp;lt;exceptionInstantiator&amp;gt;. It as assumed that message not understood exceptions are signaled by the implemention dependent implementaton of the message &amp;lt;Object&amp;gt; #doesNotUnderstand:.&lt;/p&gt;</Description>
      <StandardGlobal name="MessageNotUnderstood">
        <Description>Unspecified language element type. Conforms to the protocol &amp;lt;MessageNotUnderstoodSelector&amp;gt;. Used as an &lt;em&gt;exception selector&lt;/em&gt; .</Description>
      </StandardGlobal>
      <Message selector="handles:" docId="5.5.17.1" refined="true">
        <Synopsis>Determine whether an &lt;em&gt;exception handler&lt;/em&gt; will accept a &lt;em&gt;signaled exception&lt;/em&gt; .</Synopsis>
        <Definition protocol="exceptionSelector">This message determines whether the &lt;em&gt;exception handler&lt;/em&gt; associated with the receiver may be used to process the argument. Answer &lt;em&gt;true&lt;/em&gt; if an associated handler should be used to process &lt;code&gt;exception&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; if an associated handler may not be used to process the exception.</Definition>
        <Refinement protocol="MessageNotUnderstoodSelector">Return true if &lt;code&gt;exception&lt;/code&gt; is an exception that is the result of a failed message send.</Refinement>
        <Parameter name="exception" aliasing="unspecified">
          <Protocol name="exceptionDescription" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="MessageNotUnderstood" docId="5.5.18" abstract="false">
      <ConformsTo protocol="Error" />
      <Description>This protocol describes the behavior of exceptions that are signalled if the receiver of a message does not have a method with a matching  selector.</Description>
      <Message selector="message" docId="5.5.18.1" refined="false">
        <Synopsis>Answer the selector and arguments of the message that failed.</Synopsis>
        <Definition protocol="MessageNotUnderstood">Answer the selector and arguments of the message that failed.</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="failedMessage" />
        </ReturnValue>
      </Message>
      <Message selector="isResumable" docId="5.5.18.2" refined="true">
        <Synopsis>Determine whether an exception is resumable.</Synopsis>
        <Definition protocol="exceptionDescription">This message is used to determine whether the receiver is a &lt;em&gt;resumable&lt;/em&gt; exception. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is &lt;em&gt;resumable&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if the receiver is not &lt;em&gt;resumable&lt;/em&gt; .</Definition>
        <Refinement protocol="Error">Answer &lt;em&gt;false&lt;/em&gt; . Error exceptions by default are assumed to not be &lt;em&gt;resumable&lt;/em&gt; . Subclasses may over- ride this definition for situations where it is appropriate for an error to be resumable.</Refinement>
        <Refinement protocol="MessageNotUnderstood">Answer &lt;em&gt;true&lt;/em&gt; .</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="message" docId="5.5.18.3" refined="false">
        <Synopsis>Answer the selector and arguments of the message that failed.</Synopsis>
        <Definition protocol="MessageNotUnderstood">Answer the selector and arguments of the message that failed.</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="failedMessage" />
        </ReturnValue>
      </Message>
      <Message selector="receiver" docId="5.5.18.4" refined="false">
        <Synopsis>Answer the receiver  the message that failed.</Synopsis>
        <Definition protocol="MessageNotUnderstood">Answer the object that was the receiver of the message that failed.</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="exceptionSet" docId="5.5.19" abstract="true">
      <ConformsTo protocol="exceptionSelector" />
      <Description>This protocol describes the behavior of objects that may be used to group a set of &amp;lt;exceptionSelector&amp;gt; objects into a single &amp;lt;exceptionSelector&amp;gt;. This is useful for establishing a single &lt;em&gt;exception handler&lt;/em&gt; that may deal with several different types of exceptions.</Description>
      <Message selector="," docId="5.5.19.1" refined="true">
        <Synopsis />
        <Definition protocol="exceptionSelector">Return an exception set that contains the receiver and the argument exception. This is commonly used to specify a set of exception selectors for an &lt;em&gt;exception handler&lt;/em&gt; .</Definition>
        <Refinement protocol="exceptionSet">&lt;p&gt;In addition to &lt;code&gt;anotherException&lt;/code&gt; the exception set that is returned contains all of the &lt;em&gt;exception&lt;/em&gt; &lt;em&gt;selectors&lt;/em&gt; contained in the receiver.&lt;/p&gt;&lt;p&gt; The returned object may or may not be the same object as the receiver.&lt;/p&gt;</Refinement>
        <Parameter name="anotherException" aliasing="captured">
          <Protocol name="exceptionSelector" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="exceptionSet" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="magnitude" docId="5.6.1" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>Provides protocol for comparing objects which are linearly ordered with respect to some comparison operation.</Description>
      <Message selector="&lt;" docId="5.6.1.1" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand with respect to the ordering defined for them. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
      <Message selector="&lt;=" docId="5.6.1.2" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than or equal to operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver would answer &lt;em&gt;true&lt;/em&gt; to either the #&amp;lt; or #= message with operand as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
      <Message selector="&gt;" docId="5.6.1.3" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand with respect to the natural ordering. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
      <Message selector="&gt;=" docId="5.6.1.4" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than or equal to operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver answers &lt;em&gt;true&lt;/em&gt; to either the #&amp;gt; or #= message with operand as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
      <Message selector="between:and:" docId="5.6.1.5" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than or equal to max, and greater than or equal to min. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver answers &lt;em&gt;true&lt;/em&gt; to the #&amp;lt;= message with max as the parameter, and also answers &lt;em&gt;true&lt;/em&gt; to the #&amp;gt;= message with min as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver  and min or max are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="min" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <Parameter name="max" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>Receiver and operands are not &lt;em&gt;comparable&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="max:" docId="5.6.1.6" refined="false">
        <Synopsis>Answer the receiver if it is greater than operand. Answer operand otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer the receiver if the receiver answers &lt;em&gt;true&lt;/em&gt; to the #&amp;gt; message with operand as the parameter. Answer operand otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="magnitude" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
      <Message selector="min:" docId="5.6.1.7" refined="false">
        <Synopsis>Answer the receiver if it is less than operand. Answer operand otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer the receiver if the receiver answers &lt;em&gt;true&lt;/em&gt; to the #&amp;lt; message with operand as the parameter. Answer operand otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="magnitude" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="magnitude" />
        </ReturnValue>
        <Errors>Receiver and operand are not &lt;em&gt;comparable&lt;/em&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="number" docId="5.6.2" abstract="true">
      <ConformsTo protocol="magnitude" />
      <Description>&lt;p&gt;Provides protocol for objects that represent  numeric  quantities and support operations performing arithmetic, arithmetic progressions, and conversion on numerical quantities.&lt;/p&gt;&lt;p&gt; The descriptions of messages in this protocol reference specific arithmetic and numerical operations in the ISO/IEC 10967 standard, providing definition-by-reference for these operations.&lt;/p&gt;&lt;p&gt; Smalltalk provides for mixed-mode arithmetic with the receiver and argument having different &lt;em&gt;numeric representations&lt;/em&gt; . Unless otherwise specified by an individual operation the receiver and argument are first converted to the same &lt;em&gt;numeric representation&lt;/em&gt; according to the following table.&lt;/p&gt;&lt;p&gt; &lt;b&gt;Default Conversion Table:&lt;/b&gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;operand&lt;/b&gt; &lt;b&gt;&amp;lt;integer&amp;gt;&lt;/b&gt; &lt;b&gt;&amp;lt;scaledDecimal&amp;gt; &amp;lt;Fraction&amp;gt; &amp;lt;Float&amp;gt;&lt;/b&gt; &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &lt;b&gt;receiver&lt;/b&gt; &lt;b&gt;e&lt;/b&gt; &lt;b&gt;d&lt;/b&gt; &lt;b&gt;q&lt;/b&gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;integer&amp;gt;&lt;/b&gt; &amp;lt;integer&amp;gt; &amp;lt;scaledDecimal&amp;gt; &amp;lt;Fraction&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; e d q &lt;b&gt;&amp;lt;scaledDecimal&amp;gt;&lt;/b&gt;&amp;lt;scaledDecimal&amp;gt; &amp;lt;scaledDecimal&amp;gt; &amp;lt;Fraction&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; e d q &lt;b&gt;&amp;lt;Fraction&amp;gt;&lt;/b&gt; &amp;lt;Fraction&amp;gt; &amp;lt;Fraction&amp;gt; &amp;lt;Fraction&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; e d q &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &lt;b&gt;e&lt;/b&gt; e e e e d q &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &lt;b&gt;d&lt;/b&gt; d d d d d q &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &amp;lt;Float&amp;gt; &lt;b&gt;q&lt;/b&gt; q q q q q q&lt;/p&gt;&lt;p&gt; If multiple representations of &amp;lt;Float&amp;gt; are available, the representations are ordered from smallest to largest precision. This table contains multiple entries for &amp;lt;Float&amp;gt;, designated by a subscript, one for each designation of floating point literal representation. Values that are converted to &amp;lt;Float&amp;gt; are converted to the smallest precision of Float that can represent the number of digits in the original value.&lt;/p&gt;&lt;p&gt; An &amp;lt;integer&amp;gt; converted to a &amp;lt;scaledDecimal&amp;gt; will have the scale of the other operand with the fractional digits set to zero.  A &amp;lt;scaledDecimal&amp;gt; converted to a &amp;lt;Fraction&amp;gt; will be a fraction having the same numeric value but having an integer numerator and a denominator which is ten raised to the power of the &amp;lt;scaledDecimal&amp;gt;'s scale factor.&lt;/p&gt;&lt;p&gt; The result type of most numeric opeations is based upon the operaand type.  The Default Result Type for all operand types except &amp;lt;Fraction&amp;gt; is the type to which the operands have been converted according to the Default ConversionTable. If the converted operand type is &amp;lt;Fraction&amp;gt; the Default Result Type is &amp;lt;rational&amp;gt;. In all cases where the type of the return value differs from the default result type it is noted in the operation's description.&lt;/p&gt;&lt;p&gt; Operations can produce results that are outside the set of representable numbers, or mathematically undefined. It is implementation defined whether errors are raised when results are not representable or if unrepresentable results are wrapped in implementation-defined continuation values or their equivalent. The effect of underflow and overflow is therefore implementation defined.&lt;/p&gt;&lt;p&gt; &amp;lt;number&amp;gt; conforms to &amp;lt;magnitude&amp;gt;. All object that implement the &amp;lt;number&amp;gt; protocol or any protocol that conforms to &amp;lt;number&amp;gt; are &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Description>
      <Message selector="*" docId="5.6.2.1" refined="false">
        <Synopsis>Answer the result of multiplying the receiver by &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number whose value is the result of multiplying the receiver and &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 multiplication operation &lt;em&gt;mul&lt;/em&gt; . To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different representations  a conversion to their common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the common representation is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;mul&lt;/em&gt; . If the common representation is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;mul&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;mul&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value is defined to be the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver after conversion if necessary.&lt;/p&gt;&lt;p&gt; If the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
      </Message>
      <Message selector="+" docId="5.6.2.2" refined="false">
        <Synopsis>Answer the result of adding &lt;code&gt;operand&lt;/code&gt; to the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number whose value is the result of adding the receiver and &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 addition operation &lt;em&gt;add&lt;/em&gt; . To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different&lt;/p&gt;&lt;p&gt; representations a conversion to a common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;add&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;add&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;add&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value is defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt;  then the scale of the result is at least the scale of the receiver after conversion if necessary. If the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
      </Message>
      <Message selector="-" docId="5.6.2.3" refined="false">
        <Synopsis>Answer the result of subtracting &lt;code&gt;operand&lt;/code&gt; from the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number whose value is the result of subtracting the receiver and &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 subtraction operation &lt;em&gt;sub&lt;/em&gt; . To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;sub&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;sub&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;sub&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value is defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver after conversion if necessary. If the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
      </Message>
      <Message selector="/" docId="5.6.2.4" refined="false">
        <Synopsis>Answer the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number whose value is the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 flooring division operation &lt;em&gt;div&lt;/em&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;,&lt;/p&gt;&lt;p&gt; then the result value is a &amp;lt;rational&amp;gt; with the receiver as the numerator and the &lt;code&gt;operand&lt;/code&gt; as the denominator.  If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;div&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;div&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If both operands conform to &amp;lt;integer&amp;gt; the result value will conform to &amp;lt;rational&amp;gt;. Otherwise the protocol and representation of the return value are defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver after conversion if necessary.&lt;/p&gt;&lt;p&gt; If  the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined. If either the receiver or operand are of type &amp;lt;Float&amp;gt; and the operand has a value of zero, the result is implementation defined. The implementation must either signal the ZeroDivide exception or provide a continuation value. For all other &lt;em&gt;numeric representations&lt;/em&gt; the ZeroDivide exception is signaled.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>&lt;p&gt;If the operands conform to integer then &amp;lt;rational&amp;gt;&lt;/p&gt;&lt;p&gt; otherwise the Default Result Type&lt;/p&gt;</Description>
        </ReturnValue>
        <Errors>&lt;code&gt;operand&lt;/code&gt; = 0 unless receiver or &lt;code&gt;operand&lt;/code&gt; are of type &amp;lt;Float&amp;gt;</Errors>
      </Message>
      <Message selector="//" docId="5.6.2.5" refined="false">
        <Synopsis>Answer the truncated quotient resulting from dividing the receiver by &lt;code&gt;operand&lt;/code&gt; . The truncation is towards negative infinity.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer an integer whose value is the truncated result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 flooring division operation &lt;em&gt;div&lt;/em&gt; . Truncation is towards negative infinity. The sign of the result is positive if the receiver and &lt;code&gt;operand&lt;/code&gt; have the same sign, and negative if the signs are different.&lt;/p&gt;&lt;p&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;div&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;div&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;div&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If the operand has a value of zero the ZeroDivide exception is signaled.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;code&gt;operand&lt;/code&gt; = 0 unless receiver or &lt;code&gt;operand&lt;/code&gt; are of type &amp;lt;Float&amp;gt;</Errors>
      </Message>
      <Message selector="&lt;" docId="5.6.2.6" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand with respect to the ordering defined for them. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="number">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;operand&lt;/code&gt; is numerically less than the receiver, as specified by the ISO/IEC 10967 comparison operation &lt;em&gt;lss&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;lss&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;lss&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;lss&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="=" docId="5.6.2.7" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a&lt;/p&gt;&lt;p&gt; collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Refinement protocol="number">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;operand&lt;/code&gt; is numerically equal to the receiver, as specified by the ISO/IEC 10967 equality operation &lt;em&gt;eq&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if they are not numerically equal or if &lt;code&gt;operand&lt;/code&gt; is not a number.&lt;/p&gt;&lt;p&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;eq&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;eq&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;eq&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Numeric equality is defined by implementation defined conventions regarding round-off error and representation of numbers, hence behavior of this message may differ between platforms.&lt;/p&gt;</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&gt;" docId="5.6.2.8" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand with respect to the natural ordering. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="number">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;operand&lt;/code&gt; is numerically less than the receiver, as specified by the ISO/IEC 10967 comparison operation &lt;em&gt;gtr&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;gtr&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;gtr&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;gtr&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="\\" docId="5.6.2.9" refined="false">
        <Synopsis>Answer the remainder after integer division of the receiver by the &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer the remainder of truncating integer division as specified by the ISO/IEC 10967 remainder operation &lt;em&gt;rem&lt;/em&gt; . The remainder has the same sign as &lt;code&gt;operand&lt;/code&gt; . To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;rem&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;rem&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;rem&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value is defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver.&lt;/p&gt;&lt;p&gt; Within the limits of representation, the following invariant should hold:&lt;/p&gt;&lt;p&gt; (receiver // &lt;code&gt;operand&lt;/code&gt; ) * &lt;code&gt;operand&lt;/code&gt; + (receiver \\ &lt;code&gt;operand&lt;/code&gt; ) = receiver&lt;/p&gt;&lt;p&gt; If the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined. If either the receiver or operand is of type &amp;lt;Float&amp;gt; and the operand has a value of zero, the result is implementation defined. The implementation may signal the ZeroDivide exception or provide a continuation value. For all other &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; the ZeroDivide exception is signaled.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
        <Errors>&lt;code&gt;operand&lt;/code&gt; = 0 unless receiver or &lt;code&gt;operand&lt;/code&gt; are of type &amp;lt;Float&amp;gt;</Errors>
      </Message>
      <Message selector="abs" docId="5.6.2.10" refined="false">
        <Synopsis>Answer the absolute value of the receiver.</Synopsis>
        <Definition protocol="number">Return the absolute value of the receiver, as specified by the ISO/IEC 10967 operation &lt;em&gt;abs&lt;/em&gt; . If the receiver is greater than or equal to zero, answer an object equal to the receiver. Otherwise answer an object which is equal to the negation of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="asFloat" docId="5.6.2.11" refined="false">
        <Synopsis>Answer a floating-point number approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Return the nearest floating-point number to the receiver, as specified by the ISO/IEC 10967 &lt;em&gt;cvt&lt;/em&gt; operation.&lt;/p&gt;&lt;p&gt; If an implementation supports multiple representations for floating point numbers, the result is the representation with the smallest precision that will represent a number with the same number of digits as the receiver, truncating to the maximum precision of the representation with the largest precision.&lt;/p&gt;&lt;p&gt; The effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="asFloatD" docId="5.6.2.12" refined="false">
        <Synopsis>Answer a d precision floating-point number approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Return the nearest floating-point number to the receiver, as specified by the ISO/IEC 10967 &lt;em&gt;cvt&lt;/em&gt; operation.&lt;/p&gt;&lt;p&gt; Use the object representation for floating point numbers that corresponds to the representation used for numeric literals with the exponent designation 'd'.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="asFloatE" docId="5.6.2.13" refined="false">
        <Synopsis>Answer a floating-point number approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Return the nearest floating-point number to the receiver, as specified by the ISO/IEC 10967 &lt;em&gt;cvt&lt;/em&gt; operation.&lt;/p&gt;&lt;p&gt; Use the object representation for floating point numbers that corresponds to the representation used for numeric literals with the exponent designation 'e'.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="asFloatQ" docId="5.6.2.14" refined="false">
        <Synopsis>Answer a floating-point number approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Return the nearest floating-point number to the receiver, as specified by the ISO/IEC 10967 &lt;em&gt;cvt&lt;/em&gt; operation.&lt;/p&gt;&lt;p&gt; Use the object representation for floating point numbers that corresponds to the representation used for numeric literals with the exponent designation 'q'.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="asFraction" docId="5.6.2.15" refined="false">
        <Synopsis>Answer a fraction approximating the receiver.</Synopsis>
        <Definition protocol="number">Answer a fraction that reasonably approximates the receiver. If the receiver is an integral value the result may be &amp;lt;integer&amp;gt;.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="rational" />
        </ReturnValue>
      </Message>
      <Message selector="asInteger" docId="5.6.2.16" refined="false">
        <Synopsis>Answer an integer approximating the receiver.</Synopsis>
        <Definition protocol="number">Answer the result of sending &lt;code&gt;#rounded&lt;/code&gt; to the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="asScaledDecimal:" docId="5.6.2.17" refined="false">
        <Synopsis>Answer a scaled decimal number, with a fractional precision of &lt;code&gt;scale&lt;/code&gt; , approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;This is a conversion message. Answer a scaled decimal number, with a fractional precision of &lt;code&gt;scale,&lt;/code&gt; which minimizes the difference between the answered value and the receiver.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="scaledDecimal" />
        </ReturnValue>
      </Message>
      <Message selector="ceiling" docId="5.6.2.18" refined="false">
        <Synopsis>Answer the smallest integer greater than or equal to the receiver.</Synopsis>
        <Definition protocol="number">Answer the smallest integer greater than or equal to the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="floor" docId="5.6.2.19" refined="false">
        <Synopsis>Answer the largest integer less than or equal to the receiver.</Synopsis>
        <Definition protocol="number">Answer the largest integer less than or equal to the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="fractionPart" docId="5.6.2.20" refined="false">
        <Synopsis>Answer the fractional part of the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Return an object conforming to the protocol of the receiver that is equal to the fractional part of the receiver. Within the limits of representation, the following invariants should hold:&lt;/p&gt;&lt;p&gt; receiver integerPart + receiver fractionPart = receiver&lt;/p&gt;&lt;p&gt; receiver \\1 = receiver fractionPart&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="integerPart" docId="5.6.2.21" refined="false">
        <Synopsis>Answer the integer part of the receiver.</Synopsis>
        <Definition protocol="number">Return an object that is equal to the integer part of the receiver.  If the receiver is type &amp;lt;Fraction&amp;gt; return an object conforming to &amp;lt;integer&amp;gt;. Otherwise return an object conforming to the protocol of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Description>&lt;p&gt;&lt;b&gt;receiver&lt;/b&gt; &lt;b&gt;result&lt;/b&gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;rational&amp;gt;&lt;/b&gt; &amp;lt;rational&amp;gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;scaledDecimal&amp;gt;&lt;/b&gt; &amp;lt;scaledDecimal&amp;gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &amp;lt;Float&amp;gt;&lt;/p&gt;</Description>
        </ReturnValue>
      </Message>
      <Message selector="negated" docId="5.6.2.22" refined="false">
        <Synopsis>Answer the negation of the receiver.</Synopsis>
        <Definition protocol="number">Answer an object conforming to the receiver's protocol that is equal to the negation of the receiver (equal in magnitude to the receiver but opposite in sign), as specified by the ISO/IEC 10967 &lt;em&gt;neg&lt;/em&gt; operation.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="negative" docId="5.6.2.23" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is negative.</Synopsis>
        <Definition protocol="number">Answer &lt;em&gt;true&lt;/em&gt; if the receiver is negative. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="positive" docId="5.6.2.24" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is positive or zero.</Synopsis>
        <Definition protocol="number">Answer &lt;em&gt;true&lt;/em&gt; if the receiver is positive or zero. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="printString" docId="5.6.2.25" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="number">Answer a string that is a valid literal representation that approximates the numeric value of the receiver.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="quo:" docId="5.6.2.26" refined="false">
        <Synopsis>Answer the truncated integer quotient resulting from dividing the receiver by &lt;code&gt;operand&lt;/code&gt; . Truncation is towards zero.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number whose value is the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; , as specified by the ISO/IEC 10967 flooring division operation &lt;em&gt;div&lt;/em&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is a &amp;lt;rational&amp;gt; with the receiver as the numerator and the &lt;code&gt;operand&lt;/code&gt; as the denominator.  If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;div&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;div&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value are defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver after conversion if necessary.&lt;/p&gt;&lt;p&gt; If the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined. If either the receiver or operand are of type &amp;lt;Float&amp;gt; and the operand has a value of zero, the result is implementation defined. The implementation must either signal the ZeroDivide exception or provide a continuation value. For all other &lt;em&gt;numeric representations&lt;/em&gt; the ZeroDivide exception is signaled.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;code&gt;operand&lt;/code&gt; = 0 unless receiver or &lt;code&gt;operand&lt;/code&gt; are of type &amp;lt;Float&amp;gt;</Errors>
      </Message>
      <Message selector="raisedTo:" docId="5.6.2.27" refined="false">
        <Synopsis>Answer the receiver raised to the power &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;If &lt;code&gt;operand&lt;/code&gt; conforms to &amp;lt;integer&amp;gt;, answer the result of sending &lt;code&gt;#raisedToInteger:&lt;/code&gt; with argument &lt;code&gt;operand&lt;/code&gt; to the receiver.&lt;/p&gt;&lt;p&gt; Otherwise answer&lt;/p&gt;&lt;p&gt; &lt;code&gt;(receiver asFloat ln * operand) exp.&lt;/p&gt;&lt;p&gt;&lt;/code&gt; It is erroneous if the receiver equals zero and the &lt;code&gt;operand&lt;/code&gt; is less than or equal to zero, or if the receiver is less than zero. The effect of underflow and overflow is implementation defined.&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;numeric representation&lt;/em&gt; of the result has does not have &lt;em&gt;unbounded precision,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
        <Errors>&lt;p&gt;receiver = 0 and &lt;code&gt;operand&lt;/code&gt; &amp;lt;= 0&lt;/p&gt;&lt;p&gt; receiver &amp;lt; 0&lt;/p&gt;</Errors>
      </Message>
      <Message selector="raisedToInteger:" docId="5.6.2.28" refined="false">
        <Synopsis>Answer the receiver raised to the power &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer the receiver raised to the power &lt;code&gt;operand&lt;/code&gt; , which must be a whole number. If the &lt;code&gt;operand&lt;/code&gt; is a whole number greater than or equal to zero, then the result is the receiver raised to the power &lt;code&gt;operand&lt;/code&gt; . If &lt;code&gt;operand&lt;/code&gt; is a negative whole number then the result is equivalent to the reciprocal of the absolute value of the receiver raised to the power &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; It is erroneous if the &lt;code&gt;operand&lt;/code&gt; does not conform to the protocol &amp;lt;integer&amp;gt;. If the &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; of the result has does not have &lt;em&gt;unbounded precision,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>Receiver is not an integer.</Errors>
      </Message>
      <Message selector="reciprocal" docId="5.6.2.29" refined="false">
        <Synopsis>Answer the reciprocal of the receiver.</Synopsis>
        <Definition protocol="number">Answer the reciprocal of the receiver, which is equal to the result of the operation (1/receiver). Signal a ZeroDivide exception if the receiver is equal to zero.</Definition>
        <ReturnValue aliasing="unspecified">
          <Description>&lt;p&gt;&lt;b&gt;receiver&lt;/b&gt; &lt;b&gt;result&lt;/b&gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;integer&amp;gt;&lt;/b&gt; &amp;lt;rational&amp;gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;Fraction&amp;gt;&lt;/b&gt; &amp;lt;rational&amp;gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;scaledDecimal&amp;gt;&lt;/b&gt; &amp;lt;scaledDecimal&amp;gt;&lt;/p&gt;&lt;p&gt; &lt;b&gt;&amp;lt;Float&amp;gt;&lt;/b&gt; &amp;lt;Float&amp;gt;&lt;/p&gt;</Description>
        </ReturnValue>
        <Errors>receiver = 0</Errors>
      </Message>
      <Message selector="rem:" docId="5.6.2.30" refined="false">
        <Synopsis>Answer the remainder after integer division of the receiver by the &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer the remainder with respect to integer division, as specified by the ISO/IEC 10967 remainder operation &lt;em&gt;rem&lt;/em&gt; . The sign of the remainder is the same sign as the receiver. Within the limits of representation, the following invariant should hold:&lt;/p&gt;&lt;p&gt; &lt;code&gt;(receiver quo: operand)*operand + receiver rem: operand) = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table,&lt;/p&gt;&lt;p&gt; The protocol and representation of the return value is defined by the Default Result Type. If the return value conforms to &amp;lt;scaledDecimal&amp;gt; then the scale of the result is at least the scale of the receiver after conversion if necessary. If either the receiver or operand are of type &amp;lt;Float&amp;gt; and the operand has a value of zero, the result is implementation defined. The implementation may signal the ZeroDivide exception or provide a continuation value. For all other &lt;em&gt;numeric representations&lt;/em&gt; the ZeroDivide exception is signaled. If  the result value is outside of the &lt;em&gt;range&lt;/em&gt; of the common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
        <Errors>&lt;code&gt;operand&lt;/code&gt; = 0 unless receiver or &lt;code&gt;operand&lt;/code&gt; are of type &amp;lt;Float&amp;gt;</Errors>
      </Message>
      <Message selector="rounded" docId="5.6.2.31" refined="false">
        <Synopsis>Answer the integer nearest the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer the integer nearest the receiver according  to the following property:&lt;/p&gt;&lt;p&gt; N rounded = the nearest integer I = N + (N sign * (1/2)) truncated towards zero.&lt;/p&gt;&lt;p&gt; For example, 0.5 rounded = 1 and -0.5 rounded = -1.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="roundTo:" docId="5.6.2.32" refined="false">
        <Synopsis>Answer the number nearest the receiver that is a multiple of &lt;code&gt;factor&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer the number nearest the receiver that is a multiple of &lt;code&gt;factor&lt;/code&gt; . The result conforms to either the receiver's or &lt;code&gt;operand&lt;/code&gt; 's protocol, according to the Default Conversion Table.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;factor&lt;/code&gt; equals zero. If the &lt;em&gt;numeric representation&lt;/em&gt; of the result has does not have &lt;em&gt;unbounded precision,&lt;/em&gt; the effect of underflow or overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="factor" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
      </Message>
      <Message selector="sign" docId="5.6.2.33" refined="false">
        <Synopsis>Answer the sign of the receiver.</Synopsis>
        <Definition protocol="number">Answer 1 if the receiver is positive, 0 if the receiver equals 0, and -1 if it is negative, as specified by the ISO/IEC 10967 operation &lt;em&gt;sign&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="sqrt" docId="5.6.2.34" refined="false">
        <Synopsis>Answer the positive square root of the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer a number equal to the positive square root of the receiver as specified by the ISO/IEC 10967 remainder operation &lt;em&gt;sqrt&lt;/em&gt; . If the receiver's protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;sqrt&lt;/em&gt; . If the receiver's protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;sqrt&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;sqrt&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver is less than zero.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
      </Message>
      <Message selector="squared" docId="5.6.2.35" refined="false">
        <Synopsis>Answer the receiver squared.</Synopsis>
        <Definition protocol="number">Answer a number that is the receiver multiplied by itself. The answer must conform to the same protocol as the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="strictlyPositive" docId="5.6.2.36" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than zero.</Synopsis>
        <Definition protocol="number">Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than zero.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="to:" docId="5.6.2.37" refined="false">
        <Synopsis>Answer an object conforming to &amp;lt;interval&amp;gt; which represents an arithmetic progression from the receiver to &lt;code&gt;stop&lt;/code&gt; in increments of 1.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer an interval which represents an arithmetic progression from the receiver to &lt;code&gt;stop&lt;/code&gt; , using the increment 1 to compute each successive element. The elements conform to the receiver's protocol. Note that &lt;code&gt;stop&lt;/code&gt; may not be the last element in the sequence, which is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver + ((stop - receiver) // 1)&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The interval answered will be empty if the receiver is greater than &lt;code&gt;stop&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Interval" />
        </ReturnValue>
      </Message>
      <Message selector="to:by:" docId="5.6.2.38" refined="false">
        <Synopsis>Answer an interval which represents an arithmetic progression from receiver to &lt;code&gt;stop&lt;/code&gt; in increments of &lt;code&gt;step&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Answer an interval which represents an arithmetic progression from the receiver to &lt;code&gt;stop&lt;/code&gt; , using the increment &lt;code&gt;step&lt;/code&gt; to compute each successive element. The value of &lt;code&gt;step&lt;/code&gt; can be positive or negative, but it must be non-zero. The elements conform to either the receiver's or &lt;code&gt;step&lt;/code&gt; 's protocol, according to the Default Conversion Table.&lt;/p&gt;&lt;p&gt; Note that &lt;code&gt;stop&lt;/code&gt; may not be the last element in the sequence, which is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;(((stop - receiver) // step) * step) + receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The interval answered will be empty if:&lt;/p&gt;&lt;p&gt; 1. receiver &amp;lt; &lt;code&gt;stop&lt;/code&gt; , and &lt;code&gt;step&lt;/code&gt; &amp;lt; 0.&lt;/p&gt;&lt;p&gt; 2. receiver &amp;gt; &lt;code&gt;stop&lt;/code&gt; , and &lt;code&gt;step&lt;/code&gt; &amp;gt; 0.&lt;/p&gt;</Definition>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="step" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Interval" />
        </ReturnValue>
        <Errors>&lt;code&gt;step&lt;/code&gt; = 0</Errors>
      </Message>
      <Message selector="to:by:do:" docId="5.6.2.39" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; for each element of an interval which represents an arithmetic progression from the receiver to &lt;code&gt;stop&lt;/code&gt; in increments of &lt;code&gt;step&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;Evaluate &lt;code&gt;operation&lt;/code&gt; for each element of an interval starting at the receiver and stopping at &lt;code&gt;stop&lt;/code&gt; where each element is &lt;code&gt;step&lt;/code&gt; greater than the previous. The value of &lt;code&gt;step&lt;/code&gt; can be positive or negative, but it must be non-zero. The elements must all conform to either the receiver's or &lt;code&gt;step&lt;/code&gt; 's protocol, according to the Default Conversion Table.&lt;/p&gt;&lt;p&gt; Note that &lt;code&gt;stop&lt;/code&gt; is not necessarily an element in the sequence, which is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;(((stop - receiver) // step) * step) + receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; No evaluation takes place if:&lt;/p&gt;&lt;p&gt; 1. receiver &amp;lt; &lt;code&gt;stop&lt;/code&gt; , and &lt;code&gt;step&lt;/code&gt; &amp;lt; 0.&lt;/p&gt;&lt;p&gt; 2. receiver &amp;gt; &lt;code&gt;stop&lt;/code&gt; , and &lt;code&gt;step&lt;/code&gt; &amp;gt; 0.&lt;/p&gt;&lt;p&gt; Implementations are not required to actually create the interval described by the receiver, &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; . Implementations may restrict the definition of this message to specific classes.&lt;/p&gt;</Definition>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="step" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="operation" aliasing="unspecified">
          <Protocol name="monadicBlock" />
        </Parameter>
        <Errors>&lt;code&gt;step&lt;/code&gt; = 0</Errors>
      </Message>
      <Message selector="to:do:" docId="5.6.2.40" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; for each element of an interval which represents an arithmetic progression from receiver to &lt;code&gt;stop&lt;/code&gt; in increments of 1.</Synopsis>
        <Definition protocol="number">&lt;p&gt;Evaluate &lt;code&gt;operation&lt;/code&gt; for each element of an interval starting at the receiver and stopping at &lt;code&gt;stop&lt;/code&gt; where each element is 1 greater than the previous. The elements must all conform to the receiver's protocol according to the Default Conversion Table.&lt;/p&gt;&lt;p&gt; Note that &lt;code&gt;stop&lt;/code&gt; may not be the last element in the sequence, which is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver + ((stop - receiver) // 1)&lt;/p&gt;&lt;p&gt;&lt;/code&gt; No evaluation takes place if the receiver is greater than &lt;code&gt;stop&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Implementations are not required to actually create the interval described by the receiver and &lt;code&gt;stop&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="operation" aliasing="unspecified">
          <Protocol name="monadicBlock" />
        </Parameter>
      </Message>
      <Message selector="truncated" docId="5.6.2.41" refined="false">
        <Synopsis>Answer an integer equal to the receiver truncated towards zero.</Synopsis>
        <Definition protocol="number">As specified by the ISO/IEC 10967 truncation operation &lt;em&gt;trunc&lt;/em&gt; . If the receiver is positive, answer the largest integer less than or equal to the receiver. If it is negative, answer the smallest integer greater than or equal to the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="truncateTo:" docId="5.6.2.42" refined="false">
        <Synopsis>Answer the number nearest the receiver truncated towards zero which is a multiple of &lt;code&gt;factor&lt;/code&gt; .</Synopsis>
        <Definition protocol="number">&lt;p&gt;If the receiver is positive, answer the largest number less than or equal to the receiver which is a multiple of &lt;code&gt;factor&lt;/code&gt; . If it is negative, answer the smallest number greater than or equal to the receiver which is a multiple of &lt;code&gt;factor&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The type of the return value depends on the type of the receiver and factor, as indicated by the Default Conversion Table.&lt;/p&gt;</Definition>
        <Parameter name="factor" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>The Default Result Type</Description>
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="rational" docId="5.6.3" abstract="true">
      <ConformsTo protocol="number" />
      <Description>Rational numbers may be either integers or fractions.  An integer is logically a fraction whose denominator is one. This protocol is necessary because some integer and most fraction operations can produce results that may be either an integer or a fraction.</Description>
      <Message selector="denominator" docId="5.6.3.1" refined="false">
        <Synopsis>Answer the denominator of the receiver.</Synopsis>
        <Definition protocol="rational">Treating the receiver as a fraction, answer the lowest common denominator of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="numerator" docId="5.6.3.2" refined="false">
        <Synopsis>Answer the numerator of the receiver.</Synopsis>
        <Definition protocol="rational">Treating the receiver as a fraction reduced to its lowest common denominator, answer the integer numerator.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Fraction" docId="5.6.4" abstract="false">
      <ConformsTo protocol="rational" />
      <Description>An exact representation for rational numbers. It is unspecific whether the rational number are maintain in a reduced form but messages that reveal the numerator and denominator answer values as if the fraction was reduced.</Description>
      <Message selector="denominator" docId="5.6.4.1" refined="true">
        <Synopsis>Answer the denominator of the receiver.</Synopsis>
        <Definition protocol="rational">Treating the receiver as a fraction, answer the lowest common denominator of the recevier.</Definition>
        <Refinement protocol="Fraction">Answer the integer smallest integer denominator of the receiver.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="numerator" docId="5.6.4.2" refined="true">
        <Synopsis>Answer the numerator of the receiver.</Synopsis>
        <Definition protocol="rational">Treating the receiver as a fraction, answer the integer numerator.</Definition>
        <Refinement protocol="Fraction">Answer the integer numerator of the receiver  reduced to  its lowest denominator.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="printString" docId="5.6.4.3" refined="true">
        <Synopsis />
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="number">Answer a string that is a valid literal representation equal to the receiver.</Refinement>
        <Refinement protocol="Fraction">&lt;p&gt;Answer a string consisting of the numerator and denominator for a reduced fraction, equivalent to the receiver. The numerator and denominator are separated by the character '/' as follows:&lt;/p&gt;&lt;p&gt; numerator/denominator&lt;/p&gt;</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="integer" docId="5.6.5" abstract="true">
      <ConformsTo protocol="rational" />
      <Description>Represents an abstraction for integer numbers whose value is exact. Representations must provide &lt;em&gt;unbounded precision&lt;/em&gt; and &lt;em&gt;range&lt;/em&gt; , hence the ISO/IEC 10967 integer type parameter &lt;em&gt;bounded&lt;/em&gt; is bound to false.</Description>
      <Message selector="allMask:" docId="5.6.5.1" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if all of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if all of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise. If the receiver has fewer bits than the operand, the receiver is treated as if it were extended on the left with zeros to the length of the operand.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or the &lt;code&gt;operand&lt;/code&gt; is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="mask" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="anyMask:" docId="5.6.5.2" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if any of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if any of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise. If the receiver has fewer bits than the operand, the receiver is treated as if it were extended on the left with zeros to the length of the operand.&lt;/p&gt;&lt;p&gt; Result is undefined if either the receiver or the operand is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="mask" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="asScaledDecimal:" docId="5.6.5.3" refined="true">
        <Synopsis>Answer a scaled decimal number, with a fractional precision of &lt;code&gt;scale&lt;/code&gt; , approximating the receiver.</Synopsis>
        <Definition protocol="number">&lt;p&gt;This is a conversion message. Answer a scaled decimal number, with a fractional precision of &lt;code&gt;scale,&lt;/code&gt; which minimizes the difference between the answered value and the receiver.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="integer">&lt;p&gt;The number of significant digits of the answer is the same as the number of decimal digits in the receiver. The scale of the answer is 0.&lt;/p&gt;&lt;p&gt; It is an error if the receiver cannot be represented within the maximum precision of the &amp;lt;scaledDecimal&amp;gt; implementation.&lt;/p&gt;</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="scaledDecimal" />
        </ReturnValue>
        <Errors>scaled decimal overflow</Errors>
      </Message>
      <Message selector="bitAnd:" docId="5.6.5.4" refined="false">
        <Synopsis>Answer the bit-wise logical and of the receiver and the &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer the result of the bit-wise logical and of the binary representation of the receiver and the binary representation of &lt;code&gt;operand&lt;/code&gt; . The shorter of the receiver or the &lt;code&gt;operand&lt;/code&gt; is extended on the left with zeros to the length of the longer of the two.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or the operand is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="bitAt:" docId="5.6.5.5" refined="false">
        <Synopsis>Answer the value of the bit at &lt;code&gt;index&lt;/code&gt; in the binary representation of the receiver.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer the value of the bit at &lt;code&gt;index&lt;/code&gt; in the binary representation of the receiver. Answer an integer value of 0 or 1, depending upon the value of the bit at position &lt;code&gt;index&lt;/code&gt; in the binary representation of the receiver. The least significant bit of the receiver is designated as bit 1, with indices increasing to the left.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver is negative. It is erroneous if &lt;code&gt;index&lt;/code&gt; is less than or equal to zero.&lt;/p&gt;</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;code&gt;index&lt;/code&gt; less than or equal to zero</Errors>
      </Message>
      <Message selector="bitAt:put:" docId="5.6.5.6" refined="false">
        <Synopsis>Set the value of the bit at &lt;code&gt;index&lt;/code&gt; in the binary representation of the receiver.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Return an integer whose binary representation is identical to the receiver with the exception that the value of the bit at position &lt;code&gt;index&lt;/code&gt; is equal to the low order bit of &lt;code&gt;value&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The least significant bit of the receiver is designated as position 1, with indices increasing to the left.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or &lt;code&gt;value&lt;/code&gt; is a negative integer. It is erroneous if &lt;code&gt;index&lt;/code&gt; is less that or equal to zero.&lt;/p&gt;</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;code&gt;index&lt;/code&gt; less than or equal to zero</Errors>
      </Message>
      <Message selector="bitOr:" docId="5.6.5.7" refined="false">
        <Synopsis>Answer the logical OR of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer the result of bit-wise logical OR the binary representation of the receiver and the binary representation of &lt;code&gt;operand&lt;/code&gt; . The shorter of the receiver or the &lt;code&gt;operand&lt;/code&gt; is extended on the left with zeros to the length of the longer of the two.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or the operand is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="bitShift:" docId="5.6.5.8" refined="false">
        <Synopsis>Answer the result of logically bit-wise shifting the binary representation of the receiver by &lt;code&gt;shift&lt;/code&gt; bits.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;If &lt;code&gt;shift&lt;/code&gt; is positive, the receiver is shifted left and zeros (0) are shifted in on the right. If &lt;code&gt;shift&lt;/code&gt; is negative, the receiver is shifted right and low order bits are discarded.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver is negative.&lt;/p&gt;</Definition>
        <Parameter name="shift" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="bitXor:" docId="5.6.5.9" refined="false">
        <Synopsis>Answer bit-wise exclusive or of the receiver and the &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer the result of the bit-wise exclusive or of the binary representation of the receiver and the binary representation of &lt;code&gt;operand&lt;/code&gt; . The shorter of the receiver or the &lt;code&gt;operand&lt;/code&gt; is extended on the left with zeros to the length of the longer of the two.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or the operand is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="even" docId="5.6.5.10" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is even.</Synopsis>
        <Definition protocol="integer">Answer &lt;em&gt;true&lt;/em&gt; if the receiver is divisible by 2 with no remainder.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="factorial" docId="5.6.5.11" refined="false">
        <Synopsis>Answer the factorial of the receiver.</Synopsis>
        <Definition protocol="integer">Answer the product of all numbers between the receiver and 1 inclusive. The result is undefined if the receiver is negative.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="gcd:" docId="5.6.5.12" refined="false">
        <Synopsis>Answer the greatest common divisor of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">Answer the largest non-negative integer that divides both the receiver and &lt;code&gt;operand&lt;/code&gt; with no remainder. Answer 0 if the receiver and &lt;code&gt;operand&lt;/code&gt; are zero.</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="highBit" docId="5.6.5.13" refined="false">
        <Synopsis>Answer the index of the most significant non-zero bit in the binary representation of the receiver.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer the index of the most significant non-zero bit in the binary representation of the receiver. Answer 0 if the receiver is 0. The index of the least significant bit of the receiver is 1, with indices increasing to the left.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver is negative.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="lcm:" docId="5.6.5.14" refined="false">
        <Synopsis>Answer the least common multiple of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">Answer the smallest non-negative integer which is evenly divided by both the receiver and &lt;code&gt;operand&lt;/code&gt; . Answer 0 if the receiver and &lt;code&gt;operand&lt;/code&gt; are zero.</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="noMask:" docId="5.6.5.15" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if none of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if none of the bits that are 1 in the binary representation of &lt;code&gt;mask&lt;/code&gt; are 1 in the binary representation of the receiver. Answer &lt;em&gt;false&lt;/em&gt; otherwise. If the receiver has fewer bits than the operand, the receiver is treated as if it were extended on the left with zeros to the length of the operand.&lt;/p&gt;&lt;p&gt; The result is undefined if either the receiver or the &lt;code&gt;operand&lt;/code&gt; is a negative integer.&lt;/p&gt;</Definition>
        <Parameter name="mask" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="odd" docId="5.6.5.16" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is odd.</Synopsis>
        <Definition protocol="integer">Answer true if the receiver is divisible by two (2) with remainder one (1).</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="printStringRadix:" docId="5.6.5.17" refined="false">
        <Synopsis>Answer a string which represents the receiver in radix &lt;code&gt;base&lt;/code&gt; .</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Return a string containing a sequence of characters that represents the numeric value of the receiver in the radix specified by the argument.  The sequence of characters must be recognizable using the radixDigits production of the Smalltalk Lexical Grammar as if the numeric&lt;/p&gt;&lt;p&gt; value of the radixSpecifier was &lt;code&gt;base.&lt;/code&gt; If the receiver is negative, a minus sign ('-') is prepended to the sequence of characters. The result is undefined if &lt;code&gt;base&lt;/code&gt; is less than two or greater than 36.&lt;/p&gt;</Definition>
        <Parameter name="base" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="printOn:base:showRadix:" docId="5.6.5.18" refined="false">
        <Synopsis>Write a sequence of characters that describes the receiver in radix &lt;code&gt;base&lt;/code&gt; with optional radix specifier.</Synopsis>
        <Definition protocol="integer">&lt;p&gt;Write to output a sequence of characters that describes the receiver, starting at output's current position. If the parameter flag is true, produce a sequence of characters that are recognizable using the radixInteger production of the Smalltalk Lexical Grammar. If the flag is false, then the sequence of characters must be recognizable using the radixDigits production as if the numeric&lt;/p&gt;&lt;p&gt; value of the radixSpecifier was &lt;code&gt;base.&lt;/code&gt; If the receiver is negative, a minus sign ('-') is prepended to the sequence of characters. The result is undefined if &lt;code&gt;base&lt;/code&gt; is less than two or greater than 36.&lt;/p&gt;</Definition>
        <Parameter name="output" aliasing="uncaptured">
          <Protocol name="puttableStream" />
        </Parameter>
        <Parameter name="base" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="flag" aliasing="uncaptured">
          <Protocol name="boolean" />
        </Parameter>
      </Message>
    </Protocol>
    <Protocol name="scaledDecimal" docId="5.6.6" abstract="true">
      <ConformsTo protocol="number" />
      <Description>Provides a numeric representation of fixed point decimal numbers. The representation must be able to accurately represent decimal fractions. The standard recommends that the implementation of this protocol support unbounded precision, with no limit to the number of digits before and after the decimal point. If a bounded implementation is provided, then any operation which exceeds the bounds has an implementation-specified  result.</Description>
      <Message selector="scale" docId="5.6.6.1" refined="false">
        <Synopsis>Answer an integer which represents the total number of digits used to represent the fraction part of the receiver, including trailing zeroes.</Synopsis>
        <Definition protocol="scaledDecimal">Answer an integer which represents the total number of digits used to represent the fraction part of the receiver, including trailing zeroes.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Float" docId="5.6.7" abstract="false">
      <ConformsTo protocol="number" />
      <Description>&lt;p&gt;Represents a floating point representation for real numbers, whose value may be approximate. Provides protocol for performing trigonometry, exponentiation, and conversion on numerical quantities.&lt;/p&gt;&lt;p&gt; Operations can produce results that are outside the set of representable numbers, or that are mathematically undefined. It is implementation defined whether errors are raised when results are not representable or if unrepresentable results are wrapped in implementation-defined continuation values or their equivalent. The effect of underflow and overflow is therefore implementation defined. It is erroneous if the result of an operation is mathematically undefined.&lt;/p&gt;</Description>
      <Message selector="=" docId="5.6.7.1" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Refinement protocol="number">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;operand&lt;/code&gt; is numerically equal to the receiver, as specified by the ISO/IEC 10967 equality operation &lt;em&gt;eq&lt;/em&gt; . Answer &lt;em&gt;false&lt;/em&gt; if they are not numerically equal or if &lt;code&gt;operand&lt;/code&gt; is not a number.&lt;/p&gt;&lt;p&gt; To perform the operation both the receiver and &lt;code&gt;operand&lt;/code&gt; must be objects with identical &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representations&lt;/em&gt; . If they have different representations a conversion to a common &lt;em&gt;numeric&lt;/em&gt; &lt;em&gt;representation&lt;/em&gt; is performed, as specified by the Default Conversion Table, before applying the operation. If the resulting protocol is &amp;lt;integer&amp;gt;, then the result value is defined by the ISO/IEC 10967 operation &lt;em&gt;eq&lt;/em&gt; . If the resulting protocol is &amp;lt;Float&amp;gt;, then the result value is defined by the ISO/IEC 10967 &lt;em&gt;eq&lt;/em&gt; . Otherwise, the result is consistent with the mathematical definition of the ISO/IEC 10967 operation &lt;em&gt;eq&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Numeric equality is defined by implementation defined conventions regarding round-off error and representation of numbers, hence behavior of this message may differ between platforms.&lt;/p&gt;</Refinement>
        <Refinement protocol="Float">Answer &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;operand&lt;/code&gt; is a number which represents the same floating point number as the receiver, as specified by the ISO/IEC 10967 operation &lt;em&gt;eq&lt;/em&gt; . If the &lt;code&gt;comparand&lt;/code&gt; and the receiver do not conform to the same protocol, they are converted according to the Default Conversion Table.</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="arcCos" docId="5.6.7.2" refined="false">
        <Synopsis>Answer the inverse cosine of the receiver in radians.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the inverse cosine of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric operation &lt;em&gt;arccos&lt;/em&gt; . Within the limits of precision, the following invariant holds:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver arcCos cos = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; It is erroneous if the absolute value of the receiver is greater than 1.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
        <Errors>|receiver|  &amp;gt; 1</Errors>
      </Message>
      <Message selector="arcSin" docId="5.6.7.3" refined="false">
        <Synopsis>Answer the inverse sine of the receiver in radians.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the inverse sine of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric operation &lt;em&gt;arcsin&lt;/em&gt; . Within the limits of precision, the following invariant holds:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver arcSin sin = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; It is erroneous if the absolute value of the receiver is greater than 1.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
        <Errors>|receiver|  &amp;gt; 1</Errors>
      </Message>
      <Message selector="arcTan" docId="5.6.7.4" refined="false">
        <Synopsis>Answer the inverse tangent of the receiver in radians.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the inverse tangent of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric operation &lt;em&gt;arctan&lt;/em&gt; . Within the limits of precision, the following invariant holds:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver arcTan tan = receiver&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="cos" docId="5.6.7.5" refined="false">
        <Synopsis>Answer the cosine of the receiver in radians.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer a &amp;lt;Float&amp;gt; equal to the cosine of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric operation &lt;em&gt;cos&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The effect of underflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="degreesToRadians" docId="5.6.7.6" refined="false">
        <Synopsis>Answer the receiver converted from degrees to radians.</Synopsis>
        <Definition protocol="Float">Answer a floating-point number representing the receiver converted from degrees to radians. The result is equivalent to multiplying the receiver by (Pi / 180).</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="exp" docId="5.6.7.7" refined="false">
        <Synopsis>Answer the natural exponential of the receiver. This is the inverse of &lt;code&gt;#ln&lt;/code&gt; .</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer a floating-point number representing the irrational number e (= 2.718281...) raised to the power of the receiver, as specified by the ISO/IEC 10967 operation &lt;em&gt;exp&lt;/em&gt; . This is the inverse of the &lt;code&gt;#ln&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="floorLog:" docId="5.6.7.8" refined="false">
        <Synopsis>Answer the largest integer less than or equal to the logarithm to the base &lt;code&gt;operand&lt;/code&gt; of the receiver.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the largest integer less than or equal to the power to which the &lt;code&gt;operand&lt;/code&gt; must be raised to obtain the receiver (that is, the logarithm base &lt;code&gt;operand&lt;/code&gt; of the receiver).&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver is less than or equal to zero, or if the &lt;code&gt;operand&lt;/code&gt; is less than or equal to 1.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="ln" docId="5.6.7.9" refined="false">
        <Synopsis>Answer the natural logarithm of the receiver.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the natural logarithm of the receiver, as specified by the ISO/IEC 10967 operation &lt;em&gt;ln&lt;/em&gt; , which is a floating-point number representing the power to which the irrational number e (= 2.718281...) must be raised to obtain the receiver. This is the inverse of the &lt;code&gt;#exp&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver is less than or equal to zero.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="log:" docId="5.6.7.10" refined="false">
        <Synopsis>Answer the logarithm to the base &lt;code&gt;operand&lt;/code&gt; of the receiver.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer the logarithm to the base &lt;code&gt;operand&lt;/code&gt; of the receiver, as specified by the ISO/IEC 10967 operation &lt;em&gt;log&lt;/em&gt; , which is a floating-point number representing the power to which &lt;code&gt;operand&lt;/code&gt; must be raised to obtain the receiver. The receiver must be positive, and &lt;code&gt;operand&lt;/code&gt; must be greater than one. This is the inverse of the &lt;code&gt;#raisedTo:&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;operand&lt;/code&gt; equals 1, if &lt;code&gt;operand&lt;/code&gt; is less than or equal to zero, or if the receiver is less than or equal to zero. The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="printString" docId="5.6.7.11" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="number">Answer a string that is a valid literal representation that approximates the numeric value of the receiver.</Refinement>
        <Refinement protocol="Float">Answer a string which is a valid Smalltalk literal representation approximately equal to the receiver. An exponent literal form is produced if the value of the exponent is greater than the precision of the receiver.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="radiansToDegrees" docId="5.6.7.12" refined="false">
        <Synopsis>Answer the receiver converted from radians to degrees.</Synopsis>
        <Definition protocol="Float">Answer a floating-point number representing the receiver converted from radians to degrees. The result is equivalent to multiplying the receiver by (180 / Pi).</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="sin" docId="5.6.7.13" refined="false">
        <Synopsis>Answer the sine of the receiver.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer a floating-point number equal to the sine of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric operation &lt;em&gt;sin&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The effect of underflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="tan" docId="5.6.7.14" refined="false">
        <Synopsis>Answer the tangent of the receiver.</Synopsis>
        <Definition protocol="Float">&lt;p&gt;Answer a floating-point number equal to the tangent of the receiver in radians, as specified by the ISO/IEC 10967 trigonometric root operation &lt;em&gt;tan&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The effect of underflow and overflow is implementation defined.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="floatCharacterization" docId="5.6.8" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>Objects supporting this protocol characterize a floating point representation for real numbers. These characterizations are required by ISO/IEC 10967 for each precision of floating point numbers provided by an implementation.</Description>
      <StandardGlobal name="Float">
        <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. The value of this global is equivalent to the value of one of the globals: &lt;code&gt;FloatE&lt;/code&gt; , &lt;code&gt;FloatE&lt;/code&gt; , or &lt;code&gt;FloatE&lt;/code&gt; .</Description>
      </StandardGlobal>
      <StandardGlobal name="FloatE">
        <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the 'e' floating point literal syntax.</Description>
      </StandardGlobal>
      <StandardGlobal name="FloatD">
        <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the 'd' floating point literal syntax.</Description>
      </StandardGlobal>
      <StandardGlobal name="FloatQ">
        <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the 'q' floating point literal syntax.</Description>
      </StandardGlobal>
      <Message selector="denormalized" docId="5.6.8.1" refined="false">
        <Synopsis>Indication of whether the characterized floating point object representation allows denormalized values.</Synopsis>
        <Definition protocol="floatCharacterization">Report a boolean indicating whether the characterized floating point object representation contains denormalized values. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;denorm&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="e" docId="5.6.8.2" refined="false">
        <Synopsis>The closest floating point approximation of the irrational number e.</Synopsis>
        <Definition protocol="floatCharacterization">Return the closest floating point approximation of the irrational number e for the characterized floating point object representation.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="emax" docId="5.6.8.3" refined="false">
        <Synopsis>The largest exponent of the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">Report the largest exponent allowed by the characterized floating point object representation, providing the upper bound of the range of representable floating point numbers. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;emax&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="emin" docId="5.6.8.4" refined="false">
        <Synopsis>The smallest exponent of the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">Report the smallest exponent allowed by the characterized floating point object representation, providing the lower bound of the range of representable floating point numbers. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;emin&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="epsilon" docId="5.6.8.5" refined="false">
        <Synopsis>The maximum relative spacing in the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">&lt;p&gt;Report the maximum relative spacing in the characterized floating point object representation, satisfying the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;epsilon&lt;/em&gt; . The return value is equal to&lt;/p&gt;&lt;p&gt; &lt;code&gt;self radix raisedTo: (1 - self precision)&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="fmax" docId="5.6.8.6" refined="false">
        <Synopsis>The largest value allowed by the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">&lt;p&gt;Report the largest value allowed by the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;fmax&lt;/em&gt; , and is equal to&lt;/p&gt;&lt;p&gt; &lt;code&gt;(1 - (self radix raisedTo: self precision negated)) * self radix raisedTo: self emax&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="fmin" docId="5.6.8.7" refined="false">
        <Synopsis>The minimum value allowed by the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">Report the minimum value allowed by the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;fmin&lt;/em&gt; . If the described representation contains normalized values, then the result is equal to the result of sending &lt;code&gt;#fminNormalized&lt;/code&gt; to the receiver, otherwise the result is equal to the result of sending &lt;code&gt;#fminDenormalized&lt;/code&gt; to the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="fminDenormalized" docId="5.6.8.8" refined="false">
        <Synopsis>The minimum denormalized value allowed by the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">&lt;p&gt;Report the minimum denormalized value allowed by the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;fmin&lt;/em&gt; , and is equal to&lt;/p&gt;&lt;p&gt; &lt;code&gt;self radix raisedTo: (self emin - self precision)&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The result is unspecified if denormalized values are not allowed by the characterized representation.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="fminNormalized" docId="5.6.8.9" refined="false">
        <Synopsis>The minimum normalized value allowed by the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">&lt;p&gt;Report the minimum normalized value allowed by the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;fmin&lt;/em&gt; , and is equal to&lt;/p&gt;&lt;p&gt; &lt;code&gt;self radix raisedTo: (self emin - 1).&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="pi" docId="5.6.8.10" refined="false">
        <Synopsis>The closest floating point approximation to Pi.</Synopsis>
        <Definition protocol="floatCharacterization">Return the closest floating point approximation to Pi for the characterized floating point object representation.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Float" />
        </ReturnValue>
      </Message>
      <Message selector="precision" docId="5.6.8.11" refined="false">
        <Synopsis>The precision of the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">Report the precision, the number of radix digits, of floating point objects of the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;p&lt;/em&gt; . The result must be greater than or equal to two.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="radix" docId="5.6.8.12" refined="false">
        <Synopsis>The radix of the characterized floating point object representation.</Synopsis>
        <Definition protocol="floatCharacterization">Report the base, or radix, of the characterized floating point object representation. This satisfies the ISO/IEC 10967 floating point characterization requirement &lt;em&gt;r.&lt;/em&gt; The result must be an even number greater than or equal to two.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Fraction factory" docId="5.6.9" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>Represents protocol for creating an exact representation for rational numbers.</Description>
      <StandardGlobal name="Fraction">
        <Description>Conforms to the protocol &amp;lt;Fraction factory&amp;gt;. Its language element type is implementation defined.</Description>
      </StandardGlobal>
      <Message selector="numerator:denominator:" docId="5.6.9.1" refined="false">
        <Synopsis>Answer a new fraction whose numerator is &lt;code&gt;top&lt;/code&gt; , and whose denominator is &lt;code&gt;bottom&lt;/code&gt; .</Synopsis>
        <Definition protocol="Fraction factory">Answer a new fraction whose numerator is &lt;code&gt;top&lt;/code&gt; , and whose denominator is &lt;code&gt;bottom&lt;/code&gt; . It is unspecified whether the result is reduced to the smallest possible denominator. If ( &lt;code&gt;top&lt;/code&gt; = &lt;code&gt;bottom)&lt;/code&gt; or ( &lt;code&gt;bottom&lt;/code&gt; = 1) the result conforms to &amp;lt;integer&amp;gt; otherwise it conforms to &amp;lt;Fraction&amp;gt;. If &lt;code&gt;bottom&lt;/code&gt; = 0 a &lt;code&gt;ZeroDivide&lt;/code&gt; exception is signaled.</Definition>
        <Parameter name="top" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="bottom" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Fraction" />
          <Description>&amp;lt;integer&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="collection" docId="5.7.1" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>&lt;p&gt;Provides protocol for manipulating and operating on a collection of objects, called &lt;em&gt;elements&lt;/em&gt; , either individually or as a whole. A collection can be fixed or variable sized, ordered or unordered, and its elements may or may not be accessible by external keys.&lt;/p&gt;&lt;p&gt; Some implementations of collections may choose to use the hash values, as defined by either the message &lt;code&gt;#hash&lt;/code&gt; or the message &lt;code&gt;#identityHash&lt;/code&gt; , of either the elements of the collection or the keys by which those elements are accessed (if there are any). If the hash values of such objects are modified, the behavior of any message sent to such a collection is undefined until the message &lt;code&gt;#rehash&lt;/code&gt; has been sent to the collection in order to restore the consistency of the collection.&lt;/p&gt;</Description>
      <Message selector="allSatisfy:" docId="5.7.1.1" refined="false">
        <Synopsis>Return &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; for every &lt;em&gt;element&lt;/em&gt; of the receiver. Otherwise return &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; for every &lt;em&gt;element&lt;/em&gt; of the receiver. Return &lt;em&gt;true&lt;/em&gt; if the receiver is empty. Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; It is unspecified whether the &lt;code&gt;discriminator&lt;/code&gt; will be evaluated with every &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for each &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="anySatisfy:" docId="5.7.1.2" refined="false">
        <Synopsis>Return &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver. Otherwise return &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver. Otherwise return &lt;em&gt;false&lt;/em&gt; . Return &lt;em&gt;false&lt;/em&gt; if the receiver is empty.&lt;/p&gt;&lt;p&gt; It is unspecified whether the &lt;code&gt;discriminator&lt;/code&gt; will be evaluated with every &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="asArray" docId="5.7.1.3" refined="false">
        <Synopsis>Answer an array whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Answer an array with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The result has the same size as the receiver, as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; If the receiver maintains an ordering for its &lt;em&gt;elements&lt;/em&gt; , the order of those &lt;em&gt;elements&lt;/em&gt; will be preserved in the result.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Array" />
        </ReturnValue>
      </Message>
      <Message selector="asBag" docId="5.7.1.4" refined="false">
        <Synopsis>Answer a bag with the same &lt;em&gt;elements&lt;/em&gt; as the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Answer a bag with the same &lt;em&gt;elements&lt;/em&gt; as the receiver.&lt;/p&gt;&lt;p&gt; The result is unspecified if the receiver contains &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Bag" />
        </ReturnValue>
      </Message>
      <Message selector="asByteArray" docId="5.7.1.5" refined="false">
        <Synopsis>Answer a byte array whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Answer a byte array with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The result has the same size as the receiver, as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; If the receiver maintains an ordering for its &lt;em&gt;elements&lt;/em&gt; , the order of those &lt;em&gt;elements&lt;/em&gt; will be preserved in the result.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any &lt;em&gt;elements&lt;/em&gt; in the receiver are not integers with values between 0 and 255.</Errors>
      </Message>
      <Message selector="asOrderedCollection" docId="5.7.1.6" refined="false">
        <Synopsis>Answer an ordered collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Answer a ordered collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The result has the same size as the receiver, as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; If the receiver maintains an ordering for its &lt;em&gt;elements&lt;/em&gt; , the order of those &lt;em&gt;elements&lt;/em&gt; will be preserved in the result.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="asSet" docId="5.7.1.7" refined="false">
        <Synopsis>Answer a set with the same &lt;em&gt;elements&lt;/em&gt; as the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Answer a set with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. Since sets do not store duplicate elements, the result may have fewer elements than the receiver.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver contains &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Set" />
        </ReturnValue>
      </Message>
      <Message selector="asSortedCollection" docId="5.7.1.8" refined="false">
        <Synopsis>Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver.</Synopsis>
        <Definition protocol="collection">Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The default sort block is used.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any &lt;em&gt;element&lt;/em&gt; of the receiver is not appropriate as a parameter to the default sort block.</Errors>
      </Message>
      <Message selector="asSortedCollection:" docId="5.7.1.9" refined="false">
        <Synopsis>Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The parameter &lt;code&gt;sortBlock&lt;/code&gt; is used as the sort block.</Synopsis>
        <Definition protocol="collection">Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The parameter &lt;code&gt;sortBlock&lt;/code&gt; is used as the sort block and must meet the requirements of a sort block as specified by &amp;lt;SortedCollection&amp;gt;.</Definition>
        <Parameter name="sortBlock" aliasing="captured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;sortBlock&lt;/code&gt; does not meet the requirements for a sort block as specified by &amp;lt;SortedCollection&amp;gt;.&lt;/p&gt;&lt;p&gt; If any &lt;em&gt;element&lt;/em&gt; of the receiver is not appropriate as a parameter to the &lt;code&gt;sortBlock&lt;/code&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="collect:" docId="5.7.1.10" refined="false">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If any &lt;em&gt;element&lt;/em&gt; of the receiver is inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the result of evaluating the &lt;code&gt;transformer&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the collection to be returned.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="detect:" docId="5.7.1.11" refined="false">
        <Synopsis>Return the first &lt;em&gt;element&lt;/em&gt; of the receiver which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; when the &lt;em&gt;element&lt;/em&gt; is used as the argument.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return the first &lt;em&gt;element&lt;/em&gt; of the receiver for which the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; when given that &lt;em&gt;element&lt;/em&gt; as an argument. The &lt;code&gt;discriminator&lt;/code&gt; will only be evaluated until such an object is found or until all of the &lt;em&gt;elements&lt;/em&gt; of the collection have been used as arguments. That is, there may be &lt;em&gt;elements&lt;/em&gt; of the receiver that are never used as arguments to the &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;discriminator&lt;/code&gt; does not evaluate to &lt;em&gt;true&lt;/em&gt; for any &lt;em&gt;element&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="detect:ifNone:" docId="5.7.1.12" refined="false">
        <Synopsis>Return the first &lt;em&gt;element&lt;/em&gt; of the receiver which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; when used as the argument to the evaluation. Answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; if no such &lt;em&gt;element&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return the first &lt;em&gt;element&lt;/em&gt; of the receiver for which the &lt;code&gt;discriminator&lt;/code&gt; evaluates to &lt;em&gt;true&lt;/em&gt; when given that &lt;em&gt;element&lt;/em&gt; as an argument. The &lt;code&gt;discriminator&lt;/code&gt; will only be evaluated until such an object is found or until all of the &lt;em&gt;elements&lt;/em&gt; of the collection have been used as arguments. That is, there may be &lt;em&gt;elements&lt;/em&gt; of the receiver that are never used as arguments to the &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; If no element causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; , answer the result of &lt;code&gt;exceptionHandler value&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Parameter name="exceptionHandler" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;Object&amp;gt; unspecified</Description>
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="do:" docId="5.7.1.13" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;operation&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter.&lt;/p&gt;&lt;p&gt; Unless specifically refined, the &lt;em&gt;elements&lt;/em&gt; are not traversed in a particular order. Each &lt;em&gt;element&lt;/em&gt; is visited exactly once. Conformant protocols may refine this message to specify a particular ordering.&lt;/p&gt;</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="do:separatedBy:" docId="5.7.1.14" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with each element of the receiver interspersed by evaluation of &lt;code&gt;separator&lt;/code&gt; .</Synopsis>
        <Definition protocol="collection">For each element of the receiver, &lt;code&gt;operation&lt;/code&gt; is evaluated with the element as the parameter. Before evaluating &lt;code&gt;operation&lt;/code&gt; the second and subsequent times evaluate &lt;code&gt;separator&lt;/code&gt; . &lt;code&gt;Separator&lt;/code&gt; is not evaluated if there are less than two elements nor after the last element.</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Parameter name="separator" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
      </Message>
      <Message selector="includes:" docId="5.7.1.15" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if an &lt;em&gt;element&lt;/em&gt; of the receiver is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="collection">This message is used to test an object for inclusion among the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer &lt;em&gt;true&lt;/em&gt; if at least one of the receiver's &lt;em&gt;elements&lt;/em&gt; is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="inject:into:" docId="5.7.1.16" refined="false">
        <Synopsis>Answer the final result of evaluating &lt;code&gt;operation&lt;/code&gt; using each &lt;em&gt;element&lt;/em&gt; of the receiver and the previous evaluation result as the parameters.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;The first evaluation of &lt;code&gt;operation&lt;/code&gt; is performed with &lt;code&gt;initialValue&lt;/code&gt; as the first parameter, and the first &lt;em&gt;element&lt;/em&gt; of the receiver as the second parameter. Subsequent evaluations are done with&lt;/p&gt;&lt;p&gt; the result of the previous evaluation as the first parameter, and the next &lt;em&gt;element&lt;/em&gt; as the second parameter. The result of the last evaluation is answered.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;</Definition>
        <Parameter name="initialValue" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="isEmpty" docId="5.7.1.17" refined="false">
        <Synopsis>Return &lt;em&gt;true&lt;/em&gt; if the receiver contains no &lt;em&gt;elements&lt;/em&gt; . Return &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return &lt;em&gt;true&lt;/em&gt; if and only if&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver size = 0&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="notEmpty" docId="5.7.1.18" refined="false">
        <Synopsis>Return &lt;em&gt;true&lt;/em&gt; if the receiver contains &lt;em&gt;elements&lt;/em&gt; . Return &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;Return true if the receiver contains elements.  Return &lt;em&gt;false&lt;/em&gt; otherwise.  This is equivalent to&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver isEmpty not&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="occurrencesOf:" docId="5.7.1.19" refined="false">
        <Synopsis>Answer the number of &lt;em&gt;elements&lt;/em&gt; of the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Synopsis>
        <Definition protocol="collection">Answer the number of &lt;em&gt;elements&lt;/em&gt; of the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="rehash" docId="5.7.1.20" refined="false">
        <Synopsis>Re-establish hash invariants, if any.</Synopsis>
        <Definition protocol="collection">Re-establish any hash invariants of the receiver.</Definition>
      </Message>
      <Message selector="reject:" docId="5.7.1.21" refined="false">
        <Synopsis>Answer a new collection which includes only the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;false&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;false&lt;/em&gt; is included in the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver. If both the receiver and the result maintain an ordering of their &lt;em&gt;elements&lt;/em&gt; , the &lt;em&gt;elements&lt;/em&gt; of the result will be in the same relative order as the &lt;em&gt;elements&lt;/em&gt; of the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="select:" docId="5.7.1.22" refined="false">
        <Synopsis>Answer a new collection which contains only the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; is included in the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the same order as they would be if the message &lt;code&gt;#do:&lt;/code&gt; had been sent to the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver. If both the receiver and the result maintain an ordering of their &lt;em&gt;elements&lt;/em&gt; , the &lt;em&gt;elements&lt;/em&gt; of the result will be in the same relative order as the &lt;em&gt;elements&lt;/em&gt; of the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the elements of the receiver are inappropriate for use as arguments to discriminator.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="size" docId="5.7.1.23" refined="false">
        <Synopsis>Answer the number of &lt;em&gt;elements&lt;/em&gt; in the receiver.</Synopsis>
        <Definition protocol="collection">Answer the number of &lt;em&gt;elements&lt;/em&gt; in the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="abstractDictionary" docId="5.7.2" abstract="true">
      <ConformsTo protocol="collection" />
      <Description>&lt;p&gt;Provides protocol for accessing, adding, removing, and iterating over the &lt;em&gt;elements&lt;/em&gt; of an unordered collection whose &lt;em&gt;elements&lt;/em&gt; are accessed using an explicitly assigned external &lt;em&gt;key&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; &lt;b&gt;Glossary Entries&lt;/b&gt;&lt;/p&gt;</Description>
      <Message selector="addAll:" docId="5.7.2.1" refined="false">
        <Synopsis>Store the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;dictionary&lt;/code&gt; in the receiver at the corresponding &lt;em&gt;keys&lt;/em&gt; from &lt;code&gt;dictionary&lt;/code&gt; .</Synopsis>
        <Definition protocol="abstractDictionary">This message is equivalent to repeatedly sending the &lt;code&gt;#at:put:&lt;/code&gt; message to the receiver with each of the &lt;em&gt;keys&lt;/em&gt; and elements in &lt;code&gt;dictionary&lt;/code&gt; in turn. If a &lt;em&gt;key&lt;/em&gt; in &lt;code&gt;dictionary&lt;/code&gt; is &lt;em&gt;key equivalent&lt;/em&gt; to a &lt;em&gt;key&lt;/em&gt; in the receiver, the associated element in &lt;code&gt;dictionary&lt;/code&gt; replaces the element in the receiver.</Definition>
        <Parameter name="dictionary" aliasing="unspecified">
          <Protocol name="abstractDictionary" />
        </Parameter>
      </Message>
      <Message selector="at:" docId="5.7.2.2" refined="false">
        <Synopsis>Answer the &lt;em&gt;element&lt;/em&gt; at &lt;code&gt;&lt;em&gt;key&lt;/em&gt;&lt;/code&gt; in the receiver.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;This message defines &lt;em&gt;element&lt;/em&gt; lookup based on a &lt;code&gt;key&lt;/code&gt; . Answer the &lt;em&gt;element&lt;/em&gt; stored at &lt;code&gt;key&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Lookup is successful if an &lt;em&gt;element&lt;/em&gt; has been previously stored in the receiver at a &lt;em&gt;key&lt;/em&gt; that is &lt;em&gt;key&lt;/em&gt; &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;key&lt;/code&gt; . This element is answered. Specifically, the following expression must return &lt;em&gt;true&lt;/em&gt; for all appropriate bindings of &lt;code&gt;dictionary&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; , and &lt;code&gt;value&lt;/code&gt; :&lt;/p&gt;&lt;p&gt; &lt;code&gt;dictionary at: key put: value. ^(dictionary at: key) == value&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The result is undefined if the receiver does not contain an &lt;em&gt;element&lt;/em&gt; keyed by &lt;code&gt;key&lt;/code&gt; or if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="at:ifAbsent:" docId="5.7.2.3" refined="false">
        <Synopsis>Answer the &lt;em&gt;element&lt;/em&gt; at &lt;code&gt;key&lt;/code&gt; in the receiver. If key lookup for &lt;code&gt;key&lt;/code&gt; fails, then answer the result of evaluating &lt;code&gt;operation&lt;/code&gt; .</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;Answer the &lt;em&gt;element&lt;/em&gt; stored at the specified &lt;code&gt;key&lt;/code&gt; if &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; is successful. If the &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; fails, answer the result of evaluating &lt;code&gt;operation&lt;/code&gt; with no parameters.&lt;/p&gt;&lt;p&gt; The result is undefined if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;ANY&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="at:ifAbsentPut:" docId="5.7.2.4" refined="false">
        <Synopsis>Answer the &lt;em&gt;element&lt;/em&gt; at &lt;code&gt;key&lt;/code&gt; in the receiver. If &lt;em&gt;key&lt;/em&gt;  &lt;em&gt;lookup&lt;/em&gt; for &lt;code&gt;key&lt;/code&gt; fails, then store and return the result of evaluating &lt;code&gt;operation&lt;/code&gt; .</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;This message is the same as the &lt;code&gt;#at:&lt;/code&gt; message if &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; is successful. If the &lt;em&gt;key lookup&lt;/em&gt; fails, the result of evaluating &lt;code&gt;operation&lt;/code&gt; with no parameters is added at &lt;code&gt;key&lt;/code&gt; and answered.&lt;/p&gt;&lt;p&gt; The result is undefined  if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="unspecified">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="at:put:" docId="5.7.2.5" refined="false">
        <Synopsis>Store &lt;code&gt;newElement&lt;/code&gt; at &lt;code&gt;key&lt;/code&gt; in the receiver. Answer &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;If lookup succeeds for &lt;code&gt;key&lt;/code&gt; , then &lt;code&gt;newElement&lt;/code&gt; replaces the &lt;em&gt;element&lt;/em&gt; previously stored at &lt;code&gt;key&lt;/code&gt; . Otherwise, the &lt;code&gt;newElement&lt;/code&gt; is stored at the new &lt;code&gt;key&lt;/code&gt; . In either case, subsequent successful lookups for &lt;code&gt;key&lt;/code&gt; will answer &lt;code&gt;newElement&lt;/code&gt; .  Answer &lt;code&gt;newElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="unspecified">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="collect:" docId="5.7.2.6" refined="true">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="abstractDictionary">Answer a new instance of the receiver's type with the same &lt;em&gt;keys&lt;/em&gt; . For each &lt;em&gt;key&lt;/em&gt; of the answer, a new element is obtained by evaluating &lt;code&gt;transformer&lt;/code&gt; with the corresponding element of the receiver as the parameter.</Refinement>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the result of evaluating the &lt;code&gt;transformer&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the collection to be returned.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="includesKey:" docId="5.7.2.7" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver contains an &lt;em&gt;element&lt;/em&gt; stored at &lt;code&gt;key&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; for the &lt;code&gt;key&lt;/code&gt; succeeds. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; The result is undefined if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="keyAtValue:" docId="5.7.2.8" refined="false">
        <Synopsis>Answer a &lt;em&gt;key&lt;/em&gt; such that the &lt;em&gt;element&lt;/em&gt; stored at this &lt;em&gt;key&lt;/em&gt; is equal to &lt;code&gt;value&lt;/code&gt; . Answer &lt;em&gt;nil&lt;/em&gt; if no such &lt;em&gt;key&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;Answer an object such that &lt;em&gt;key lookup&lt;/em&gt; with this object will answer an &lt;em&gt;element&lt;/em&gt; in the receiver &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; . Note that if there are multiple &lt;em&gt;elements&lt;/em&gt; in the receiver that are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; , then the one whose &lt;em&gt;key&lt;/em&gt; is answered is arbitrary.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver does not contain an &lt;em&gt;element&lt;/em&gt; &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="value" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="keyAtValue:ifAbsent:" docId="5.7.2.9" refined="false">
        <Synopsis>Answer a &lt;em&gt;key&lt;/em&gt; such that the element stored at this &lt;em&gt;key&lt;/em&gt; is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; . Answer the result of evaluating &lt;code&gt;operation&lt;/code&gt; if no such &lt;em&gt;key&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;Answer an object such that &lt;em&gt;key lookup&lt;/em&gt; with this object will answer an &lt;em&gt;element&lt;/em&gt; in the receiver &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; . If no &lt;em&gt;element&lt;/em&gt; &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;value&lt;/code&gt; is found, then the result of evaluating&lt;/p&gt;&lt;p&gt; &lt;code&gt;operation&lt;/code&gt; with no parameters is answered.&lt;/p&gt;</Definition>
        <Parameter name="value" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;ANY&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="keys" docId="5.7.2.10" refined="false">
        <Synopsis>Answer a collection of &lt;em&gt;keys&lt;/em&gt; at which there is an &lt;em&gt;element&lt;/em&gt; stored in the receiver.</Synopsis>
        <Definition protocol="abstractDictionary">Answer a collection of all the &lt;em&gt;keys&lt;/em&gt; in the receiver.  The size of the result is equal to the size of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="collection" />
        </ReturnValue>
      </Message>
      <Message selector="keysAndValuesDo:" docId="5.7.2.11" refined="false">
        <Synopsis>Iteratively evaluate &lt;code&gt;operation&lt;/code&gt; with each of the receiver's &lt;em&gt;keys&lt;/em&gt; and values.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; in the receiver, &lt;code&gt;operation&lt;/code&gt; is evaluated with the corresponding &lt;em&gt;key&lt;/em&gt; as the first argument and the &lt;em&gt;element&lt;/em&gt; as the second argument.&lt;/p&gt;&lt;p&gt; The order in which the &lt;em&gt;elements&lt;/em&gt; are traversed is not specified. Each &lt;em&gt;key&lt;/em&gt; is visited exactly once.&lt;/p&gt;</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <Errors>If any of the &lt;em&gt;keys&lt;/em&gt; or values are not appropriate as an argument to operation.</Errors>
      </Message>
      <Message selector="keysDo:" docId="5.7.2.12" refined="true">
        <Synopsis>Iteratively evaluate &lt;code&gt;operation&lt;/code&gt; with each of the receiver's &lt;em&gt;keys&lt;/em&gt; at which there are &lt;em&gt;elements&lt;/em&gt; stored.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;For each &lt;em&gt;key&lt;/em&gt; in the receiver, &lt;code&gt;operation&lt;/code&gt; is evaluated with the &lt;em&gt;key&lt;/em&gt; used as the parameter.&lt;/p&gt;&lt;p&gt; The order in which the &lt;em&gt;elements&lt;/em&gt; are traversed is not specified. Each &lt;em&gt;key&lt;/em&gt; is visited exactly once.&lt;/p&gt;</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>If any of the &lt;em&gt;keys&lt;/em&gt; are not appropriate as an argument to operation.</Errors>
      </Message>
      <Message selector="reject:" docId="5.7.2.13" refined="true">
        <Synopsis>Answer a new collection which excludes the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;false&lt;/em&gt; is added to the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="abstractDictionary">For each &lt;em&gt;key&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the corresponding &lt;em&gt;element&lt;/em&gt; as the parameter. If the &lt;em&gt;element&lt;/em&gt; causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;false&lt;/em&gt; , the &lt;em&gt;key&lt;/em&gt; is added to the answer with the &lt;em&gt;element&lt;/em&gt; as its corresponding value.</Refinement>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="removeAllKeys:" docId="5.7.2.14" refined="false">
        <Synopsis>Remove any &lt;em&gt;elements&lt;/em&gt; from the receiver which are stored at the &lt;em&gt;keys&lt;/em&gt; specified in &lt;code&gt;keys&lt;/code&gt; .</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;This message has the same effect on the receiver as repeatedly sending the &lt;code&gt;#removeKey:&lt;/code&gt; message for each &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;keys&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if duplicate &lt;em&gt;keys,&lt;/em&gt; as defined by &lt;em&gt;key equivalence&lt;/em&gt; , are in the &lt;code&gt;keys&lt;/code&gt; or if any &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;keys&lt;/code&gt; is not a valid &lt;em&gt;key&lt;/em&gt; of the receiver.&lt;/p&gt;</Definition>
        <Parameter name="keys" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
      </Message>
      <Message selector="removeAllKeys:ifAbsent:" docId="5.7.2.15" refined="false">
        <Synopsis>Remove any &lt;em&gt;elements&lt;/em&gt; from the receiver which are stored at the &lt;em&gt;keys&lt;/em&gt; specified in &lt;code&gt;keys&lt;/code&gt; . For any &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;keys&lt;/code&gt; which is not a valid &lt;em&gt;key&lt;/em&gt; of the receiver, evaluate &lt;code&gt;operation&lt;/code&gt; with that &lt;em&gt;element&lt;/em&gt; as the argument, but do not stop the enumeration.</Synopsis>
        <Definition protocol="abstractDictionary">This message has the same effect on the receiver as repeatedly sending the &lt;code&gt;#removeKey:ifAbsent:&lt;/code&gt; message for each &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;keys&lt;/code&gt; . If any &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;keys&lt;/code&gt; is not a valid &lt;em&gt;key&lt;/em&gt; of the receiver, evaluate &lt;code&gt;operation&lt;/code&gt; with that &lt;em&gt;element&lt;/em&gt; as the parameter and continue the enumeration.</Definition>
        <Parameter name="keys" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>If any &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;keys&lt;/code&gt; is not a valid &lt;em&gt;key&lt;/em&gt; of the receiver and inappropriate for use as an argument to the &lt;code&gt;operation&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="removeKey:" docId="5.7.2.16" refined="false">
        <Synopsis>Remove the &lt;em&gt;element&lt;/em&gt; which is stored at &lt;code&gt;key&lt;/code&gt; in the receiver. Answer the removed element.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;This message defines removal of a &lt;em&gt;key&lt;/em&gt; from the receiver. If &lt;em&gt;key lookup&lt;/em&gt; for &lt;code&gt;key&lt;/code&gt; is successful, then both &lt;code&gt;key&lt;/code&gt; and its corresponding &lt;em&gt;element&lt;/em&gt; are removed. Answer the removed &lt;em&gt;element&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver does not contain an &lt;em&gt;element&lt;/em&gt; keyed by &lt;code&gt;key&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="removeKey:ifAbsent:" docId="5.7.2.17" refined="false">
        <Synopsis>Remove the &lt;em&gt;element&lt;/em&gt; which is stored at &lt;code&gt;key&lt;/code&gt; in the receiver and answer the removed &lt;em&gt;element&lt;/em&gt; . Answer the result of evaluating &lt;code&gt;operation&lt;/code&gt; if no such &lt;em&gt;key&lt;/em&gt; is found in the receiver.</Synopsis>
        <Definition protocol="abstractDictionary">&lt;p&gt;If &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; for &lt;code&gt;key&lt;/code&gt; is successful, then both &lt;code&gt;key&lt;/code&gt; and its corresponding &lt;em&gt;element&lt;/em&gt; are removed. Answer the removed &lt;em&gt;element&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;key&lt;/em&gt; &lt;em&gt;lookup&lt;/em&gt; fails, the result of evaluating &lt;code&gt;operation&lt;/code&gt; with no parameters is answered.&lt;/p&gt;&lt;p&gt; The result is undefined if the &lt;code&gt;key&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="key" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;ANY&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="select:" docId="5.7.2.18" refined="true">
        <Synopsis>Answer a new collection which contains the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; is added to the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="abstractDictionary">&lt;p&gt;For each &lt;em&gt;key&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. If &lt;em&gt;element&lt;/em&gt; causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; , the &lt;em&gt;key&lt;/em&gt; is added to the answer with value element.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Refinement>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>If the elements of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="values" docId="5.7.2.19" refined="false">
        <Synopsis>Answer a collection of the receiver's &lt;em&gt;elements.&lt;/em&gt;</Synopsis>
        <Definition protocol="abstractDictionary">Answer a collection of the receiver's &lt;em&gt;elements.&lt;/em&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Dictionary" docId="5.7.3" abstract="false">
      <ConformsTo protocol="abstractDictionary" />
      <Description>Represents an unordered collection whose &lt;em&gt;elements&lt;/em&gt; can be accessed using an explicitly assigned external &lt;em&gt;key&lt;/em&gt; . &lt;em&gt;Key equivalence&lt;/em&gt; is defined as sending the &lt;code&gt;#=&lt;/code&gt; message.</Description>
    </Protocol>
    <Protocol name="IdentityDictionary" docId="5.7.4" abstract="false">
      <ConformsTo protocol="abstractDictionary" />
      <Description>This protocol defines the behavior of unordered collections whose &lt;em&gt;elements&lt;/em&gt; can be accessed using an explicitly-assigned, external &lt;em&gt;key&lt;/em&gt; . &lt;em&gt;Key equivalence&lt;/em&gt; is defined as sending the &lt;code&gt;#==&lt;/code&gt; message.</Description>
    </Protocol>
    <Protocol name="extensibleCollection" docId="5.7.5" abstract="true">
      <ConformsTo protocol="collection" />
      <Description>Provides protocol for adding &lt;em&gt;elements&lt;/em&gt; to and removing &lt;em&gt;elements&lt;/em&gt; from a variable sized collection.</Description>
      <Message selector="add:" docId="5.7.5.1" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds a &lt;code&gt;newElement&lt;/code&gt; to the receiver. Unless specifically refined, the position of the &lt;code&gt;newElement&lt;/code&gt; in the &lt;em&gt;element&lt;/em&gt; traversal order is unspecified.&lt;/p&gt;&lt;p&gt; Conformant protocols may place restrictions on the type of objects that are valid &lt;em&gt;elements&lt;/em&gt; . Unless otherwise specified, any object is acceptable.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
      <Message selector="addAll:" docId="5.7.5.2" refined="false">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver.&lt;/p&gt;&lt;p&gt; The operation is equivalent to adding each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver using the &lt;code&gt;#add:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter. The &lt;code&gt;newElements&lt;/code&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
      </Message>
      <Message selector="remove:" docId="5.7.5.3" refined="false">
        <Synopsis>Remove the first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; and return the removed &lt;em&gt;element&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;Remove the first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; and return the removed &lt;em&gt;element&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are tested in the same order in which they would be enumerated by the message &lt;code&gt;#do:&lt;/code&gt; for this receiver.&lt;/p&gt;&lt;p&gt; The behavior is undefined if an object &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; is not found.&lt;/p&gt;</Definition>
        <Parameter name="oldElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="remove:ifAbsent:" docId="5.7.5.4" refined="false">
        <Synopsis>Remove the first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; . If it is not found, answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;The first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; is removed from the receiver's &lt;em&gt;elements&lt;/em&gt; . If no such &lt;em&gt;element&lt;/em&gt; is found, answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; with no parameters.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are tested in the same order in which they would be enumerated by the message &lt;code&gt;#do:&lt;/code&gt; for this receiver.&lt;/p&gt;</Definition>
        <Parameter name="oldElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="exceptionHandler" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;Object&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="removeAll:" docId="5.7.5.5" refined="false">
        <Synopsis>For each &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;oldElements&lt;/code&gt; , remove the first &lt;em&gt;element&lt;/em&gt; from the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to this &lt;em&gt;element&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message is used to remove each &lt;em&gt;element&lt;/em&gt; of a given collection from the receiver's &lt;em&gt;elements&lt;/em&gt; . The operation is defined to be equivalent to removing each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;oldElements&lt;/code&gt; from the receiver using the &lt;code&gt;#remove:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter.&lt;/p&gt;&lt;p&gt; The behavior is undefined if any &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;oldElements&lt;/code&gt; is not found.&lt;/p&gt;</Definition>
        <Parameter name="oldElements" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>&lt;p&gt;&lt;b&gt;Errors:&lt;/b&gt;&lt;/p&gt;&lt;p&gt; none&lt;/p&gt;</Description>
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Bag" docId="5.7.6" abstract="false">
      <ConformsTo protocol="extensibleCollection" />
      <Description>Represents an unordered, variable sized collection whose &lt;em&gt;elements&lt;/em&gt; can be added or removed, but cannot be individually accessed by external &lt;em&gt;keys&lt;/em&gt; . A bag is similar to a set but can contain duplicate &lt;em&gt;elements&lt;/em&gt; . &lt;em&gt;Elements&lt;/em&gt; are duplicates if they are &lt;em&gt;equivalent&lt;/em&gt; .</Description>
      <Message selector="add:" docId="5.7.6.1" refined="true">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds a &lt;code&gt;newElement&lt;/code&gt; to the receiver. Unless specifically refined, the position of the &lt;code&gt;newElement&lt;/code&gt; in the &lt;em&gt;element&lt;/em&gt; traversal order is unspecified.&lt;/p&gt;&lt;p&gt; Conformant protocols may place restrictions on the type of objects that are valid &lt;em&gt;elements&lt;/em&gt; . Unless otherwise specified, any object is acceptable.&lt;/p&gt;</Definition>
        <Refinement protocol="Bag">The result is undefined if &lt;code&gt;newElement&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
      <Message selector="add:withOccurrences:" docId="5.7.6.2" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt;  &lt;code&gt;count&lt;/code&gt; times to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="Bag">&lt;p&gt;This message adds an &lt;em&gt;element&lt;/em&gt; to the receiver multiple times. The operation is equivalent to adding &lt;code&gt;newElement&lt;/code&gt; to the receiver &lt;code&gt;count&lt;/code&gt; times using the &lt;code&gt;#add:&lt;/code&gt; message with &lt;code&gt;newElement&lt;/code&gt; as the parameter.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;newElement&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
      </Message>
      <Message selector="addAll:" docId="5.7.6.3" refined="true">
        <Synopsis>Add each element of &lt;code&gt;newElements&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver.&lt;/p&gt;&lt;p&gt; The operation is equivalent to adding each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver using the &lt;code&gt;#add:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter. The &lt;code&gt;newElements&lt;/code&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag">&lt;p&gt;The result is undefined if &lt;code&gt;newElements&lt;/code&gt; contains &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The traversal order is unspecified.&lt;/p&gt;</Refinement>
        <Parameter name="newElements" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
      </Message>
      <Message selector="collect:" docId="5.7.6.4" refined="true">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an objects conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Bag">The result is undefined if &lt;code&gt;transformer&lt;/code&gt; evaluates to &lt;em&gt;nil&lt;/em&gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.</Refinement>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the result of evaluating the &lt;code&gt;transformer&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the collection to be returned.&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="Set" docId="5.7.7" abstract="false">
      <ConformsTo protocol="extensibleCollection" />
      <Description>Represents an unordered, variable sized collection whose &lt;em&gt;elements&lt;/em&gt; can be added or removed, but cannot be individually accessed by external &lt;em&gt;keys&lt;/em&gt; . A set is similar to a bag but cannot contain duplicate &lt;em&gt;elements&lt;/em&gt; .</Description>
      <Message selector="add:" docId="5.7.7.1" refined="true">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds a &lt;code&gt;newElement&lt;/code&gt; to the receiver. Unless specifically refined, the position of the &lt;code&gt;newElement&lt;/code&gt; in the &lt;em&gt;element&lt;/em&gt; traversal order is unspecified.&lt;/p&gt;&lt;p&gt; Conformant protocols may place restrictions on the type of objects that are valid &lt;em&gt;elements&lt;/em&gt; . Unless otherwise specified, any object is acceptable.&lt;/p&gt;</Definition>
        <Refinement protocol="Set">&lt;p&gt;Since sets may not contain duplicates, if there is already an &lt;em&gt;element&lt;/em&gt; in the receiver that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;newElement&lt;/code&gt; , this operation has no effect.&lt;/p&gt;&lt;p&gt; The results are undefined if &lt;code&gt;newElement&lt;/code&gt; is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The equivalence of &lt;code&gt;newElement&lt;/code&gt; with respect to other objects should not be changed while &lt;code&gt;newElement&lt;/code&gt; is in the collection, as this would violate the invariant under which the element was placed within the collection.&lt;/p&gt;</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
      <Message selector="addAll:" docId="5.7.7.2" refined="true">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver.&lt;/p&gt;&lt;p&gt; The operation is equivalent to adding each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver using the &lt;code&gt;#add:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter. The &lt;code&gt;newElements&lt;/code&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set">&lt;p&gt;Duplicates will not be added.&lt;/p&gt;&lt;p&gt; The results are undefined if &lt;code&gt;newElements&lt;/code&gt; contains &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
      </Message>
      <Message selector="collect:" docId="5.7.7.3" refined="true">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an objects conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Set">&lt;p&gt;Duplicates will not be added.&lt;/p&gt;&lt;p&gt; The results are undefined if &lt;code&gt;newElements&lt;/code&gt; contains &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the result of evaluating the &lt;code&gt;transformer&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the collection to be returned.&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="sequencedReadableCollection" docId="5.7.8" abstract="true">
      <ConformsTo protocol="collection" />
      <Description>Provides protocol for reading an ordered collection of objects whose &lt;em&gt;elements&lt;/em&gt; can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; . The &lt;em&gt;keys&lt;/em&gt; are between one (1) and the number of &lt;em&gt;elements&lt;/em&gt; in the collection, inclusive.</Description>
      <Message selector="," docId="5.7.8.1" refined="false">
        <Synopsis>Answer a new collection which is the concatenation of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing all of the receiver's &lt;em&gt;elements&lt;/em&gt; in their original order followed by all of the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; , in their original order. The size of the new collection is equal to the sum of the sizes of the receiver and &lt;code&gt;operand&lt;/code&gt; , as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; are not suitable for storage in instances of the receiver's class.</Errors>
      </Message>
      <Message selector="=" docId="5.7.8.2" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Answer &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise answer &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conformant protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash value&lt;/em&gt; s. Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. However, only objects whose implementation of &lt;code&gt;#=&lt;/code&gt; is &lt;em&gt;temporally invariant&lt;/em&gt; can be reliably stored within collections that use &lt;code&gt;#=&lt;/code&gt; to discriminate objects.&lt;/p&gt;</Definition>
        <Refinement protocol="sequencedReadableCollection">&lt;p&gt;Unless specifically refined, the receiver and &lt;code&gt;operand&lt;/code&gt; are &lt;em&gt;equivalent&lt;/em&gt; if all of the following are true:&lt;/p&gt;&lt;p&gt; 1. The receiver and &lt;code&gt;operand&lt;/code&gt; are instances of the same class.&lt;/p&gt;&lt;p&gt; 2. They answer the same value for the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; 3. For all indices of the receiver, the &lt;em&gt;element&lt;/em&gt; in the receiver at a given index is &lt;em&gt;equivalent&lt;/em&gt; to the &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;operand&lt;/code&gt; at the same index.&lt;/p&gt;&lt;p&gt; &lt;em&gt;Element&lt;/em&gt; lookup is defined by the &lt;code&gt;#at:&lt;/code&gt; message for the receiver and &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="after:" docId="5.7.8.3" refined="false">
        <Synopsis>Answer the object immediately following the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; in the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer the object immediately following the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; in the receiver. An &lt;em&gt;element&lt;/em&gt; immediately follows another if its index is one greater than that of the other. The order used to determine which of the receiver's &lt;em&gt;elements&lt;/em&gt; is the first to be &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; is the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for the receiver.&lt;/p&gt;&lt;p&gt; It is an error if the first occurrence of &lt;code&gt;target&lt;/code&gt; is the last &lt;em&gt;element&lt;/em&gt; of the receiver, or if the receiver does not include &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;element&lt;/em&gt; which is equal to &lt;code&gt;target&lt;/code&gt; is the last &lt;em&gt;element&lt;/em&gt; in the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="at:" docId="5.7.8.4" refined="false">
        <Synopsis>Answer the &lt;em&gt;element&lt;/em&gt; at the position &lt;code&gt;index&lt;/code&gt; in the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">This message defines &lt;em&gt;element&lt;/em&gt; retrieval based on an index. Answer the &lt;em&gt;element&lt;/em&gt; at the specified &lt;code&gt;index&lt;/code&gt; . The result is undefined if the receiver has no &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; .</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; is &amp;lt;= 0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; is greater than the receiver's size.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="at:ifAbsent:" docId="5.7.8.5" refined="false">
        <Synopsis>Answer the &lt;em&gt;element&lt;/em&gt; at the position &lt;code&gt;index&lt;/code&gt; in the receiver.  If there is no position corresponding to &lt;code&gt;index&lt;/code&gt; in the receiver, then answer the result of evaluating &lt;code&gt;exceptionBlock&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">This message defines &lt;em&gt;element&lt;/em&gt; retrieval based on an index. Answer the &lt;em&gt;element&lt;/em&gt; at the specified &lt;code&gt;index&lt;/code&gt; .  If there is no position corresponding to &lt;code&gt;index&lt;/code&gt; in the receiver, then answer the result of evaluating &lt;code&gt;exceptionBlock&lt;/code&gt; .</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="exceptionBlock" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
          <Description>&amp;lt;ANY&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="before:" docId="5.7.8.6" refined="false">
        <Synopsis>Answer the object immediately preceding the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; in the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer the object immediately preceding the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; in the receiver. An &lt;em&gt;element&lt;/em&gt; immediately precedes another if its index is one less than that of the other.&lt;/p&gt;&lt;p&gt; It is an error if &lt;code&gt;target&lt;/code&gt; is the first &lt;em&gt;element&lt;/em&gt; of the receiver, or if the receiver does not include &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;element&lt;/em&gt; which is equal to &lt;code&gt;target&lt;/code&gt; is the first &lt;em&gt;element&lt;/em&gt; in the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyFrom:to:" docId="5.7.8.7" refined="false">
        <Synopsis>Answer a new collection containing all of the &lt;em&gt;elements&lt;/em&gt; of the receiver between the indices &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive. If &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; , the result has a size of zero.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing the specified range of &lt;em&gt;elements&lt;/em&gt; of the receiver in their original order. The &lt;em&gt;element&lt;/em&gt; at index &lt;code&gt;start&lt;/code&gt; in the receiver is at index 1 in the new collection; the &lt;em&gt;element&lt;/em&gt; at index &lt;code&gt;start&lt;/code&gt; +1 is at index 2, etc. If &lt;code&gt;stop&lt;/code&gt; is less than &lt;code&gt;start&lt;/code&gt; , then the new collection is empty. Otherwise, the size of the new collection is the maximum of ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) and 0.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive..&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;stop&lt;/code&gt; &amp;gt;= &lt;code&gt;start&lt;/code&gt; and ( &lt;code&gt;start&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size).&lt;/p&gt;&lt;p&gt; If &lt;code&gt;stop&lt;/code&gt; &amp;gt;= &lt;code&gt;start&lt;/code&gt; and ( &lt;code&gt;stop&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;stop&lt;/code&gt; &amp;gt; the receiver's size).&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceAll:with:" docId="5.7.8.8" refined="false">
        <Synopsis>Answer a new collection in which all subsequences of &lt;em&gt;elements&lt;/em&gt; in the receiver matching &lt;code&gt;targetElements&lt;/code&gt; are replaced in the new collection by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver in their original order, except where a subsequence in the receiver matches &lt;code&gt;targetElements&lt;/code&gt; . A subsequence in the receiver is said to match the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;targetElements&lt;/code&gt; if:&lt;/p&gt;&lt;p&gt; 1. They have the same number of &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; 2. For all indices of the subsequence, the &lt;em&gt;element&lt;/em&gt; in the subsequence at a given index is &lt;em&gt;equivalent&lt;/em&gt; to the &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;targetElements&lt;/code&gt; at the same index.&lt;/p&gt;&lt;p&gt; Starting with the first &lt;em&gt;element&lt;/em&gt; of the receiver and proceeding through ascending &lt;em&gt;elements&lt;/em&gt; , each non-overlapping subsequence of the receiver matching &lt;code&gt;targetElements&lt;/code&gt; is detected.  The result is a copy of the receiver with each detected subsequence replaced by the sequence of &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="targetElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>If any of the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of instances of the receiver's class.</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:with:" docId="5.7.8.9" refined="false">
        <Synopsis>Answer a new collection, containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver, but with the &lt;em&gt;elements&lt;/em&gt; in the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive replaced by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. The size of &lt;code&gt;replacementElements&lt;/code&gt; (as defined by &lt;code&gt;#size)&lt;/code&gt; need not be the same as the number of &lt;em&gt;elements&lt;/em&gt; being replaced. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then the &lt;code&gt;replacementElements&lt;/code&gt; are inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and the &lt;code&gt;replacementElements&lt;/code&gt; are placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range are replaced by the &lt;em&gt;elements&lt;/em&gt; from &lt;code&gt;replacementElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; In all cases, the resulting collection consists of the receiver's &lt;em&gt;elements&lt;/em&gt; from indices 1 to &lt;code&gt;start&lt;/code&gt; - 1 in their original order, followed by the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; , followed by the remainder of the receiver's &lt;em&gt;elements&lt;/em&gt; from index &lt;code&gt;stop&lt;/code&gt; + 1 in their original order. The size of the result is the receiver's size - ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) + the &lt;code&gt;replacementElements&lt;/code&gt; size.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;The &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; are not suitable for storage in instances of the receiver's class.&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; receiver's size + 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; - 1&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:withObject:" docId="5.7.8.10" refined="false">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which the &lt;em&gt;elements&lt;/em&gt; of the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive have been replaced with &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then &lt;code&gt;replacementElement&lt;/code&gt; is inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and &lt;code&gt;replacementElement&lt;/code&gt; is placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and each of the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range is replaced by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be non-negative.&lt;/p&gt;&lt;p&gt; Collections that by definition enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>&lt;p&gt;The &lt;code&gt;replacementElement&lt;/code&gt; is not suitable for storage in instances of the receiver's class.&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; receiver's size + 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; - 1&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplacing:withObject:" docId="5.7.8.11" refined="false">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which any occurrences of &lt;code&gt;targetElement&lt;/code&gt; are replaced by &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;A new collection is created and initialized with the same &lt;em&gt;elements&lt;/em&gt; as the receiver in the same order, except that any objects in the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;targetElement&lt;/code&gt; are replaced in the new collection by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="targetElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
        <Errors>If the &lt;code&gt;replacementElement&lt;/code&gt; is inappropriate for storage in instances of the receiver's class.</Errors>
      </Message>
      <Message selector="copyWith:" docId="5.7.8.12" refined="false">
        <Synopsis>Answer a new collection containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver, with &lt;code&gt;newElement&lt;/code&gt; added.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with size one greater than the size of the receiver containing the &lt;em&gt;elements&lt;/em&gt; of the receiver and &lt;code&gt;newElement&lt;/code&gt; placed at the end.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="copyWithout:" docId="5.7.8.13" refined="true">
        <Synopsis>Answer a new collection, containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver in their original order omitting any &lt;em&gt;elements&lt;/em&gt;  &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">Answer a new collection with all of the &lt;em&gt;elements&lt;/em&gt; of the receiver that are not &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; , in their original order.</Definition>
        <Parameter name="oldElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="do:" docId="5.7.8.14" refined="true">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;operation&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter.&lt;/p&gt;&lt;p&gt; Unless specifically refined, the &lt;em&gt;elements&lt;/em&gt; are not traversed in a particular order. Each &lt;em&gt;element&lt;/em&gt; is visited exactly once. Conformant protocols may refine this message to specify a particular ordering.&lt;/p&gt;</Definition>
        <Refinement protocol="sequencedReadableCollection">The &lt;code&gt;operation&lt;/code&gt; is evaluated with each &lt;em&gt;element&lt;/em&gt; of the receiver in indexed order starting at 1. The first &lt;em&gt;element&lt;/em&gt; is at index 1, the second at index 2, etc. The index of the last &lt;em&gt;element&lt;/em&gt; is equal to the receiver's size.</Refinement>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="findFirst:" docId="5.7.8.15" refined="false">
        <Synopsis>Answer the index of the first &lt;em&gt;element&lt;/em&gt; of the receiver which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; when the &lt;em&gt;element&lt;/em&gt; is used as the parameter. Answer zero (0) if no such &lt;em&gt;element&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Answer the index of the first &lt;em&gt;element&lt;/em&gt; which results in an evaluation of &lt;em&gt;true&lt;/em&gt; ; no further &lt;em&gt;elements&lt;/em&gt; are considered. If no such &lt;em&gt;element&lt;/em&gt; exists in the receiver, answer 0.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;p&gt;If an evaluation of &lt;code&gt;discriminator&lt;/code&gt; results in an object that does not conform to &amp;lt;boolean&amp;gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="findLast:" docId="5.7.8.16" refined="false">
        <Synopsis>Answer the index of the last &lt;em&gt;element&lt;/em&gt; of the receiver which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; when the &lt;em&gt;element&lt;/em&gt; is used as the parameter. Answer zero (0) if no such &lt;em&gt;element&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, in reverse order starting with the last, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Answer the index of the first &lt;em&gt;element&lt;/em&gt; which results in an evaluation of &lt;em&gt;true&lt;/em&gt; ; no further &lt;em&gt;elements&lt;/em&gt; are considered. Answer 0 if no such &lt;em&gt;element&lt;/em&gt; is found in the receiver.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#reverseDo:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;p&gt;If an evaluation of &lt;code&gt;discriminator&lt;/code&gt; results in an object that does not conform to &amp;lt;boolean&amp;gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="first" docId="5.7.8.17" refined="false">
        <Synopsis>Answer the first &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">Answer the &lt;em&gt;element&lt;/em&gt; at index 1 in the receiver. The result is undefined if the receiver is empty (answers &lt;em&gt;true&lt;/em&gt; to the &lt;code&gt;#isEmpty&lt;/code&gt; message).</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="from:to:do:" docId="5.7.8.18" refined="false">
        <Synopsis>For those &lt;em&gt;elements&lt;/em&gt; of the receiver between positions &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; , inclusive, evaluate &lt;code&gt;operation&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">For each index in the range &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; , the &lt;code&gt;operation&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; at that index as its argument.</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;</Errors>
      </Message>
      <Message selector="from:to:keysAndValuesDo:" docId="5.7.8.19" refined="false">
        <Synopsis>For those &lt;em&gt;elements&lt;/em&gt; of the receiver between positions &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; , inclusive, evaluate &lt;code&gt;operation&lt;/code&gt; with an &lt;em&gt;element&lt;/em&gt; of the receiver as the first argument and the &lt;em&gt;element's&lt;/em&gt; position (index) as the second.</Synopsis>
        <Definition protocol="sequencedReadableCollection">For each index in the range &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; , the &lt;code&gt;operation&lt;/code&gt; is evaluated with the index as the first argument and the &lt;em&gt;element&lt;/em&gt; at that index as the second argument.</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver or its indices are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;</Errors>
      </Message>
      <Message selector="indexOf:" docId="5.7.8.20" refined="false">
        <Synopsis>Answer the index of the first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer zero (0) if no such &lt;em&gt;element&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer the index of the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; ; no further &lt;em&gt;elements&lt;/em&gt; are considered. Answer 0 if no such &lt;em&gt;element&lt;/em&gt; exists in the receiver.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="indexOf:ifAbsent:" docId="5.7.8.21" refined="false">
        <Synopsis>Answer the index of the first &lt;em&gt;element&lt;/em&gt; of the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; with no parameters if no such &lt;em&gt;element&lt;/em&gt; is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer the index of the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; ; no further &lt;em&gt;elements&lt;/em&gt; are considered. Answer &lt;code&gt;exceptionHandler&lt;/code&gt; evaluated with no parameters if no such &lt;em&gt;element&lt;/em&gt; is found.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="exceptionHandler" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
          <Description>&amp;lt;Object&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="indexOfSubCollection:startingAt:" docId="5.7.8.22" refined="false">
        <Synopsis>Answer the index of the first &lt;em&gt;element&lt;/em&gt; of the receiver which is the start of a subsequence which matches &lt;code&gt;targetSequence&lt;/code&gt; . Start searching at index &lt;code&gt;start&lt;/code&gt; in the receiver. Answer 0 if no such subsequence is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Each subsequence of the receiver starting at index &lt;code&gt;start&lt;/code&gt; is checked for a match with &lt;code&gt;targetSequence&lt;/code&gt; . To match, each &lt;em&gt;element&lt;/em&gt; of a subsequence of the receiver must be &lt;em&gt;equivalent&lt;/em&gt; to the corresponding &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;targetSequence&lt;/code&gt; . Answer the index of the first &lt;em&gt;element&lt;/em&gt; which begins a matching subsequence; no further subsequences are considered. Answer 0 if no such subsequence is found in the receiver, or if &lt;code&gt;targetSequence&lt;/code&gt; is empty.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="targetSequence" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size&lt;/p&gt;</Errors>
      </Message>
      <Message selector="indexOfSubCollection:startingAt:ifAbsent:" docId="5.7.8.23" refined="false">
        <Synopsis>Answer the index of the first &lt;em&gt;element&lt;/em&gt; of the receiver which is the start of a subsequence which matches &lt;code&gt;targetSequence&lt;/code&gt; . Start searching at index &lt;code&gt;start&lt;/code&gt; in the receiver. Answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; with no parameters if no such subsequence is found.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Each subsequence of the receiver starting at index &lt;code&gt;start&lt;/code&gt; is checked for a match with &lt;code&gt;targetSequence&lt;/code&gt; . To match, each &lt;em&gt;element&lt;/em&gt; of a subsequence of the receiver must be &lt;em&gt;equivalent&lt;/em&gt; to the corresponding &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;targetSequence&lt;/code&gt; . Answer the index of the first &lt;em&gt;element&lt;/em&gt; which begins a matching subsequence; no further subsequences are considered. Answer the result of evaluating &lt;code&gt;exceptionHandler&lt;/code&gt; with no parameters if no such subsequence is found or if &lt;code&gt;targetSequence&lt;/code&gt; is empty.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="targetSequence" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="exceptionHandler" aliasing="uncaptured">
          <Protocol name="niladicValuable" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
          <Description>&amp;lt;Object&amp;gt; unspecified</Description>
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size&lt;/p&gt;</Errors>
      </Message>
      <Message selector="keysAndValuesDo:" docId="5.7.8.24" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with the index of each &lt;em&gt;element&lt;/em&gt; of the receiver, in order, together with the &lt;em&gt;element&lt;/em&gt; itself.</Synopsis>
        <Definition protocol="sequencedReadableCollection">The &lt;code&gt;operation&lt;/code&gt; is evaluated with the index of each &lt;em&gt;element&lt;/em&gt; of the receiver as the first argument and the &lt;em&gt;element&lt;/em&gt; itself as the second argument. Evaluation is in indexed order starting at 1. The first &lt;em&gt;element&lt;/em&gt; is at index 1, the second at index 2, etc. The index of the last &lt;em&gt;element&lt;/em&gt; is equal to the receiver's size.</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="last" docId="5.7.8.25" refined="false">
        <Synopsis>Answer the last &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="sequencedReadableCollection">Answer the last &lt;em&gt;element&lt;/em&gt; of the receiver, the &lt;em&gt;element&lt;/em&gt; at the index equal to the receiver's size. The result is unspecified if the receiver is empty (answers &lt;em&gt;true&lt;/em&gt; to the &lt;code&gt;#isEmpty&lt;/code&gt; message).</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="reverse" docId="5.7.8.26" refined="false">
        <Synopsis>Answer a collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver arranged in reverse order.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a collection conforming to the same protocols as the receiver, but with its &lt;em&gt;elements&lt;/em&gt; arranged in reverse order.&lt;/p&gt;&lt;p&gt; This operation is equivalent to:&lt;/p&gt;&lt;p&gt; 1. Create a new collection which conforms to the same protocols as the receiver;&lt;/p&gt;&lt;p&gt; 2. Traverse the &lt;em&gt;elements&lt;/em&gt; of the receiver in the order specified by the &lt;code&gt;#reverseDo:&lt;/code&gt; message, adding each &lt;em&gt;element&lt;/em&gt; of the receiver to the new collection;&lt;/p&gt;&lt;p&gt; 3. Answer the new collection.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
      <Message selector="reverseDo:" docId="5.7.8.27" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver in the reverse of the receiver's standard traversal order.</Synopsis>
        <Definition protocol="sequencedReadableCollection">For each &lt;em&gt;element&lt;/em&gt; of the receiver, evaluate &lt;code&gt;operation&lt;/code&gt; with the &lt;em&gt;element&lt;/em&gt; as the parameter. The &lt;em&gt;elements&lt;/em&gt; are traversed in the opposite order from the &lt;code&gt;#do:&lt;/code&gt; message. Each &lt;em&gt;element&lt;/em&gt; is visited exactly once.</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="with:do:" docId="5.7.8.28" refined="false">
        <Synopsis>Evaluate &lt;code&gt;operation&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver and the corresponding &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;otherCollection&lt;/code&gt; as parameters.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver and the corresponding &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;otherCollection&lt;/code&gt; , evaluate&lt;/p&gt;&lt;p&gt; &lt;code&gt;operation&lt;/code&gt; with the receiver's &lt;em&gt;element&lt;/em&gt; as the first parameter, and the &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;otherCollection&lt;/code&gt; as the second parameter. The receiver and &lt;code&gt;otherCollection&lt;/code&gt; must have the same size.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; of the receiver and &lt;code&gt;otherCollection&lt;/code&gt; are traversed in indexed order starting at 1. The &lt;code&gt;operation&lt;/code&gt; is first evaluated with the &lt;em&gt;elements&lt;/em&gt; at index 1 in the two &amp;lt;sequencedReadableCollection&amp;gt;s, then index 2, etc.&lt;/p&gt;</Definition>
        <Parameter name="otherCollection" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver or the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;otherCollection&lt;/code&gt; are inappropriate for use as arguments to &lt;code&gt;operation&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the receiver's size is not equal to the size of &lt;code&gt;otherCollection&lt;/code&gt; .&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="Interval" docId="5.7.9" abstract="false">
      <ConformsTo protocol="sequencedReadableCollection" />
      <Description>Represents a collection whose &lt;em&gt;elements&lt;/em&gt; are numbers which form an arithmetic progression. Elements cannot be accessed externally.</Description>
      <Message selector="," docId="5.7.9.1" refined="true">
        <Synopsis>Answer a new collection which is the concatenation of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing all of the receiver's &lt;em&gt;elements&lt;/em&gt; in their original order followed by all of the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; , in their original order. The size of the new collection is equal to the sum of the sizes of the receiver and &lt;code&gt;operand&lt;/code&gt; , as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same type as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">Answer a collection containing the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; appended to the &lt;em&gt;elements&lt;/em&gt; of the receiver. The enumeration order defined by the &lt;code&gt;#do:&lt;/code&gt; message is used.  The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="collect:" docId="5.7.9.2" refined="true">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each element of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an objects conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="copyFrom:to:" docId="5.7.9.3" refined="true">
        <Synopsis>Answer a new collection containing all of the &lt;em&gt;elements&lt;/em&gt; of the receiver between the indices &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive. If &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; , the result has a size of zero.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing the specified range of &lt;em&gt;elements&lt;/em&gt; of the receiver in their original order. The &lt;em&gt;element&lt;/em&gt; at index &lt;code&gt;start&lt;/code&gt; in the receiver is at index 1 in the new collection; the &lt;em&gt;element&lt;/em&gt; at index &lt;code&gt;start&lt;/code&gt; +1 is at index 2, etc. If &lt;code&gt;stop&lt;/code&gt; is less than &lt;code&gt;start&lt;/code&gt; , then the new collection is empty. Otherwise, the size of the new collection is the maximum of ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) and 0.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;start&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;start&lt;/code&gt; &amp;gt; self size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;stop&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;stop&lt;/code&gt; &amp;gt; self size.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceAll:with:" docId="5.7.9.4" refined="true">
        <Synopsis>Answer a new collection in which all subsequences of &lt;em&gt;elements&lt;/em&gt; in the receiver matching &lt;code&gt;targetElements&lt;/code&gt; are replaced in the new collection by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver in their original order, except where a subsequence in the receiver matches &lt;code&gt;targetElements&lt;/code&gt; . A subsequence in the receiver is said to match the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;targetElements&lt;/code&gt; if:&lt;/p&gt;&lt;p&gt; 1. They have the same number of &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; 2. For all indices of the subsequence, the &lt;em&gt;element&lt;/em&gt; in the subsequence at a given index is &lt;em&gt;equivalent&lt;/em&gt; to the &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;targetElements&lt;/code&gt; at the same index.&lt;/p&gt;&lt;p&gt; Where a subsequence match is found, the &lt;em&gt;elements&lt;/em&gt; from &lt;code&gt;replacementElements&lt;/code&gt; are placed in the new collection instead.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="targetElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>If any of the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; is inappropriate for storage in instances of the result.</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:with:" docId="5.7.9.5" refined="true">
        <Synopsis>Answer a new collection, containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver, but with the &lt;em&gt;elements&lt;/em&gt; in the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive replaced by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. The size of &lt;code&gt;replacementElements&lt;/code&gt; (as defined by &lt;code&gt;#size)&lt;/code&gt; need not be the same as the number of &lt;em&gt;elements&lt;/em&gt; being replaced. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then the &lt;code&gt;replacementElements&lt;/code&gt; are inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and the &lt;code&gt;replacementElements&lt;/code&gt; are placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range are replaced by the &lt;em&gt;elements&lt;/em&gt; from &lt;code&gt;replacementElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; In all cases, the resulting collection consists of the receiver's &lt;em&gt;elements&lt;/em&gt; from indices 1 to &lt;code&gt;start&lt;/code&gt; - 1 in their original order, followed by the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; , followed by the remainder of the receiver's &lt;em&gt;elements&lt;/em&gt; from index &lt;code&gt;stop&lt;/code&gt; + 1 in their original order. The size of the result is the receiver's size - ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) + the &lt;code&gt;replacementElements&lt;/code&gt; size.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>The &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; are not suitable for storage in instances of the result.</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:withObject:" docId="5.7.9.6" refined="true">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which the &lt;em&gt;elements&lt;/em&gt; of the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive have been replaced with &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then &lt;code&gt;replacementElement&lt;/code&gt; is inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and &lt;code&gt;replacementElement&lt;/code&gt; is placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and each of the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range is replaced by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be non-negative.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;&lt;p&gt; Collections that by definition enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="copyReplacing:withObject:" docId="5.7.9.7" refined="true">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which any occurrences of &lt;code&gt;targetElement&lt;/code&gt; are replaced by &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;A new collection is created and initialized with the same &lt;em&gt;elements&lt;/em&gt; as the receiver in the same order, except that any objects in the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;targetElement&lt;/code&gt; are replaced in the new collection by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="targetElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="copyWith:" docId="5.7.9.8" refined="true">
        <Synopsis>Answer a new collection containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver, with &lt;code&gt;newElement&lt;/code&gt; added.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with size one greater than the size of the receiver containing the &lt;em&gt;elements&lt;/em&gt; of the receiver and &lt;code&gt;newElement&lt;/code&gt; placed at the end.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="copyWithout:" docId="5.7.9.9" refined="true">
        <Synopsis>Answer a new collection, containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver in their original order omitting any &lt;em&gt;elements&lt;/em&gt;  &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with all of the &lt;em&gt;elements&lt;/em&gt; of the receiver that are not &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;oldElement&lt;/code&gt; , in their original order.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same type as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="oldElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="reject:" docId="5.7.9.10" refined="true">
        <Synopsis>Answer a new collection which excludes the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;false&lt;/em&gt; is added to the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an object conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is refined to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="reverse" docId="5.7.9.11" refined="true">
        <Synopsis>Answer a collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver arranged in reverse order.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a collection conforming to the same protocols as the receiver, but with its &lt;em&gt;elements&lt;/em&gt; arranged in reverse order.&lt;/p&gt;&lt;p&gt; This operation is equivalent to:&lt;/p&gt;&lt;p&gt; 1. Create a new collection which conforms to the same protocols as the receiver;&lt;/p&gt;&lt;p&gt; 2. Traverse the &lt;em&gt;elements&lt;/em&gt; of the receiver in the order specified by the &lt;code&gt;#reverseDo:&lt;/code&gt; message, adding each &lt;em&gt;element&lt;/em&gt; of the receiver to the new collection;&lt;/p&gt;&lt;p&gt; 3. Answer the new collection.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is generalized to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="select:" docId="5.7.9.12" refined="true">
        <Synopsis>Answer a new collection which contains the &lt;em&gt;elements&lt;/em&gt; in the receiver which cause &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; .</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;discriminator&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. Each &lt;em&gt;element&lt;/em&gt; which causes &lt;code&gt;discriminator&lt;/code&gt; to evaluate to &lt;em&gt;true&lt;/em&gt; is added to the new collection.&lt;/p&gt;&lt;p&gt; The &lt;em&gt;elements&lt;/em&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an objects conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="Interval">The return type is refined to &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <Parameter name="discriminator" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;discriminator&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;discriminator&lt;/code&gt; evaluates to an object that does not conform to the protocol &amp;lt;boolean&amp;gt; for any &lt;em&gt;element&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="readableString" docId="5.7.10" abstract="true">
      <ConformsTo protocol="magnitude" />
      <ConformsTo protocol="sequencedReadableCollection" />
      <Description>Provides protocol for string operations such as copying, comparing, replacing, converting, indexing, and matching. All objects that conform to the protocol &amp;lt;readableString&amp;gt; are &lt;em&gt;comparable&lt;/em&gt; .</Description>
      <Message selector="," docId="5.7.10.1" refined="true">
        <Synopsis>Answer a new collection which is the concatenation of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing all of the receiver's elements in their original order followed by all of the elements of &lt;code&gt;operand&lt;/code&gt; , in their original order. The size of the new collection is equal to the sum of the sizes of the receiver and &lt;code&gt;operand&lt;/code&gt; , as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their elements are permitted to refine this message to reorder the result.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same type as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">The parameter &lt;code&gt;operand&lt;/code&gt; must be a &amp;lt;readableString&amp;gt;.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="&lt;" docId="5.7.10.2" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than &lt;code&gt;operand&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than &lt;code&gt;operand&lt;/code&gt; with respect to the ordering defined for them. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver and &lt;code&gt;operand&lt;/code&gt; are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">Answer &lt;em&gt;true&lt;/em&gt; if the receiver collates before &lt;code&gt;operand&lt;/code&gt; , according to the implementation defined collating algorithm. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&lt;=" docId="5.7.10.3" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than or equal to &lt;code&gt;operand&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver would answer &lt;em&gt;true&lt;/em&gt; to either the &lt;code&gt;#&amp;lt;&lt;/code&gt; or &lt;code&gt;#=&lt;/code&gt; message with &lt;code&gt;operand&lt;/code&gt; as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver and &lt;code&gt;operand&lt;/code&gt; are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">Answer &lt;em&gt;true&lt;/em&gt; if the receiver answers true to either the &lt;code&gt;#&amp;lt;&lt;/code&gt; or &lt;code&gt;#sameAs:&lt;/code&gt; messages with &lt;code&gt;operand&lt;/code&gt; as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&gt;" docId="5.7.10.4" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than &lt;code&gt;operand&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than &lt;code&gt;operand&lt;/code&gt; with respect to the natural ordering. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver and &lt;code&gt;operand&lt;/code&gt; are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of &lt;code&gt;operand&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">Answer &lt;em&gt;true&lt;/em&gt; if the receiver collates after &lt;code&gt;operand&lt;/code&gt; , according to the implementation defined collating algorithm. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&gt;=" docId="5.7.10.5" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than or equal to &lt;code&gt;operand&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver answers &lt;em&gt;true&lt;/em&gt; to either the &lt;code&gt;#&amp;gt;&lt;/code&gt; or &lt;code&gt;#=&lt;/code&gt; message with &lt;code&gt;operand&lt;/code&gt; as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; The result is undefined if the receiver and &lt;code&gt;operand&lt;/code&gt; are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">Answer &lt;em&gt;true&lt;/em&gt; if the receiver answers true to either the &lt;code&gt;#&amp;gt;&lt;/code&gt; or &lt;code&gt;#sameAs:&lt;/code&gt; messages with &lt;code&gt;operand&lt;/code&gt; as the parameter. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="asLowercase" docId="5.7.10.6" refined="false">
        <Synopsis>Answer a new string which contains all of the elements of the receiver converted to their lowercase equivalents.</Synopsis>
        <Definition protocol="readableString">Answer a new string which contains all of the elements of the receiver converted to their lowercase equivalents. Individual element of the string are converted as if they were receivers of the message # &lt;code&gt;asLowercase&lt;/code&gt; .</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="asString" docId="5.7.10.7" refined="false">
        <Synopsis>Answer a string containing the same characters as the receiver.</Synopsis>
        <Definition protocol="readableString">Answer a string containing the same characters as the receiver, in their original order.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="asSymbol" docId="5.7.10.8" refined="false">
        <Synopsis>Answer a symbol containing the same characters as the receiver.</Synopsis>
        <Definition protocol="readableString">Answer a symbol containing the same characters as the receiver, in their original order.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="symbol" />
        </ReturnValue>
      </Message>
      <Message selector="asUppercase" docId="5.7.10.9" refined="false">
        <Synopsis>Answer a new string which contains all of the elements of the receiver converted to their upper case equivalents.</Synopsis>
        <Definition protocol="readableString">Answer a new string which contains all of the elements of the receiver converted to their upper case equivalents.  Individual element of the string are converted as if they were receivers of the message # &lt;code&gt;asUppercase&lt;/code&gt; .</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="copyReplaceAll:with:" docId="5.7.10.10" refined="true">
        <Synopsis>Answer a new collection in which all subsequences of elements in the receiver matching &lt;code&gt;targetElements&lt;/code&gt; are replaced in the new collection by the elements in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with the elements of the receiver in their original order, except where a subsequence in the receiver matches &lt;code&gt;targetElements&lt;/code&gt; . A subsequence in the receiver is said to match the elements of &lt;code&gt;targetElements&lt;/code&gt; if:&lt;/p&gt;&lt;p&gt; 1. They have the same number of elements.&lt;/p&gt;&lt;p&gt; 2. For all indices of the subsequence, the element in the subsequence at a given index is &lt;em&gt;equivalent&lt;/em&gt; to the element in &lt;code&gt;targetElements&lt;/code&gt; at the same index.&lt;/p&gt;&lt;p&gt; Where a subsequence match is found, the elements from &lt;code&gt;replacementElements&lt;/code&gt; are placed in the new collection instead.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their elements are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">The elements of &lt;code&gt;targetElements&lt;/code&gt; and &lt;code&gt;replacementElements&lt;/code&gt; must conform to the protocol &amp;lt;character&amp;gt; and be valid elements for the result.</Refinement>
        <Parameter name="targetElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="copyReplaceFrom:to:with:" docId="5.7.10.11" refined="true">
        <Synopsis>Answer a new collection, containing the same elements as the receiver, but with the elements in the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive replaced by the elements in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. The size of &lt;code&gt;replacementElements&lt;/code&gt; (as defined by &lt;code&gt;#size)&lt;/code&gt; need not be the same as the number of elements being replaced. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then the &lt;code&gt;replacementElements&lt;/code&gt; are inserted between the elements at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's elements are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and the &lt;code&gt;replacementElements&lt;/code&gt; are placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and the receiver's elements in the given range are replaced by the elements from &lt;code&gt;replacementElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; In all cases, the resulting collection consists of the receiver's elements from indices 1 to &lt;code&gt;start&lt;/code&gt; - 1 in their original order, followed by the elements of &lt;code&gt;replacementElements&lt;/code&gt; , followed by the remainder of the receiver's elements from index &lt;code&gt;stop&lt;/code&gt; + 1 in their original order. The size of the result is the receiver's size - ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) + the &lt;code&gt;replacementElements&lt;/code&gt; size.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their elements are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">The elements of &lt;code&gt;replacementElements&lt;/code&gt; must be characters.</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="copyReplacing:withObject:" docId="5.7.10.12" refined="true">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which any occurrences of &lt;code&gt;targetElement&lt;/code&gt; are replaced by &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;A new collection is created and initialized with the same elements as the receiver in the same order, except that any objects in the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;targetElement&lt;/code&gt; are replaced in the new collection by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their elements are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">The parameters &lt;code&gt;targetElement&lt;/code&gt; and &lt;code&gt;replacementElement&lt;/code&gt; must be characters.</Refinement>
        <Parameter name="targetElement" aliasing="uncaptured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="copyWith:" docId="5.7.10.13" refined="true">
        <Synopsis>Answer a new collection containing the same elements as the receiver, with &lt;code&gt;newElement&lt;/code&gt; added.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with size one greater than the size of the receiver containing the elements of the receiver and &lt;code&gt;newElement&lt;/code&gt; placed at the end.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their elements are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="readableString">The parameter &lt;code&gt;newElement&lt;/code&gt; must be characters.</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="sameAs:" docId="5.7.10.14" refined="false">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver collates the same as &lt;code&gt;operand&lt;/code&gt; . Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="readableString">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver collates the same as &lt;code&gt;operand&lt;/code&gt; , according to the implementation-defined collating algorithm. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; This message differs from the &lt;code&gt;#=&lt;/code&gt; message because two strings which are not equal can collate the same, and because the receiver and &lt;code&gt;operand&lt;/code&gt; do not need to conform to the same protocols.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="subStrings:" docId="5.7.10.15" refined="false">
        <Synopsis>Answer an array containing the substrings in the receiver separated by the elements of &lt;code&gt;separators&lt;/code&gt; .</Synopsis>
        <Definition protocol="readableString">Answer an array of strings. Each element represents a group of characters separated by any of the characters in the list of &lt;code&gt;separators&lt;/code&gt; .</Definition>
        <Parameter name="separators" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If the list of &lt;code&gt;separators&lt;/code&gt; contains anything other than characters.</Errors>
      </Message>
    </Protocol>
    <Protocol name="symbol" docId="5.7.11" abstract="true">
      <ConformsTo protocol="readableString" />
      <Description>Represents an ordered, variable sized and immutable collection of characters. There is a unique object conforming to this protocol for every possible sequence of characters.  Symbols are &lt;em&gt;identity&lt;/em&gt; &lt;em&gt;objects&lt;/em&gt; .</Description>
      <Message selector="asString" docId="5.7.11.1" refined="true">
        <Synopsis>Answer a string containing the same characters as the receiver.</Synopsis>
        <Definition protocol="readableString">Answer a string containing the same characters as the receiver, in their original order.</Definition>
        <Refinement protocol="symbol">Answer an object that is not identical to the receiver</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="asSymbol" docId="5.7.11.2" refined="true">
        <Synopsis>Answer a symbol containing the same characters as the receiver.</Synopsis>
        <Definition protocol="readableString">Answer a symbol containing the same characters as the receiver, in their original order.</Definition>
        <Refinement protocol="symbol">Answer the receiver.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="RECEIVER" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="sequencedCollection" docId="5.7.12" abstract="true">
      <ConformsTo protocol="sequencedReadableCollection" />
      <Description>Provides protocol for writing to an ordered collection of objects, whose &lt;em&gt;elements&lt;/em&gt; can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <Message selector="at:put:" docId="5.7.12.1" refined="false">
        <Synopsis>Replace the &lt;em&gt;element&lt;/em&gt; in the receiver at &lt;code&gt;index&lt;/code&gt; with &lt;code&gt;newElement&lt;/code&gt; . Answer &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedCollection">This message sets one of the receiver's &lt;em&gt;elements&lt;/em&gt; based on &lt;code&gt;index&lt;/code&gt; . The &lt;code&gt;newElement&lt;/code&gt; is stored at &lt;code&gt;index&lt;/code&gt; in the receiver's &lt;em&gt;elements&lt;/em&gt; , replacing any previously stored object. Subsequent retrievals at this index will answer &lt;code&gt;newElement&lt;/code&gt; .</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; &amp;lt; 0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;newElement&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="atAll:put:" docId="5.7.12.2" refined="false">
        <Synopsis>Replace the &lt;em&gt;elements&lt;/em&gt; in the receiver specified by &lt;code&gt;indices&lt;/code&gt; with &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedCollection">&lt;p&gt;The &lt;code&gt;newElement&lt;/code&gt; is stored at each index in the receiver specified by the &lt;em&gt;elements&lt;/em&gt; of the &lt;code&gt;indices&lt;/code&gt; collection, replacing any previously stored objects at these indices. Subsequent retrievals at these indices will answer &lt;code&gt;newElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; This message is equivalent to storing &lt;code&gt;newElement&lt;/code&gt; in the receiver at each index specified by &lt;code&gt;indices&lt;/code&gt; using the &lt;code&gt;#at:put:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="indices" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>&lt;p&gt;If any &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;indices&lt;/code&gt; does not conform to &amp;lt;integer&amp;gt;.&lt;/p&gt;&lt;p&gt; If any &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;indices&lt;/code&gt; is &amp;lt;= 0 or greater than the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;newElement&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="atAllPut:" docId="5.7.12.3" refined="false">
        <Synopsis>Replace all the &lt;em&gt;elements&lt;/em&gt; in the receiver with &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedCollection">&lt;p&gt;The &lt;code&gt;newElement&lt;/code&gt; is stored at each index in the receiver, replacing any previously stored objects.&lt;/p&gt;&lt;p&gt; This message is equivalent to storing &lt;code&gt;newElement&lt;/code&gt; in the receiver at each index from 1 to the receiver's size using the &lt;code&gt;#at:put:&lt;/code&gt; message for the receiver.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>If &lt;code&gt;newElement&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of the receiver.</Errors>
      </Message>
      <Message selector="replaceFrom:to:with:" docId="5.7.12.4" refined="false">
        <Synopsis>Replace the &lt;em&gt;elements&lt;/em&gt; of the receiver between positions &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive, with the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; in their original order. Answer the receiver.</Synopsis>
        <Definition protocol="sequencedCollection">&lt;p&gt;The first &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; is stored in the receiver at position &lt;code&gt;start&lt;/code&gt; , the second at position &lt;code&gt;start&lt;/code&gt; + 1, etc. Any previously stored &lt;em&gt;elements&lt;/em&gt; at these positions are replaced.&lt;/p&gt;&lt;p&gt; If the size of &lt;code&gt;replacementElements&lt;/code&gt; is not equal to &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1, the result of sending this message is unspecified.&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;start&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;stop&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;stop&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;replacementElements&lt;/code&gt; size &amp;lt;&amp;gt; &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="replaceFrom:to:with:startingAt:" docId="5.7.12.5" refined="false">
        <Synopsis>Replace the &lt;em&gt;elements&lt;/em&gt; of the receiver between positions &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive with the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; , in their original order, starting at position &lt;code&gt;replacementStart&lt;/code&gt; . Answer the receiver.</Synopsis>
        <Definition protocol="sequencedCollection">&lt;p&gt;The &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;replacementStart&lt;/code&gt; in &lt;code&gt;replacementElements&lt;/code&gt; is stored in the receiver at position &lt;code&gt;start&lt;/code&gt; ; the &lt;em&gt;element&lt;/em&gt; at &lt;code&gt;replacementStart&lt;/code&gt; + 1 is stored at position &lt;code&gt;start&lt;/code&gt; + 1; etc. Any previously stored &lt;em&gt;elements&lt;/em&gt; at these positions in the receiver are replaced.&lt;/p&gt;&lt;p&gt; If the size of &lt;code&gt;replacementElements&lt;/code&gt; is not equal to ( &lt;code&gt;replacementStart&lt;/code&gt; + &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; ), the result of sending this message is unspecified.&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="replacementStart" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;start&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;stop&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;stop&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;replacementStart&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;replacementStart&lt;/code&gt; &amp;gt; &lt;code&gt;replacementElements&lt;/code&gt; size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;replacementElements&lt;/code&gt; size - &lt;code&gt;replacementStart&lt;/code&gt; + 1 &amp;lt; &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="replaceFrom:to:withObject:" docId="5.7.12.6" refined="false">
        <Synopsis>Replace the &lt;em&gt;elements&lt;/em&gt; of the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive with &lt;code&gt;replacementElement&lt;/code&gt; . Answer the receiver.</Synopsis>
        <Definition protocol="sequencedCollection">Replace the &lt;em&gt;elements&lt;/em&gt; of the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive with &lt;code&gt;replacementElement&lt;/code&gt; . Answer the receiver.</Definition>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;start&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;start&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;stop&lt;/code&gt; &amp;lt; 1 or &lt;code&gt;stop&lt;/code&gt; &amp;gt; the receiver's size.&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
    <Protocol name="String" docId="5.7.13" abstract="false">
      <ConformsTo protocol="readableString" />
      <ConformsTo protocol="sequencedCollection" />
      <Description>Provides protocol for string operations such as copying, storing, comparing, replacing, converting, indexing, and matching.  The &lt;em&gt;element type&lt;/em&gt; of &amp;lt;String&amp;gt; is &amp;lt;Character&amp;gt;.  The range of codePoints of characters that may be &lt;em&gt;elements&lt;/em&gt; of a &amp;lt;String&amp;gt; is implementation defined.</Description>
      <Message selector="asString" docId="5.7.13.1" refined="true">
        <Synopsis>Answer a string containing the same characters as the receiver.</Synopsis>
        <Definition protocol="readableString">Answer a string containing the same characters as the receiver, in their original order.</Definition>
        <Refinement protocol="String">Answer the receiver.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="String" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Array" docId="5.7.14" abstract="false">
      <ConformsTo protocol="sequencedCollection" />
      <Description>Represents a keyed collection of objects which can be accessed externally using sequential integer &lt;em&gt;keys&lt;/em&gt; . The index of the first &lt;em&gt;element&lt;/em&gt; is one (1).</Description>
    </Protocol>
    <Protocol name="ByteArray" docId="5.7.15" abstract="false">
      <ConformsTo protocol="sequencedCollection" />
      <Description>Represents a keyed collection whose &lt;em&gt;element type&lt;/em&gt; is &amp;lt;integer&amp;gt; and is limited to the range 0 to 255, inclusive. The elements can be accessed externally using sequential integer &lt;em&gt;keys&lt;/em&gt; . The index of the first &lt;em&gt;element&lt;/em&gt; is one (1).</Description>
    </Protocol>
    <Protocol name="sequencedContractibleCollection" docId="5.7.16" abstract="true">
      <ConformsTo protocol="collection" />
      <Description>Provides protocol for removing &lt;em&gt;elements&lt;/em&gt; from an ordered collection of objects, whose &lt;em&gt;elements&lt;/em&gt; can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <Message selector="removeAtIndex:" docId="5.7.16.1" refined="false">
        <Synopsis>Remove the &lt;em&gt;element&lt;/em&gt; of the receiver at position &lt;code&gt;index&lt;/code&gt; , and answer the removed &lt;em&gt;element&lt;/em&gt; .</Synopsis>
        <Definition protocol="sequencedContractibleCollection">&lt;p&gt;The &lt;em&gt;element&lt;/em&gt; of the receiver which is at position &lt;code&gt;index&lt;/code&gt; is removed from the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer the removed &lt;em&gt;element&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; &lt;code&gt;index&lt;/code&gt; must be a positive integer less than or equal to the receiver's size.&lt;/p&gt;</Definition>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; is 0 or negative.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; is greater than the receiver's size.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="removeFirst" docId="5.7.16.2" refined="false">
        <Synopsis>Remove and answer the first &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="sequencedContractibleCollection">The first &lt;em&gt;element&lt;/em&gt; of the receiver is removed and answered. The &lt;em&gt;element&lt;/em&gt; (if any) that was previously the second &lt;em&gt;element&lt;/em&gt; in the traversal order now becomes the first, and the receiver has one fewer &lt;em&gt;elements&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>The receiver is empty</Errors>
      </Message>
      <Message selector="removeLast" docId="5.7.16.3" refined="false">
        <Synopsis>Remove and answer the last &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="sequencedContractibleCollection">The last &lt;em&gt;element&lt;/em&gt; of the receiver is removed and answered. The &lt;em&gt;element&lt;/em&gt; (if any) that was previously the second from last &lt;em&gt;element&lt;/em&gt; in the traversal order now becomes the last, and the receiver has one fewer &lt;em&gt;elements&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>The receiver is empty</Errors>
      </Message>
    </Protocol>
    <Protocol name="SortedCollection" docId="5.7.17" abstract="false">
      <ConformsTo protocol="extensibleCollection" />
      <ConformsTo protocol="sequencedContractibleCollection" />
      <ConformsTo protocol="sequencedReadableCollection" />
      <Description>Represents a variable sized collection of objects whose &lt;em&gt;elements&lt;/em&gt; are ordered based on a sort order.  The sort order is specified by a &amp;lt;dyadicValuable&amp;gt; called the &lt;em&gt;sort block&lt;/em&gt; . &lt;em&gt;Elements&lt;/em&gt; may be added, removed or inserted, and can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <Message selector="," docId="5.7.17.1" refined="true">
        <Synopsis>Answer a new collection which is the concatenation of the receiver and &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection containing all of the receiver's &lt;em&gt;elements&lt;/em&gt; in their original order followed by all of the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; , in their original order. The size of the new collection is equal to the sum of the sizes of the receiver and &lt;code&gt;operand&lt;/code&gt; , as defined by the &lt;code&gt;#size&lt;/code&gt; message.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same type as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver sorts its &lt;em&gt;elements&lt;/em&gt; , the result will also be sorted as defined by the receiver's &lt;em&gt;sort&lt;/em&gt; &lt;em&gt;block&lt;/em&gt; .</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;operand&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="add:" docId="5.7.17.2" refined="true">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds a &lt;code&gt;newElement&lt;/code&gt; to the receiver. Unless specifically refined, the position of the &lt;code&gt;newElement&lt;/code&gt; in the &lt;em&gt;element&lt;/em&gt; traversal order is unspecified.&lt;/p&gt;&lt;p&gt; Conformant protocols may place restrictions on the type of objects that are valid elements. Unless otherwise specified, any object is acceptable.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver maintains its &lt;em&gt;elements&lt;/em&gt; in sorted order, the position of &lt;code&gt;newElement&lt;/code&gt; will depend on the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>If &lt;code&gt;newElement&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="asSortedCollection" docId="5.7.17.3" refined="true">
        <Synopsis>Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver.</Synopsis>
        <Definition protocol="collection">Answer a sorted collection with the same &lt;em&gt;elements&lt;/em&gt; as the receiver. The default &lt;em&gt;sort block&lt;/em&gt; is used unless another &lt;em&gt;sort block&lt;/em&gt; is specified in a refinement.</Definition>
        <Refinement protocol="SortedCollection">The receiver's &lt;em&gt;sort block&lt;/em&gt; is used in the result.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="SortedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="collect:" docId="5.7.17.4" refined="true">
        <Synopsis>Answer a new collection constructed by gathering the results of evaluating &lt;code&gt;transformer&lt;/code&gt; with each &lt;em&gt;element&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="collection">&lt;p&gt;For each &lt;em&gt;element&lt;/em&gt; of the receiver, &lt;code&gt;transformer&lt;/code&gt; is evaluated with the &lt;em&gt;element&lt;/em&gt; as the parameter. The results of these evaluations are collected into a new collection.&lt;/p&gt;&lt;p&gt; The elements are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for the receiver.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an objects conforming to the same protocol as the receiver.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Answer a &amp;lt;sequencedCollection&amp;gt;.</Refinement>
        <Parameter name="transformer" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;em&gt;elements&lt;/em&gt; of the receiver are inappropriate for use as arguments to &lt;code&gt;transformer&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the result of evaluating the &lt;code&gt;transformer&lt;/code&gt; is inappropriate for storage in the collection to be returned.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceAll:with:" docId="5.7.17.5" refined="true">
        <Synopsis>Answer a new collection in which all subsequences of &lt;em&gt;elements&lt;/em&gt; in the receiver matching &lt;code&gt;targetElements&lt;/code&gt; are replaced in the new collection by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a new collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver in their original order, except where a subsequence in the receiver matches &lt;code&gt;targetElements&lt;/code&gt; . A subsequence in the receiver is said to match the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;targetElements&lt;/code&gt; if:&lt;/p&gt;&lt;p&gt; 1. They have the same number of &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; 2. For all indices of the subsequence, the &lt;em&gt;element&lt;/em&gt; in the subsequence at a given index is &lt;em&gt;equivalent&lt;/em&gt; to the &lt;em&gt;element&lt;/em&gt; in &lt;code&gt;targetElements&lt;/code&gt; at the same index.&lt;/p&gt;&lt;p&gt; Where a subsequence match is found, the &lt;em&gt;elements&lt;/em&gt; from &lt;code&gt;replacementElements&lt;/code&gt; are placed in the new collection instead.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver maintains its &lt;em&gt;elements&lt;/em&gt; in sorted order, the positions of &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; will depend on the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Refinement>
        <Parameter name="targetElements" aliasing="uncaptured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If any of the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; does not conform to any &lt;em&gt;element type&lt;/em&gt; restrictions of instances of the receiver's class.&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:with:" docId="5.7.17.6" refined="true">
        <Synopsis>Answer a new collection, containing the same &lt;em&gt;elements&lt;/em&gt; as the receiver, but with the &lt;em&gt;elements&lt;/em&gt; in the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive replaced by the &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. The size of &lt;code&gt;replacementElements&lt;/code&gt; (as defined by &lt;code&gt;#size)&lt;/code&gt; need not be the same as the number of &lt;em&gt;elements&lt;/em&gt; being replaced. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then the &lt;code&gt;replacementElements&lt;/code&gt; are inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and the &lt;code&gt;replacementElements&lt;/code&gt; are placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range are replaced by the &lt;em&gt;elements&lt;/em&gt; from &lt;code&gt;replacementElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; In all cases, the resulting collection consists of the receiver's &lt;em&gt;elements&lt;/em&gt; from indices 1 to &lt;code&gt;start&lt;/code&gt; - 1 in their original order, followed by the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; , followed by the remainder of the receiver's &lt;em&gt;elements&lt;/em&gt; from index &lt;code&gt;stop&lt;/code&gt; + 1 in their original order. The size of the result is the receiver's size - ( &lt;code&gt;stop&lt;/code&gt; - &lt;code&gt;start&lt;/code&gt; + 1) + the &lt;code&gt;replacementElements&lt;/code&gt; size.&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be positive.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver maintains its &lt;em&gt;elements&lt;/em&gt; in sorted order, the positions of elements of &lt;code&gt;replacementElements&lt;/code&gt; will depend on the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElements" aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;The &lt;em&gt;elements&lt;/em&gt; in &lt;code&gt;replacementElements&lt;/code&gt; are not suitable for storage in instances of the receiver's class.&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; receiver's size + 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; - 1&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;replacementElements&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplaceFrom:to:withObject:" docId="5.7.17.7" refined="true">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which the &lt;em&gt;elements&lt;/em&gt; of the receiver between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; inclusive have been replaced with &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;This message can be used to insert, append, or replace. There are three cases:&lt;/p&gt;&lt;p&gt; 1. If &lt;code&gt;stop&lt;/code&gt; = &lt;code&gt;start&lt;/code&gt; - 1 , and &lt;code&gt;start&lt;/code&gt; is less than or equal to the size of the receiver, then &lt;code&gt;replacementElement&lt;/code&gt; is inserted between the &lt;em&gt;elements&lt;/em&gt; at index &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; . None of the receiver's &lt;em&gt;elements&lt;/em&gt; are replaced.&lt;/p&gt;&lt;p&gt; 2. If &lt;code&gt;stop&lt;/code&gt; = the size of the receiver and &lt;code&gt;start&lt;/code&gt; = &lt;code&gt;stop&lt;/code&gt; + 1, then the operation is an append, and &lt;code&gt;replacementElement&lt;/code&gt; is placed at the end of the new collection.&lt;/p&gt;&lt;p&gt; 3. Otherwise, the operation is a replacement, and each of the receiver's &lt;em&gt;elements&lt;/em&gt; in the given range is replaced by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; The parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; must be non-negative.&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver's class.&lt;/p&gt;&lt;p&gt; Collections that by definition enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver maintains its &lt;em&gt;elements&lt;/em&gt; in sorted order, the position(s) occupied by &lt;code&gt;replacementElement&lt;/code&gt; will depend on the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Refinement>
        <Parameter name="start" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="stop" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;The &lt;code&gt;replacementElement&lt;/code&gt; is not suitable for storage in instances of the receiver's class.&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; receiver's size + 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; 1&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;gt; receiver's size&lt;/p&gt;&lt;p&gt; &lt;code&gt;stop&lt;/code&gt; &amp;lt; &lt;code&gt;start&lt;/code&gt; - 1&lt;/p&gt;&lt;p&gt; If &lt;code&gt;replacementElement&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="copyReplacing:withObject:" docId="5.7.17.8" refined="true">
        <Synopsis>Answer a new collection conforming to the same protocols as the receiver, in which any occurrences of &lt;code&gt;targetElement&lt;/code&gt; are replaced by &lt;code&gt;replacementElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;A new collection is created and initialized with the same &lt;em&gt;elements&lt;/em&gt; as the receiver in the same order, except that any objects in the receiver which are &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;targetElement&lt;/code&gt; are replaced in the new collection by &lt;code&gt;replacementElement&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Unless specifically refined, this message is defined to answer an instance of the same class as the receiver.&lt;/p&gt;&lt;p&gt; Collections that enforce an ordering on their &lt;em&gt;elements&lt;/em&gt; are permitted to refine this message to reorder the result.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Since the receiver maintains its &lt;em&gt;elements&lt;/em&gt; in sorted order, the position occupied by &lt;code&gt;replacementElement&lt;/code&gt; will depend on the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Refinement>
        <Parameter name="targetElement" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="replacementElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>&lt;p&gt;If the &lt;code&gt;replacementElement&lt;/code&gt; is inappropriate for storage in instances of the receiver's class.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;replacementElement&lt;/code&gt; cannot be sorted using receiver's &lt;em&gt;sort block&lt;/em&gt; .&lt;/p&gt;</Errors>
      </Message>
      <Message selector="reverse" docId="5.7.17.9" refined="true">
        <Synopsis>Answer a collection with the &lt;em&gt;elements&lt;/em&gt; of the receiver arranged in reverse order.</Synopsis>
        <Definition protocol="sequencedReadableCollection">&lt;p&gt;Answer a collection conforming to the same protocols as the receiver, but with its &lt;em&gt;elements&lt;/em&gt; arranged in reverse order.&lt;/p&gt;&lt;p&gt; This operation is equivalent to:&lt;/p&gt;&lt;p&gt; 1. Create a new collection which conforms to the same protocols as the receiver;&lt;/p&gt;&lt;p&gt; 2. Traverse the &lt;em&gt;elements&lt;/em&gt; of the receiver in the order specified by the &lt;code&gt;#reverseDo:&lt;/code&gt; message, adding each &lt;em&gt;element&lt;/em&gt; of the receiver to the new collection;&lt;/p&gt;&lt;p&gt; 3. Answer the new collection.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection">Answer a &amp;lt;sequencedReadableCollection&amp;gt;.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="sortBlock" docId="5.7.17.10" refined="false">
        <Synopsis>Answer the receiver's &lt;em&gt;sort block&lt;/em&gt; .</Synopsis>
        <Definition protocol="SortedCollection">Answer the receiver's &lt;em&gt;sort block&lt;/em&gt; . The &lt;em&gt;sort block&lt;/em&gt; is defined by the &lt;code&gt;#sortBlock:&lt;/code&gt; message.</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="dyadicValuable" />
        </ReturnValue>
      </Message>
      <Message selector="sortBlock:" docId="5.7.17.11" refined="false">
        <Synopsis>Set the receiver's &lt;em&gt;sort block&lt;/em&gt; to &lt;code&gt;discriminator&lt;/code&gt; .</Synopsis>
        <Definition protocol="SortedCollection">&lt;p&gt;This message defines the &lt;em&gt;sort block&lt;/em&gt; used to specify the receiver's ordering criteria. The sortBlock is a 2-parameter &amp;lt;block&amp;gt;, which when evaluated with any two &lt;em&gt;elements&lt;/em&gt; in the receiver, answers &lt;em&gt;true&lt;/em&gt; if the first parameter should be ordered before the second parameter, and &lt;em&gt;false&lt;/em&gt; otherwise. The &lt;em&gt;sort block&lt;/em&gt; must obey the following properties:&lt;/p&gt;&lt;p&gt; 1. Given the same 2 parameters, the &lt;em&gt;sort block&lt;/em&gt; must answer the same result.&lt;/p&gt;&lt;p&gt; 2. The &lt;em&gt;sort block&lt;/em&gt; must obey transitivity. For example, if a is before b, and b is before c, then a must be before c.&lt;/p&gt;&lt;p&gt; The receiver's &lt;em&gt;sort block&lt;/em&gt; is set to &lt;code&gt;discriminator&lt;/code&gt; , and the &lt;em&gt;elements&lt;/em&gt; are re-sorted.&lt;/p&gt;</Definition>
        <Parameter name="discriminator" aliasing="captured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="SortedCollection" />
          <Description>&amp;lt;SortedCollection&amp;gt; receiver</Description>
        </ReturnValue>
        <Errors>If the &lt;em&gt;elements&lt;/em&gt; of the receiver cannot be sorted using the &lt;code&gt;discriminator&lt;/code&gt; .</Errors>
      </Message>
    </Protocol>
    <Protocol name="OrderedCollection" docId="5.7.18" abstract="false">
      <ConformsTo protocol="extensibleCollection" />
      <ConformsTo protocol="sequencedContractibleCollection" />
      <ConformsTo protocol="sequencedCollection" />
      <Description>Represents an ordered, variable sized collection of objects. &lt;em&gt;Elements&lt;/em&gt; may be added, removed or inserted, and can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <Message selector="add:" docId="5.7.18.1" refined="true">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver's &lt;em&gt;elements&lt;/em&gt; .</Synopsis>
        <Definition protocol="extensibleCollection">&lt;p&gt;This message adds a &lt;code&gt;newElement&lt;/code&gt; to the receiver. Unless specifically refined, the position of the &lt;code&gt;newElement&lt;/code&gt; in the &lt;em&gt;element&lt;/em&gt; traversal order is unspecified.&lt;/p&gt;&lt;p&gt; Conformant protocols may place restrictions on the type of objects that are valid &lt;em&gt;elements&lt;/em&gt; . Unless otherwise specified, any object is acceptable.&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection">The &lt;code&gt;newElement&lt;/code&gt; is added to the end of the receiver's &lt;em&gt;elements&lt;/em&gt; so that it becomes the last element in the traversal order. This message is equivalent to &lt;code&gt;#addLast:&lt;/code&gt; for the receiver with &lt;code&gt;newElement&lt;/code&gt; as the parameter.</Refinement>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
      <Message selector="add:after:" docId="5.7.18.2" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately following the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately following the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to&lt;/p&gt;&lt;p&gt; &lt;code&gt;target&lt;/code&gt; . An &lt;em&gt;element&lt;/em&gt; immediately follows another if its index is one greater than that of the other. The order used to determine which of the receiver's &lt;em&gt;elements&lt;/em&gt; is the first to equal &lt;code&gt;target&lt;/code&gt; is the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for the receiver.&lt;/p&gt;&lt;p&gt; If the receiver does not include &lt;code&gt;target&lt;/code&gt; , the operation fails.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="add:afterIndex:" docId="5.7.18.3" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately following the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately following the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; . &lt;code&gt;newElement&lt;/code&gt; is inserted at position &lt;code&gt;index&lt;/code&gt; + 1. If &lt;code&gt;index&lt;/code&gt; is equal to 0, &lt;code&gt;newElement&lt;/code&gt; becomes the first &lt;em&gt;element&lt;/em&gt; of the receiver.</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; &amp;lt; 0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; &amp;gt; receiver's size.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="add:before:" docId="5.7.18.4" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately before the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately before the first &lt;em&gt;element&lt;/em&gt; which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . An &lt;em&gt;element&lt;/em&gt; immediately precedes another if its index is one less than that of the other. The order used to determine which of the receiver's &lt;em&gt;elements&lt;/em&gt; is the first to equal &lt;code&gt;target&lt;/code&gt; in the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for the receiver.&lt;/p&gt;&lt;p&gt; If the receiver does not include &lt;code&gt;target&lt;/code&gt; , the operation fails.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the &lt;em&gt;element&lt;/em&gt; which is equal to &lt;code&gt;target&lt;/code&gt; is the last &lt;em&gt;element&lt;/em&gt; in the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="add:beforeIndex:" docId="5.7.18.5" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately before the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add &lt;code&gt;newElement&lt;/code&gt; to the receiver immediately before the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; in the receiver. If &lt;code&gt;index&lt;/code&gt; equals the receiver's size plus 1 &lt;code&gt;newElement&lt;/code&gt; will be inserted at the end of the receiver.&lt;/p&gt;&lt;p&gt; The parameter &lt;code&gt;index&lt;/code&gt; must be a positive integer less than or equal to the receiver's size plus 1.&lt;/p&gt;</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; &amp;lt;=0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; &amp;gt; receiver's size + 1.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="addAll:after:" docId="5.7.18.6" refined="false">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver immediately after the first &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver in the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for &lt;code&gt;newElements&lt;/code&gt; . The new &lt;em&gt;elements&lt;/em&gt; are inserted in the receiver immediately after the first &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; An &lt;em&gt;element&lt;/em&gt; immediately follows another if its index is one greater than that of the other. The order used to determine which of the receiver's &lt;em&gt;elements&lt;/em&gt; is the first to equal &lt;code&gt;target&lt;/code&gt; is the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for the receiver.&lt;/p&gt;&lt;p&gt; If the receiver does not include &lt;code&gt;target&lt;/code&gt; , the operation fails.&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .</Errors>
      </Message>
      <Message selector="addAll:afterIndex:" docId="5.7.18.7" refined="false">
        <Synopsis>Insert the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; in the receiver immediately after the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver in the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for &lt;code&gt;newElements&lt;/code&gt; . The new &lt;em&gt;elements&lt;/em&gt; are inserted in the receiver immediately after the &lt;em&gt;element&lt;/em&gt; in the receiver at position &lt;code&gt;index&lt;/code&gt; . If &lt;code&gt;index&lt;/code&gt; is equal to 0, &lt;code&gt;newElements&lt;/code&gt; are inserted at the beginning of the receiver.&lt;/p&gt;&lt;p&gt; The parameter &lt;code&gt;index&lt;/code&gt; must be a non-negative integer less than or equal to the receiver's size.&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; &amp;lt; 0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; &amp;gt; receiver's size.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="addAll:before:" docId="5.7.18.8" refined="false">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver immediately before the first &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver in the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for &lt;code&gt;newElements&lt;/code&gt; . The new &lt;em&gt;elements&lt;/em&gt; are inserted in the receiver immediately before the first &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; An &lt;em&gt;element&lt;/em&gt; immediately follows another if its index is one greater than that of the other. The order used to determine which of the receiver's &lt;em&gt;elements&lt;/em&gt; is the first to equal &lt;code&gt;target&lt;/code&gt; is the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for the receiver.&lt;/p&gt;&lt;p&gt; If the receiver does not include &lt;code&gt;target&lt;/code&gt; , the operation fails.&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="target" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Description>&lt;p&gt;&lt;b&gt;Errors:&lt;/b&gt;&lt;/p&gt;&lt;p&gt; If there is no &lt;em&gt;element&lt;/em&gt; in the receiver which is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;target&lt;/code&gt; .&lt;/p&gt;</Description>
        </ReturnValue>
      </Message>
      <Message selector="addAll:beforeIndex:" docId="5.7.18.9" refined="false">
        <Synopsis>Insert the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; in the receiver immediately before the &lt;em&gt;element&lt;/em&gt; at position &lt;code&gt;index&lt;/code&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;Add the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver in the traversal order defined by &lt;code&gt;#do:&lt;/code&gt; for &lt;code&gt;newElements&lt;/code&gt; . The new &lt;em&gt;elements&lt;/em&gt; are inserted in the receiver immediately before the &lt;em&gt;element&lt;/em&gt; in the receiver at position &lt;code&gt;index&lt;/code&gt; . If &lt;code&gt;index&lt;/code&gt; equals the receiver's size plus 1 &lt;code&gt;newElements&lt;/code&gt; will be inserted at the end of the receiver.&lt;/p&gt;&lt;p&gt; The parameter &lt;code&gt;index&lt;/code&gt; must be a positive integer less than or equal to the receiver's size plus 1.&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <Parameter name="index" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; &amp;lt;=0.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;index&lt;/code&gt; &amp;gt; receiver's size + 1.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="addAllFirst:" docId="5.7.18.10" refined="false">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the beginning of the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;This message is used to iteratively add each &lt;em&gt;element&lt;/em&gt; of a given collection to the beginning of the receiver's &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The operation is equivalent to adding each successive &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver using the &lt;code&gt;#addFirst:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter, where the &lt;code&gt;newElements&lt;/code&gt; are traversed in the order specified by the &lt;code&gt;#reverseDo:&lt;/code&gt; message for &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="sequencedCollection" />
        </Parameter>
      </Message>
      <Message selector="addAllLast:" docId="5.7.18.11" refined="false">
        <Synopsis>Add each &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the end of the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">&lt;p&gt;This message is used to iteratively add each &lt;em&gt;element&lt;/em&gt; of a given collection to the end of the receiver's &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The operation is equivalent to adding each successive &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; to the receiver using the &lt;code&gt;#addLast:&lt;/code&gt; message with the &lt;em&gt;element&lt;/em&gt; as the parameter, where the &lt;code&gt;newElements&lt;/code&gt; are traversed in the order specified by the &lt;code&gt;#do:&lt;/code&gt; message for &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="ERROR" aliasing="unspecified">
          <Protocol name="ANY" />
        </Parameter>
        <ReturnValue aliasing="state">
          <Protocol name="sequencedCollection" />
          <Description>&amp;lt;sequencedCollection&amp;gt; parameter</Description>
        </ReturnValue>
      </Message>
      <Message selector="addFirst:" docId="5.7.18.12" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the beginning of the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">The &lt;code&gt;newElement&lt;/code&gt; is added to the beginning of the receiver's &lt;em&gt;elements&lt;/em&gt; so that it becomes the first &lt;em&gt;element&lt;/em&gt; in the traversal order.</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
      <Message selector="addLast:" docId="5.7.18.13" refined="false">
        <Synopsis>Add &lt;code&gt;newElement&lt;/code&gt; to the end of the receiver's &lt;em&gt;elements&lt;/em&gt; . Answer &lt;code&gt;newElement&lt;/code&gt; .</Synopsis>
        <Definition protocol="OrderedCollection">The &lt;code&gt;newElement&lt;/code&gt; is added to the end of the receiver's &lt;em&gt;elements&lt;/em&gt; so that it becomes the last &lt;em&gt;element&lt;/em&gt; in the traversal order.</Definition>
        <Parameter name="newElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
      </Message>
    </Protocol>
    <Protocol name="Interval factory" docId="5.7.19" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>Represents protocol for creating a collection whose &lt;em&gt;elements&lt;/em&gt; are numbers which form an arithmetic progression.</Description>
      <StandardGlobal name="Interval">
        <Description>Conforms to the protocol &amp;lt;Interval factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Interval&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="from:to:" docId="5.7.19.1" refined="false">
        <Synopsis>Answer an interval which represents an arithmetic progression from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; in increments of 1.</Synopsis>
        <Definition protocol="Interval factory">&lt;p&gt;Answer an interval which represents an arithmetic progression from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; , using the increment 1 to compute each successive &lt;em&gt;element&lt;/em&gt; . The &lt;em&gt;elements&lt;/em&gt; are numbers which have the same type as &lt;code&gt;start&lt;/code&gt; . Note that &lt;code&gt;stop&lt;/code&gt; may not be the last &lt;em&gt;element&lt;/em&gt; in the sequence; the last &lt;em&gt;element&lt;/em&gt; is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;start + ((stop - start) // 1)&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The interval answered will be empty (it will answer 0 to the &lt;code&gt;#size&lt;/code&gt; message) if &lt;code&gt;start&lt;/code&gt; &amp;gt; &lt;code&gt;stop&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Interval" />
        </ReturnValue>
      </Message>
      <Message selector="from:to:by:" docId="5.7.19.2" refined="false">
        <Synopsis>Answer an interval which represents an arithmetic progression from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; in increments of &lt;code&gt;step&lt;/code&gt; .</Synopsis>
        <Definition protocol="Interval factory">&lt;p&gt;Answer an interval which represents an arithmetic progression from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; , using the increment &lt;code&gt;step&lt;/code&gt; to compute each successive &lt;em&gt;element&lt;/em&gt; . The value of &lt;code&gt;step&lt;/code&gt; can be positive or negative, but it must be non-zero. The &lt;em&gt;elements&lt;/em&gt; are numbers which have the most general type of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; . Note that &lt;code&gt;stop&lt;/code&gt; is not necessarily an &lt;em&gt;element&lt;/em&gt; in the sequence; the last element is given by the formula&lt;/p&gt;&lt;p&gt; &lt;code&gt;(((stop - start) // step) * step) + start&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The interval answered will be empty (it will answer 0 to the &lt;code&gt;#size&lt;/code&gt; message) if:&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;lt; &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; &amp;lt; 0, or&lt;/p&gt;&lt;p&gt; &lt;code&gt;start&lt;/code&gt; &amp;gt; &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; &amp;gt; 0.&lt;/p&gt;</Definition>
        <Parameter name="start" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="stop" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="step" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Interval" />
        </ReturnValue>
        <Errors>&lt;code&gt;step&lt;/code&gt; = 0</Errors>
      </Message>
    </Protocol>
    <Protocol name="collection factory" docId="5.7.20" abstract="true">
      <ConformsTo protocol="instantiator" />
      <Description>Provides protocol for creating a collection of objects. A collection can be fixed or variable sized, ordered or unordered, and its &lt;em&gt;elements&lt;/em&gt; may or may not be accessible by external &lt;em&gt;keys&lt;/em&gt; .</Description>
      <Message selector="new" docId="5.7.20.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; .</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Collection" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.20.2" refined="false">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; , if any, of the new collection are unspecified.&lt;/p&gt;</Definition>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Dictionary factory" docId="5.7.21" abstract="false">
      <ConformsTo protocol="collection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to the protocol &amp;lt;Dictionary&amp;gt;.</Description>
      <StandardGlobal name="Dictionary">
        <Description>Conforms to the protocol &amp;lt;Dictionary factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Dictionary&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.21.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="Dictionary factory">Return a new &amp;lt;Dictionary&amp;gt; that is optimized to store an implementation defined number of &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Dictionary" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.21.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="Dictionary factory">&lt;p&gt;The parameter &lt;code&gt;count&lt;/code&gt; represents a hint for space allocation. The new collection is to optimized to contain &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.&lt;/p&gt;&lt;p&gt; The new collection conforms to the protocol &amp;lt;Dictionary&amp;gt;.&lt;/p&gt;</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Dictionary" />
        </ReturnValue>
      </Message>
      <Message selector="withAll:" docId="5.7.21.3" refined="false">
        <Synopsis>Create a collection containing all the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="Dictionary factory">Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; . The effect is the same as evaluating &lt;code&gt;Dictionary new addAll: newElements; yourself.</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="abstractDictionary" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Dictionary" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="IdentityDictionary factory" docId="5.7.22" abstract="false">
      <ConformsTo protocol="collection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to the protocol &amp;lt;IdentityDictionary&amp;gt;.</Description>
      <StandardGlobal name="IdentityDictionary">
        <Description>Conforms to the protocol &amp;lt;IdentityDictionary factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;IdentityDictionary&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.22.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="IdentityDictionary factory">Return a new &amp;lt;IdentityDictionary&amp;gt; that is optimized to store an implementation defined number of &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="IdentityDictionary" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.22.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="IdentityDictionary factory">&lt;p&gt;The parameter &lt;code&gt;count&lt;/code&gt; represents a hint for space allocation. The new collection is to optimized to contain &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.&lt;/p&gt;&lt;p&gt; The new collection conforms to the protocol &amp;lt;IdentityDictionary&amp;gt;.&lt;/p&gt;</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="IdentityDictionary" />
        </ReturnValue>
      </Message>
      <Message selector="withAll:" docId="5.7.22.3" refined="false">
        <Synopsis>Create a collection containing all the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="IdentityDictionary factory">Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .  The effect is the same as evaluating &lt;code&gt;IdentityDictionary new addAll: newElements; yourself&lt;/code&gt; .</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="abstractDictionary" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="IdentityDictionary" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="initializableCollection factory" docId="5.7.23" abstract="true">
      <ConformsTo protocol="collection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create non-empty collections.</Description>
      <Message selector="with:" docId="5.7.23.1" refined="false">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.23.1" refined="false">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.23.1" refined="false">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.23.1" refined="false">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.23.2" refined="false">
        <Synopsis>Create a collection containing all the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="collection" />
        </ReturnValue>
        <Errors>If any of the elements in &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="Array factory" docId="5.7.24" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to &amp;lt;Array&amp;gt;.  These objects are created with a specified size.  If element values are not explicitly provided they default to nil.</Description>
      <StandardGlobal name="Array">
        <Description>Conforms to the protocol &amp;lt;Array factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Array&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.24.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="Array factory">Create a new  &amp;lt;Array&amp;gt; that contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.24.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">The parameter &lt;code&gt;count&lt;/code&gt; specifies the size of the receiver. The initial value of each &lt;em&gt;element&lt;/em&gt; of the new instance of the receiver is &lt;em&gt;nil&lt;/em&gt; . The new collections conforms to the protocol &amp;lt;Array&amp;gt;.</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>&lt;code&gt;count&amp;lt;0</Errors>
      </Message>
      <Message selector="with:" docId="5.7.24.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.24.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.24.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.24.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.24.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Array factory">If the elements of &lt;code&gt;newElements&lt;/code&gt; are ordered then their ordering establishing their index positions in the new collection.</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Array" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="Bag factory" docId="5.7.25" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to the protocol &amp;lt;Bag&amp;gt;.</Description>
      <StandardGlobal name="Bag">
        <Description>Conforms to the protocol &amp;lt;Bag factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Bag&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.25.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="Bag factory">Return a new &amp;lt;Bag&amp;gt; that is optimized to store an implementation defined number of &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.25.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">&lt;p&gt;The parameter &lt;code&gt;count&lt;/code&gt; represents a hint to the implementation as to the likely number of elements that may be added to the new collection. The new collection initially contains no elements.&lt;/p&gt;&lt;p&gt; The new collections conforms to the protocol &amp;lt;Bag&amp;gt;.&lt;/p&gt;</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
      </Message>
      <Message selector="with:" docId="5.7.25.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.25.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.25.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.25.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.25.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Bag factory">The result is unspecified if &lt;code&gt;newElements&lt;/code&gt; contains &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Bag" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="ByteArray factory" docId="5.7.26" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to &amp;lt;ByteArray&amp;gt;.  These objects are created with a specified size.  If the element values are not explicitly provided, they default to 0.</Description>
      <StandardGlobal name="ByteArray">
        <Description>Conforms to the protocol &amp;lt;ByteArray factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;ByteArray&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.26.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="ByteArray factory">Create a new  &amp;lt;ByteArray&amp;gt; that contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.26.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="ByteArray factory">The parameter &lt;code&gt;count&lt;/code&gt; specifies the size of the receiver. The initial value of each &lt;em&gt;element&lt;/em&gt; of the new instance of the receiver is &lt;em&gt;0&lt;/em&gt; . The new collections conforms to the protocol &amp;lt;ByteArray&amp;gt;.</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>&lt;code&gt;count&amp;lt;0</Errors>
      </Message>
      <Message selector="with:" docId="5.7.26.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;P&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;EM&gt;elements&lt;/EM&gt; .&lt;/P&gt;
&lt;P&gt;Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;EM&gt;element types&lt;/EM&gt; .&lt;/P&gt;</Definition>
        <Refinement protocol="ByteArray factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;EM&gt;element type&lt;/EM&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.26.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;P&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;EM&gt;elements&lt;/EM&gt; .&lt;/P&gt;
&lt;P&gt;Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;EM&gt;element types&lt;/EM&gt; .&lt;/P&gt;</Definition>
        <Refinement protocol="ByteArray factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;EM&gt;element type&lt;/EM&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.26.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;P&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;EM&gt;elements&lt;/EM&gt; .&lt;/P&gt;
&lt;P&gt;Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;EM&gt;element types&lt;/EM&gt; .&lt;/P&gt;</Definition>
        <Refinement protocol="ByteArray factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;EM&gt;element type&lt;/EM&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.26.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="ByteArray factory">The first argument is at index position 1, the second argument is at index position 2, and so on...</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.26.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="ByteArray factory">If the elements of &lt;code&gt;newElements&lt;/code&gt; are ordered then their ordering establishing their index positions in the new collection.</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="OrderedCollection factory" docId="5.7.27" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create fixed sized ordered collections of objects which can be accessed externally using integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <StandardGlobal name="OrderedCollection">
        <Description>Conforms to the protocol &amp;lt;OrderedCollection factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;OrderedCollection&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.27.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="OrderedCollection factory">Create a new &amp;lt;OrderedCollection&amp;gt; that is optimized to store an implementation defined number of &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.27.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">The parameter &lt;code&gt;count&lt;/code&gt; represents a hint for space allocation. The new collection is to optimized to contain &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>&lt;code&gt;count&amp;lt;0</Errors>
      </Message>
      <Message selector="with:" docId="5.7.27.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.27.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.27.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.27.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.27.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="OrderedCollection factory">If the elements of &lt;code&gt;newElements&lt;/code&gt; are ordered then their ordering establishing their index positions in the new collection.</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="OrderedCollection" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="Set factory" docId="5.7.28" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to the protocol &amp;lt;Set&amp;gt;.</Description>
      <StandardGlobal name="Set">
        <Description>Conforms to the protocol &amp;lt;Set factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Set&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.28.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="Set factory">Return a new &amp;lt;Set&amp;gt; that is optimized to store an arbitrary number of &lt;em&gt;elements&lt;/em&gt; . The new collection initially contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.28.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">&lt;p&gt;The parameter &lt;code&gt;count&lt;/code&gt; represents a hint for space allocation. The new collection is to optimized to contain &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; . If the value of count is zero the collection should be optimize to hold an arbitrary number of elements. The new collection initially contains no elements.&lt;/p&gt;&lt;p&gt; The new collections conforms to the protocol &amp;lt;Set&amp;gt;.&lt;/p&gt;</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
      </Message>
      <Message selector="with:" docId="5.7.28.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.28.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.28.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.28.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">The result is undefined if any of the arguments are &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.28.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="Set factory">The result is unspecified if &lt;code&gt;newElements&lt;/code&gt; contains &lt;em&gt;nil&lt;/em&gt; .</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Set" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="SortedCollection factory" docId="5.7.29" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>Represents protocol for creating a variable sized collection of objects whose &lt;em&gt;elements&lt;/em&gt; are ordered based on a sort order specified by a two parameter block called the &lt;em&gt;sort block&lt;/em&gt; . &lt;em&gt;Elements&lt;/em&gt; may be added, removed or inserted, and can be accessed using external integer &lt;em&gt;keys&lt;/em&gt; .</Description>
      <StandardGlobal name="SortedCollection">
        <Description>Conforms to the protocol &amp;lt;SortedCollection factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;SortedCollection&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.29.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the elements will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The collection's representation should be optimized to store an arbitrary number of &lt;em&gt;elements.&lt;/em&gt;</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.29.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">&lt;p&gt;The parameter &lt;code&gt;count&lt;/code&gt; represents an estimate of the maximum number of &lt;em&gt;elements&lt;/em&gt; in the collection. The representation may be optimized for this size.&lt;/p&gt;&lt;p&gt; A sort block is supplied which guarantees that the elements will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="sortBlock:" docId="5.7.29.3" refined="false">
        <Synopsis>Create a new sorted collection with &lt;code&gt;sortBlock&lt;/code&gt; as the sort block.</Synopsis>
        <Definition protocol="SortedCollection factory">&lt;p&gt;Return a new sorted collection with &lt;code&gt;sortBlock&lt;/code&gt; as the sort block. The &lt;code&gt;sortBlock&lt;/code&gt; specifies the ordering criteria for the new collection and is a two-parameter valuable, which when evaluated with any two &lt;em&gt;elements&lt;/em&gt; in the receiver, answers &lt;em&gt;true&lt;/em&gt; if the first parameter should be ordered before the second parameter, and &lt;em&gt;false&lt;/em&gt; otherwise. The sort block must obey the following properties:&lt;/p&gt;&lt;p&gt; 1. Given the same two parameters, the sort block must answer the same result.&lt;/p&gt;&lt;p&gt; 2. The sort block must obey transitivity. For example, if a is before b, and b is before c, then a must be before c.&lt;/p&gt;</Definition>
        <Parameter name="sortBlock" aliasing="captured">
          <Protocol name="dyadicValuable" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
      </Message>
      <Message selector="with:" docId="5.7.29.4" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the &lt;em&gt;elements&lt;/em&gt; will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The initial &lt;em&gt;elements&lt;/em&gt; are ordered according to this sort block.</Refinement>
        <Parameter name="firstElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="secondElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="thirdElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="fourthElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments are not appropriate as parameters to the default sort block.</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.29.4" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the &lt;em&gt;elements&lt;/em&gt; will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The initial &lt;em&gt;elements&lt;/em&gt; are ordered according to this sort block.</Refinement>
        <Parameter name="firstElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="secondElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="thirdElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="fourthElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments are not appropriate as parameters to the default sort block.</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.29.4" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the &lt;em&gt;elements&lt;/em&gt; will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The initial &lt;em&gt;elements&lt;/em&gt; are ordered according to this sort block.</Refinement>
        <Parameter name="firstElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="secondElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="thirdElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="fourthElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments are not appropriate as parameters to the default sort block.</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.29.4" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the &lt;em&gt;elements&lt;/em&gt; will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The initial &lt;em&gt;elements&lt;/em&gt; are ordered according to this sort block.</Refinement>
        <Parameter name="firstElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="secondElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="thirdElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Parameter name="fourthElement" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any of the arguments are not appropriate as parameters to the default sort block.</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.29.5" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="SortedCollection factory">A sort block is supplied which guarantees that the &lt;em&gt;elements&lt;/em&gt; will be sorted in ascending order as specified by the &lt;code&gt;#&amp;lt;&lt;/code&gt; message for the &lt;em&gt;elements&lt;/em&gt; . The initial &lt;em&gt;elements&lt;/em&gt; are ordered according to this sort block.</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="SortedCollection" />
        </ReturnValue>
        <Errors>If any &lt;em&gt;element&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; is not appropriate as a parameter to the default sort block.</Errors>
      </Message>
    </Protocol>
    <Protocol name="String factory" docId="5.7.30" abstract="false">
      <ConformsTo protocol="initializableCollection factory" />
      <Description>This protocol defines the behavior of objects that can be used to create objects that conform to &amp;lt;String&amp;gt;.  These objects are created with a specified size.</Description>
      <StandardGlobal name="String">
        <Description>Conforms to the protocol &amp;lt;String factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;String&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="new" docId="5.7.30.1" refined="true">
        <Synopsis>Create a new object.</Synopsis>
        <Definition protocol="instantiator">Return a newly created object initialized to a standard initial state.</Definition>
        <Refinement protocol="collection factory">This message has the same effect as sending the message &lt;code&gt;#new:&lt;/code&gt; with the argument &lt;code&gt;0&lt;/code&gt; , and will return an empty collection.</Refinement>
        <Refinement protocol="String factory">Create a new  &amp;lt;String&amp;gt; that contains no elements.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
      </Message>
      <Message selector="new:" docId="5.7.30.2" refined="true">
        <Synopsis>Create a new collection. The parameter &lt;code&gt;count&lt;/code&gt; constrains the number of &lt;em&gt;elements&lt;/em&gt; in the result.</Synopsis>
        <Definition protocol="collection factory">&lt;p&gt;Return a new collection that has space for at least &lt;code&gt;count&lt;/code&gt; &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may refine this message. In particular, the effect of the parameter &lt;code&gt;count&lt;/code&gt; should be specified in refinements. It can be used to specify the exact number of &lt;em&gt;elements&lt;/em&gt; , the minimum number, or in some cases can even be interpreted as a hint from the programmer, with no guarantee that the requested number of instance variables will actually be allocated.&lt;/p&gt;&lt;p&gt; Unless otherwise stated the initial values of &lt;em&gt;elements&lt;/em&gt; of the new instance of the receiver are unspecified.&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">The parameter &lt;code&gt;count&lt;/code&gt; specifies the size of the receiver. The initial value of each &lt;em&gt;element&lt;/em&gt; of the new instance of the receiver is unspecified. The new collections conforms to the protocol &amp;lt;String&amp;gt;.</Refinement>
        <Parameter name="count" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>&lt;code&gt;count&amp;lt;0</Errors>
      </Message>
      <Message selector="with:" docId="5.7.30.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:" docId="5.7.30.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:" docId="5.7.30.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="with:with:with:with:" docId="5.7.30.3" refined="true">
        <Synopsis>Create a collection initially containing the argument elements</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection containing a number of elements equal to the number of arguments to this message. The collection contains the arguments as its &lt;em&gt;elements&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of the arguments and hence the &lt;em&gt;element types&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">The first argument is at index position 1, the second argument is at index position 2, and so on.</Refinement>
        <Parameter name="element1" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element2" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element3" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <Parameter name="element4" aliasing="captured">
          <Protocol name="Character" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>If any of the arguments do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
      <Message selector="withAll:" docId="5.7.30.4" refined="true">
        <Synopsis>Create a collection containing only the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .</Synopsis>
        <Definition protocol="initializableCollection factory">&lt;p&gt;Return a new collection whose &lt;em&gt;elements&lt;/em&gt; are the &lt;em&gt;elements&lt;/em&gt; of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; Conforming protocols may impose restrictions on the values of &lt;code&gt;newElements&lt;/code&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="String factory">If the elements of &lt;code&gt;newElements&lt;/code&gt; are ordered then their ordering establishing their index positions in the new collection.</Refinement>
        <Parameter name="newElements" aliasing="unspecified">
          <Protocol name="collection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="String" />
        </ReturnValue>
        <Errors>If any of the elements of &lt;code&gt;newElements&lt;/code&gt; do not meet the &lt;em&gt;element type&lt;/em&gt; constraints of the result object</Errors>
      </Message>
    </Protocol>
    <Protocol name="DateAndTime" docId="5.8.1" abstract="false">
      <ConformsTo protocol="magnitude" />
      <Description>&lt;p&gt;This protocol describes the behavior that is common to date time objects. Date time objects represent individual points in Coordinated Universal Time (UTC) as represented in an implementation defined local time.&lt;/p&gt;&lt;p&gt; The exact properties of local times are unspecified. Local times may differ in their offset from UTC. A given local time may have different offsets from UTC at different points in time.&lt;/p&gt;&lt;p&gt; All dates and times in the UTC local time are in the Gregorian calendar. Date times prior to the adoption of the Gregorian calendar are given in the retrospective astronomical Gregorian calendar. The year 1 B.C. is astronomical Gregorian year 0. The year 2 B.C. is astronomical Gregorian year-1. The year 1 A.D. is astronomical Gregorian year 1. The offset of the UTC local time is zero.&lt;/p&gt;</Description>
      <Message selector="+" docId="5.8.1.1" refined="false">
        <Synopsis>Answer the result of adding &lt;code&gt;operand&lt;/code&gt; to the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;DateAndTime&amp;gt; that represents the UTC time that is &lt;code&gt;operand&lt;/code&gt; after the receiver and whose &lt;em&gt;local time&lt;/em&gt; is the same as the receiver's. If &lt;code&gt;operand&lt;/code&gt; is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; , the result is the &amp;lt;DateAndTime&amp;gt; that is that is the absolute value of &lt;code&gt;operand&lt;/code&gt; before the receiver.</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="DateAndTime" />
        </ReturnValue>
      </Message>
      <Message selector="-" docId="5.8.1.2" refined="false">
        <Synopsis>Answer the result of adding &lt;code&gt;operand&lt;/code&gt; to the receiver.</Synopsis>
        <Definition protocol="DateAndTime">&lt;p&gt;If &lt;code&gt;operand&lt;/code&gt; is a &amp;lt;DateAndTime&amp;gt;, answer a &amp;lt;Duration&amp;gt; whose value is the period of time between the &lt;code&gt;operand&lt;/code&gt; and the receiver. If &lt;code&gt;operand&lt;/code&gt; is a &amp;lt;DateAndTime&amp;gt; prior to the receiver then the result is a &amp;lt;Duration&amp;gt; less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If &lt;code&gt;operand&lt;/code&gt; is a &amp;lt;Duration&amp;gt;, answer a new &amp;lt;DateAndTime&amp;gt; which represents the UTC time that is &lt;code&gt;operand&lt;/code&gt; before the receiver and whose &lt;em&gt;local time&lt;/em&gt; is the same as the receiver's. If &lt;code&gt;operand&lt;/code&gt; is a duration less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result is a &amp;lt;DateAndTime&amp;gt; that is the absolute value of operand after the receiver.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="DateAndTime" />
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
          <Description>&amp;lt;DateAndTime&amp;gt; unspecified</Description>
        </ReturnValue>
        <Errors>none.</Errors>
      </Message>
      <Message selector="&lt;" docId="5.8.1.3" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand with respect to the ordering defined for them. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="DateAndTime">&lt;p&gt;Answer true if the UTC time represented by &lt;code&gt;operand&lt;/code&gt; follows the UTC time represented by the receiver. Answer false otherwise.&lt;/p&gt;&lt;p&gt; If the offsets of the receiver and operand are the same then their order is determined by their &lt;em&gt;lexical order&lt;/em&gt; in the sequence &lt;code&gt;#year&lt;/code&gt; , &lt;code&gt;#month&lt;/code&gt; , &lt;code&gt;#day&lt;/code&gt; , &lt;code&gt;#hour24&lt;/code&gt; , &lt;code&gt;#minute&lt;/code&gt; , &lt;code&gt;#second&lt;/code&gt; . If their offsets differ then result is the same as if &lt;code&gt;receiver asUTC &amp;lt; operand asUTC&lt;/code&gt; were evaluated.&lt;/p&gt;</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="DateAndTime" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="=" docId="5.8.1.4" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Refinement protocol="DateAndTime">Answer true if the &lt;code&gt;comparand conforms to &amp;lt;DateAndTime&amp;gt; and if it&lt;/code&gt; represents the same UTC time as the receiver. Answer false otherwise.  The &lt;em&gt;local times&lt;/em&gt; of the receiver and operand are ignored.</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&gt;" docId="5.8.1.5" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand with respect to the natural ordering. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="DateAndTime">&lt;p&gt;Answer true if the UTC time represented by &lt;code&gt;operand&lt;/code&gt; precedes the UTC time represented by the receiver. Answer false otherwise.&lt;/p&gt;&lt;p&gt; If the offsets of the receiver and operand are the same then their order is determined by their &lt;em&gt;lexical order&lt;/em&gt; in the sequence &lt;code&gt;#year&lt;/code&gt; , &lt;code&gt;#month&lt;/code&gt; , &lt;code&gt;#day&lt;/code&gt; , &lt;code&gt;#hour24&lt;/code&gt; , &lt;code&gt;#minute&lt;/code&gt; , &lt;code&gt;#second&lt;/code&gt; . If their offsets differ then result is the same as if &lt;code&gt;receiver asUTC &amp;gt; operand asUTC&lt;/code&gt; were evaluated.&lt;/p&gt;</Refinement>
        <Parameter name="operand" aliasing="uncaptured">
          <Protocol name="DateAndTime" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="asLocal" docId="5.8.1.6" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; that represents the same UTC time as the receiver but in the &lt;em&gt;local time&lt;/em&gt; specified by the implementation.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;DateAndTime&amp;gt; that represents the same UTC time as the receiver but in the &lt;em&gt;local time&lt;/em&gt; specified by the implementation.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="DateAndTime" />
        </ReturnValue>
      </Message>
      <Message selector="asUTC" docId="5.8.1.7" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; that represents the same absolute time as the receiver but in the &lt;em&gt;local&lt;/em&gt; &lt;em&gt;time&lt;/em&gt; UTC.</Synopsis>
        <Definition protocol="DateAndTime">&lt;p&gt;Answer a &amp;lt;DateAndTime&amp;gt; that represents the same absolute time as the receiver but in the &lt;em&gt;local&lt;/em&gt; &lt;em&gt;time&lt;/em&gt; UTC.  The exact meaning of UTC &lt;em&gt;local time&lt;/em&gt; is specified by the implementation. The UTC &lt;em&gt;local&lt;/em&gt; &lt;em&gt;time&lt;/em&gt; must use the Gregorian calendar. &amp;lt;DateAndTimes&amp;gt; representing UTC times prior to the adoption of the Gregorian calendar must use the retrospective astronomical Gregorian calendar. It is an invariant that&lt;/p&gt;&lt;p&gt; &lt;code&gt;&amp;lt;DateAndTime&amp;gt; asUTC offset = Duration zero.&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="DateAndTime" />
        </ReturnValue>
      </Message>
      <Message selector="dayOfMonth" docId="5.8.1.8" refined="false">
        <Synopsis>Answer the number of the day in the month in the &lt;em&gt;local time&lt;/em&gt; of the receiver which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 1 and 31 inclusive representing the number of the day in the month, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="dayOfWeek" docId="5.8.1.9" refined="false">
        <Synopsis>Answer the number of the day in the week, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 1 and 7 inclusive representing the number of the day in the week, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver. Sunday is 1, Monday is 2, and so on.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="dayOfWeekAbbreviation" docId="5.8.1.10" refined="false">
        <Synopsis>Answer the abbreviation of the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the day of the week which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;readableString&amp;gt;  which is the abbreviation of the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the day of the week which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="dayOfWeekName" docId="5.8.1.11" refined="false">
        <Synopsis>Answer the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the day of the week which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;readableString&amp;gt; which is the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the day of the week which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="dayOfYear" docId="5.8.1.12" refined="false">
        <Synopsis>Answer the number of the day in the year, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 1 and 366 inclusive representing the number of the day in the year, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="hour" docId="5.8.1.13" refined="false">
        <Synopsis>Answer the number of the hour in the day, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 0 and 23 inclusive representing the number of the hour in the day, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver. It is implementation defined whether a given &lt;em&gt;local time&lt;/em&gt; uses the 12-hour clock or the 24-hour clock, except that the UTC &lt;em&gt;local time&lt;/em&gt; must use the 24-hour clock.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="hour12" docId="5.8.1.14" refined="false">
        <Synopsis>Answer the hour in the day in the 12-hour clock of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 1 and 12 inclusive representing the hour in the day in the 12-hour clock of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="hour24" docId="5.8.1.15" refined="false">
        <Synopsis>Answer the hour in the day in the 24-hour clock of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 0 and 23 inclusive representing the hour in the day in the 24-hour clock of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="isLeapYear" docId="5.8.1.16" refined="false">
        <Synopsis>Test for leap year.</Synopsis>
        <Definition protocol="DateAndTime">&lt;p&gt;Answer true if the year, which includes the receiver, in the &lt;em&gt;local time&lt;/em&gt; of the receiver is a leap year, false otherwise.&lt;/p&gt;&lt;p&gt; Two &amp;lt;DateAndTime&amp;gt; objects that are equal can give different results for #isLeapYear. Equality depends on their UTC time whereas #isLeapYear depends on their &lt;em&gt;local time&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="meridianAbbreviation" docId="5.8.1.17" refined="false">
        <Synopsis>Answer the abbreviation, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the name of the half of the day, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;readableString&amp;gt; that is the abbreviation, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the name of the half of the day, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="minute" docId="5.8.1.18" refined="false">
        <Synopsis>Answer the minute of the hour in the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 0 and 59 inclusive representing the minute of hour in the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="month" docId="5.8.1.19" refined="false">
        <Synopsis>Answer the number of the month in the year, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; between 1 and 12 inclusive representing the number of the month in the year, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="monthAbbreviation" docId="5.8.1.20" refined="false">
        <Synopsis>Answer the abbreviation of the name of the month, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;readableString&amp;gt; that is the abbreviation of the name of the month, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="monthName" docId="5.8.1.21" refined="false">
        <Synopsis>Answer the name of the month, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;readableString&amp;gt; that is the name of the month, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="offset" docId="5.8.1.22" refined="false">
        <Synopsis>Answer the difference between the &lt;em&gt;local time&lt;/em&gt; of the receiver and UTC at the time of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;Duration&amp;gt; representing the difference between the &lt;em&gt;local time&lt;/em&gt; of the receiver and UTC at the time of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="offset:" docId="5.8.1.23" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; equivalent to the receiver but with its &lt;em&gt;local time&lt;/em&gt; being offset from UTC by &lt;code&gt;offset&lt;/code&gt; .</Synopsis>
        <Definition protocol="DateAndTime">&lt;p&gt;Answer a &amp;lt;DateAndTime&amp;gt; equivalent to the receiver but with its &lt;em&gt;local time&lt;/em&gt; being offset from UTC by &lt;code&gt;offset&lt;/code&gt; .  The impact of this on any other &lt;em&gt;local time&lt;/em&gt; property is unspecified.&lt;/p&gt;&lt;p&gt; Implementations may define a limit to the range of &lt;code&gt;offset&lt;/code&gt; , but it must be at least -12:00:00 to 12:00:00 inclusive.&lt;/p&gt;&lt;p&gt; It is an invariant that if x is a &amp;lt;Duration&amp;gt; in range then&lt;/p&gt;&lt;p&gt; &lt;code&gt;(&amp;lt;DateAndTime&amp;gt; offset: x) offset = x&lt;/p&gt;</Definition>
        <Parameter name="offset" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="DateAndTime" />
        </ReturnValue>
        <Errors>&lt;code&gt;offset&lt;/code&gt; out of range</Errors>
      </Message>
      <Message selector="printString" docId="5.8.1.24" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object are implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="DateAndTime">&lt;p&gt;The returned string will represent the UTC time of the receiver offset from UTC by the offset of the receiver. All dates are in the astronomical Gregorian calendar. The result will be formatted as&lt;/p&gt;&lt;p&gt; -YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z where&lt;/p&gt;&lt;p&gt; - is the &amp;lt;Character&amp;gt; $- if the year is less than 0 otherwise it is the &amp;lt;Character&amp;gt; that is returned from the message &lt;code&gt;#space&lt;/code&gt; sent to the standard global &lt;code&gt;Character&lt;/code&gt; ,&lt;/p&gt;&lt;p&gt; YYYY is the year left zero filled to four places,&lt;/p&gt;&lt;p&gt; - is the &amp;lt;Character&amp;gt; $-,&lt;/p&gt;&lt;p&gt; MM is the month of the year left zero filled to two places,&lt;/p&gt;&lt;p&gt; - is the &amp;lt;Character&amp;gt; $-,&lt;/p&gt;&lt;p&gt; DD is the day of the month left zero filled to two places,&lt;/p&gt;&lt;p&gt; T is the &amp;lt;Character&amp;gt; $T,&lt;/p&gt;&lt;p&gt; hh is the hour in the 24-hour clock left zero filled to two places,&lt;/p&gt;&lt;p&gt; : is the &amp;lt;Character&amp;gt; $:,&lt;/p&gt;&lt;p&gt; mm is the minute left zero filled to two places,&lt;/p&gt;&lt;p&gt; : is the &amp;lt;Character&amp;gt; $:,&lt;/p&gt;&lt;p&gt; ss is the second left zero filled to two places,&lt;/p&gt;&lt;p&gt; . is the &amp;lt;Character&amp;gt; $. and is present only if the fraction of a second is non-zero,&lt;/p&gt;&lt;p&gt; s is the fraction of a second and is present only if non-zero,&lt;/p&gt;&lt;p&gt; + is the &amp;lt;Character&amp;gt; $+ if the offset is greater than or equal to &amp;lt;Duration factory&amp;gt; #zero and the &amp;lt;Character&amp;gt; $- if it is less,&lt;/p&gt;&lt;p&gt; ZZ is the hours of the offset left zero filled to two places, and&lt;/p&gt;&lt;p&gt; : is the &amp;lt;Character&amp;gt; $:,&lt;/p&gt;&lt;p&gt; zz is the minutes of the offset left zero filled to two places,&lt;/p&gt;&lt;p&gt; : is the &amp;lt;Character&amp;gt; $: and is present only if the seconds of the offset is non-zero,&lt;/p&gt;&lt;p&gt; z is the seconds of the offset including any fractional part and is present only if non- zero.&lt;/p&gt;&lt;p&gt; This format is based on ISO 8601 sections 5.3.3 and 5.4.1.&lt;/p&gt;&lt;p&gt; Example: 8:33:14.321 PM EST January 5, 1200 B.C.&lt;/p&gt;&lt;p&gt; &lt;code&gt;'-1199-01-05T20:33:14.321-05:00'&lt;/code&gt; Example: 12 midnight UTC January 1,  2001 A.D.&lt;/p&gt;&lt;p&gt; &lt;code&gt;' 2001-01-01T00:00:00+00:00'&lt;/p&gt;</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="second" docId="5.8.1.25" refined="false">
        <Synopsis>Answer the second of the minute of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a &amp;lt;number&amp;gt; greater than or equal to 0 and strictly less than 60 representing the second of the minute of the &lt;em&gt;local time&lt;/em&gt; of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
      </Message>
      <Message selector="timeZoneAbbreviation" docId="5.8.1.26" refined="false">
        <Synopsis>Answer the abbreviation of the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the time zone of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a  &amp;lt;readableString&amp;gt; that is the abbreviation of the name, in the &lt;em&gt;local time&lt;/em&gt; of the receiver, of the time zone of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="timeZoneName" docId="5.8.1.27" refined="false">
        <Synopsis>Answer the name in the &lt;em&gt;local time&lt;/em&gt; of the receiver of the time zone of the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer a  &amp;lt;readableString&amp;gt; that is the name in the &lt;em&gt;local time&lt;/em&gt; of the receiver of the time zone of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="year" docId="5.8.1.28" refined="false">
        <Synopsis>Answer the number of the year in the &lt;em&gt;local time&lt;/em&gt; of the receiver which includes the receiver.</Synopsis>
        <Definition protocol="DateAndTime">Answer an &amp;lt;integer&amp;gt; the number of the year which includes the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Duration" docId="5.8.2" abstract="false">
      <ConformsTo protocol="magnitude" />
      <Description>Represents a length of time.</Description>
      <Message selector="*" docId="5.8.2.1" refined="false">
        <Synopsis>Answer the result of multiplying the receiver by &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="Duration">Answer a &amp;lt;Duration&amp;gt; that is the result of multiplying the receiver by &lt;code&gt;operand&lt;/code&gt; .</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="+" docId="5.8.2.2" refined="false">
        <Synopsis>Answer the result of adding &lt;code&gt;operand&lt;/code&gt; to the receiver.</Synopsis>
        <Definition protocol="Duration">Answer a &amp;lt;Duration&amp;gt; whose value is the result of adding the receiver and &lt;code&gt;operand&lt;/code&gt; .</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="-" docId="5.8.2.3" refined="false">
        <Synopsis>Answer the result of subtracting the operand from the receiver.</Synopsis>
        <Definition protocol="Duration">Answer a &amp;lt;Duration&amp;gt; whose value is the result of subtracting &lt;code&gt;operand&lt;/code&gt; from the receiver.</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="/" docId="5.8.2.4" refined="false">
        <Synopsis>Answer the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; .</Synopsis>
        <Definition protocol="Duration">&lt;p&gt;If &lt;code&gt;operand&lt;/code&gt; is a &amp;lt;number&amp;gt; answer a new &amp;lt;Duration&amp;gt; whose value is the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; . If &lt;code&gt;operand&lt;/code&gt; equals zero the ZeroDivide exception is signaled.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;operand&lt;/code&gt; is a &amp;lt;Duration&amp;gt; answer a &amp;lt;number&amp;gt; whose value is the result of dividing the receiver by &lt;code&gt;operand&lt;/code&gt; . If &lt;code&gt;operand&lt;/code&gt; is &lt;code&gt;&amp;lt;Duration factory&amp;gt; #zero&lt;/code&gt; the ZeroDivide exception is signaled.&lt;/p&gt;</Definition>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="number" />
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
          <Description>&amp;lt;number&amp;gt; unspecified</Description>
        </ReturnValue>
      </Message>
      <Message selector="&lt;" docId="5.8.2.5" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is less than operand with respect to the ordering defined for them. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="Duration">Answer true if operand represents a &amp;lt;Duration&amp;gt; that is larger than the receiver. Answer false otherwise.</Refinement>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="=" docId="5.8.2.6" refined="true">
        <Synopsis>Object equivalence test.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;This message tests whether the receiver and the &lt;code&gt;comparand&lt;/code&gt; are equivalent objects at the time the message is processed. Return &lt;em&gt;true&lt;/em&gt; if the receiver is equivalent to &lt;code&gt;comparand&lt;/code&gt; . Otherwise return &lt;em&gt;false&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The meaning of &amp;quot;equivalent&amp;quot; cannot be precisely defined but the intent is that two objects are considered equivalent if they can be used interchangeably. Conforming protocols may choose to more precisely define the meaning of &amp;quot;equivalent&amp;quot;.&lt;/p&gt;&lt;p&gt; The value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; if and only if the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;comparand = receiver&lt;/p&gt;&lt;p&gt;&lt;/code&gt; would also be &lt;em&gt;true&lt;/em&gt; . If the value of&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand&lt;/p&gt;&lt;p&gt;&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt; then the receiver and &lt;code&gt;comparand&lt;/code&gt; must have &lt;em&gt;equivalent&lt;/em&gt; &lt;em&gt;hash values&lt;/em&gt; . Or more formally:&lt;/p&gt;&lt;p&gt; &lt;code&gt;receiver = comparand receiver hash = comparand hash&lt;/p&gt;&lt;p&gt;&lt;/code&gt; The equivalence of objects need not be &lt;em&gt;temporally invariant&lt;/em&gt; . Two independent invocations of &lt;code&gt;#=&lt;/code&gt; with the same receiver and &lt;code&gt;operand&lt;/code&gt; objects may not always yield the same results. Note that a collection that uses &lt;code&gt;#=&lt;/code&gt; to discriminate objects may only reliably store objects whose hash values do not change while the objects are contained in the collection.&lt;/p&gt;</Definition>
        <Refinement protocol="Duration">Answer true if the &lt;code&gt;comparand&lt;/code&gt; is a &amp;lt;Duration&amp;gt; representing the same length of time as the receiver. Answer false otherwise.</Refinement>
        <Parameter name="comparand" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="&gt;" docId="5.8.2.7" refined="true">
        <Synopsis>Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand. Answer &lt;em&gt;false&lt;/em&gt; otherwise.</Synopsis>
        <Definition protocol="magnitude">&lt;p&gt;Answer &lt;em&gt;true&lt;/em&gt; if the receiver is greater than operand with respect to the natural ordering. Answer &lt;em&gt;false&lt;/em&gt; otherwise.&lt;/p&gt;&lt;p&gt; It is erroneous if the receiver and operand are not &lt;em&gt;comparable&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The semantics of the natural ordering must be defined by refinement, which may also restrict the type of operand.&lt;/p&gt;</Definition>
        <Refinement protocol="Duration">Answer true if &lt;code&gt;operand&lt;/code&gt; represents a &amp;lt;Duration&amp;gt; which is smaller than the receiver. Answer false otherwise.</Refinement>
        <Parameter name="operand" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="asSeconds" docId="5.8.2.8" refined="false">
        <Synopsis>Answer the total number of seconds in the length of time represented by the receiver.</Synopsis>
        <Definition protocol="Duration">Answer the total number of seconds in the length of time represented by the receiver including any fractional part of a second.  If the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result will be less than 0.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
      </Message>
      <Message selector="abs" docId="5.8.2.9" refined="false">
        <Synopsis>Answer the absolute value of the receiver.</Synopsis>
        <Definition protocol="Duration">If the receiver is greater than or equal to &amp;lt;Duration Factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; answer a &amp;lt;Duration&amp;gt; which is equal to the receiver. Otherwise answer a &amp;lt;Duration&amp;gt; which has the same magnitude as the receiver but the opposite sign.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="days" docId="5.8.2.10" refined="false">
        <Synopsis>Answer the number of complete days in the receiver.</Synopsis>
        <Definition protocol="Duration">Answer the number of complete days in the receiver. If the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result will be less than or equal to 0.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="hours" docId="5.8.2.11" refined="false">
        <Synopsis>Answer the number of complete hours in the receiver.</Synopsis>
        <Definition protocol="Duration">Answer an &amp;lt;integer&amp;gt; between -23 and 23 inclusive that represents the number of complete hours in the receiver, after the number of complete days has been removed. If the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result will be less than or equal to 0.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="minutes" docId="5.8.2.12" refined="false">
        <Synopsis>Answer the number of complete minutes in the receiver.</Synopsis>
        <Definition protocol="Duration">Answer an &amp;lt;integer&amp;gt; between -59 and 59 inclusive that represents the number of complete minutes in the receiver, after the number of complete days and hours have been removed. If the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result will be less than or equal to 0.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="negated" docId="5.8.2.13" refined="false">
        <Synopsis>Answer the negation of the receiver.</Synopsis>
        <Definition protocol="Duration">Answer a &amp;lt;Duration&amp;gt; which is of the same magnitude but opposite sign as the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="negative" docId="5.8.2.14" refined="false">
        <Synopsis>Answer true if the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; .</Synopsis>
        <Definition protocol="Duration">Answer true if the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; , false otherwise.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="positive" docId="5.8.2.15" refined="false">
        <Synopsis>Answer true if the receiver is greater than or equal to &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; .</Synopsis>
        <Definition protocol="Duration">Answer true if the receiver is greater than or equal to the &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; , false otherwise.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="printString" docId="5.8.2.16" refined="true">
        <Synopsis>Return a string that describes the receiver.</Synopsis>
        <Definition protocol="Object">&lt;p&gt;A string consisting of a sequence of characters that describe the receiver are returned as the result.&lt;/p&gt;&lt;p&gt; The exact sequence of characters that describe an object is implementation defined.&lt;/p&gt;</Definition>
        <Refinement protocol="Duration">&lt;p&gt;Answer a description of the receiver that is formatted as&lt;/p&gt;&lt;p&gt; [-]D:HH:MM:SS[.S] where&lt;/p&gt;&lt;p&gt; - is a minus sign if the receiver represents a length of time going from the future into the past,&lt;/p&gt;&lt;p&gt; D is the number of complete days with leading zeros to fill one place,&lt;/p&gt;&lt;p&gt; HH is the number of complete hours with leading zeros to fill two places,&lt;/p&gt;&lt;p&gt; MM is the number of complete minutes with leading zeros to fill two places,&lt;/p&gt;&lt;p&gt; SS is. the number of complete seconds with leading zeros to fill two places, and&lt;/p&gt;&lt;p&gt; .S is the fractional part of the number of seconds, if any.&lt;/p&gt;</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="readableString" />
        </ReturnValue>
      </Message>
      <Message selector="seconds" docId="5.8.2.17" refined="false">
        <Synopsis>Answer the number of seconds in the receiver.</Synopsis>
        <Definition protocol="Duration">Answer a &amp;lt;number&amp;gt; strictly greater than -60 and strictly less than 60 that represents the number of seconds in the receiver, after the complete days, hours, and minutes have been removed. If the receiver is less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; then the result will be less than or equal to 0.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="number" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="Duration factory" docId="5.8.3" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>Represents protocol for creating a particular length of time.</Description>
      <StandardGlobal name="Duration">
        <Description>Conforms to the protocol &amp;lt;Duration factory&amp;gt;. Its language element type is unspecified.</Description>
      </StandardGlobal>
      <Message selector="days:hours:minutes:seconds:" docId="5.8.3.1" refined="false">
        <Synopsis>Answer a &amp;lt;Duration&amp;gt; of the number of days, hours, minutes, and seconds.</Synopsis>
        <Definition protocol="Duration factory">Answer a &amp;lt;Duration&amp;gt; of the number of days, hours, minutes, and seconds. If any of the operands are negative, the result is smaller by that number of days, hours, minutes, or seconds as appropriate.</Definition>
        <Parameter name="days" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="hours" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="minutes" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="seconds" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="seconds:" docId="5.8.3.2" refined="false">
        <Synopsis>Answer a &amp;lt;Duration&amp;gt; which is &lt;code&gt;seconds&lt;/code&gt; in length</Synopsis>
        <Definition protocol="Duration factory">If &lt;code&gt;seconds&lt;/code&gt; is negative, answer a &amp;lt;Duration&amp;gt; that is abs ( &lt;code&gt;seconds&lt;/code&gt; ) less than &amp;lt;Duration factory&amp;gt; &lt;code&gt;#zero&lt;/code&gt; .</Definition>
        <Parameter name="seconds" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="zero" docId="5.8.3.3" refined="false">
        <Synopsis>Answer a &amp;lt;Duration&amp;gt; of zero length.</Synopsis>
        <Definition protocol="Duration factory">Answer a &amp;lt;Duration&amp;gt; representing a length of no time.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="DateAndTime factory" docId="5.8.4" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>Represents protocol for creating an abstraction for a particular day of the year.</Description>
      <StandardGlobal name="DateTime">
        <Description>Conforms to the protocol &amp;lt;DateAndTime factory&amp;gt;. Its language element type is unspecified.</Description>
      </StandardGlobal>
      <Message selector="clockPrecision" docId="5.8.4.1" refined="false">
        <Synopsis>Answer a &amp;lt;Duration&amp;gt; such that after that period of time passes, &lt;code&gt;#now&lt;/code&gt; is guaranteed to give a different result.</Synopsis>
        <Definition protocol="DateAndTime factory">Answer a &amp;lt;Duration&amp;gt; such that after that period of time passes, &lt;code&gt;#now&lt;/code&gt; is guaranteed to give a different result. Ideally implementations should answer the least such duration.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="Duration" />
        </ReturnValue>
      </Message>
      <Message selector="year:month:day:hour:minute:second:" docId="5.8.4.2" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfMonth&lt;/code&gt; of the month &lt;code&gt;month&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar in local time.</Synopsis>
        <Definition protocol="DateAndTime factory">&lt;p&gt;Answer the least &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfMonth&lt;/code&gt; of the month &lt;code&gt;month&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar in the &lt;em&gt;local time&lt;/em&gt; specified by the implementation. The &lt;code&gt;second&lt;/code&gt; must be a &amp;lt;number&amp;gt; greater than or equal to 0 and strictly less than 60. The &lt;code&gt;minute&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 59 inclusive. The &lt;code&gt;hour&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 23 inclusive. The &lt;code&gt;day&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and 31 inclusive. The &lt;code&gt;month&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and 12 inclusive.  An implementation may not impose any limits on the year other than those imposed on &amp;lt;integer&amp;gt; constants.&lt;/p&gt;&lt;p&gt; It is possible that the time specified does not exist in the local time defined by the implementation. If there is a time change such that the &lt;em&gt;local time&lt;/em&gt; is set forward and the time specified is in the interregnum, then that time does not exist in the local time. For example if at 02:00 in California on April 26, 1997 there is a time change that sets local time forward one hour, then the local time 02:30  in California does not exist. Conversely if there is a time change that sets the &lt;em&gt;locale time&lt;/em&gt; back there are times which are ambiguous. For example if instead of setting the local time forward from 02:00 to 03:00 it is set back to 01:00 the the local time 01:30 in California is ambiguious. The result is the least &amp;lt;DateAndTime&amp;gt; that conforms to the given parameters.&lt;/p&gt;</Definition>
        <Parameter name="year" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="month" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="dayOfMonth" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="hour" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="minute" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="second" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="DateAndTime" />
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;month&lt;/code&gt; is not between 1 and 12 inclusive &lt;code&gt;.&lt;/p&gt;&lt;p&gt; dayOfMonth&lt;/code&gt; greater than the number of days in the month &lt;code&gt;month&lt;/code&gt; of year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar.&lt;/p&gt;&lt;p&gt; &lt;code&gt;hour&lt;/code&gt; is not between 0 and 23 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;minute&lt;/code&gt; is not between 0 and 59 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;second&lt;/code&gt; is not greater than or equal to 0 and strictly less than 60.&lt;/p&gt;&lt;p&gt; the time specified does not exist.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="year:month:day:hour:minute:second:offset:" docId="5.8.4.3" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfMonth&lt;/code&gt; of the month &lt;code&gt;month&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar offset from UTC by &lt;code&gt;offset&lt;/code&gt; .</Synopsis>
        <Definition protocol="DateAndTime factory">&lt;p&gt;Answer the least &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfMonth&lt;/code&gt; of the month &lt;code&gt;month&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar offset from UTC by &lt;code&gt;offset&lt;/code&gt; . The &lt;code&gt;second&lt;/code&gt; must be a &amp;lt;number&amp;gt; greater than or equal to 0 and strictly less than 60. The &lt;code&gt;minute&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 59 inclusive. The &lt;code&gt;hour&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 23 inclusive. The &lt;code&gt;day&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and&lt;/p&gt;&lt;p&gt; 31 inclusive. The &lt;code&gt;month&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and 12 inclusive. An implementation may not impose any limits on the year other than those imposed on &amp;lt;integer&amp;gt; constants.&lt;/p&gt;&lt;p&gt; It is possible that the time specified does not exist in the local time defined by the implementation. If there is a time change such that the &lt;em&gt;local time&lt;/em&gt; is set forward and the time specified is in the interregnum, then that time does not exist in the local time. For example if at 02:00 in California on April 26, 1997 there is a time change that sets local time forward one hour, then the local time 02:30  in California does not exist. Conversely if there is a time change that sets the &lt;em&gt;local time&lt;/em&gt; back there are times which are ambiguous. For example if instead of setting the local time forward from 02:00 to 03:00 it is set back to 01:00 the the local time 01:30 in California is ambiguious. The result is the least &amp;lt;DateAndTime&amp;gt; that conforms to the given parameters.&lt;/p&gt;</Definition>
        <Parameter name="year" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="month" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="dayOfMonth" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="hour" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="minute" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="second" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="offset" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="DateAndTime" />
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;month&lt;/code&gt; is not between 1 and 12 inclusive &lt;code&gt;.&lt;/p&gt;&lt;p&gt; dayOfMonth&lt;/code&gt; greater than the number of days in the month &lt;code&gt;month&lt;/code&gt; of year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar.&lt;/p&gt;&lt;p&gt; &lt;code&gt;hour&lt;/code&gt; is not between 0 and 23 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;minute&lt;/code&gt; is not between 0 and 59 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;second&lt;/code&gt; is not greater than or equal to 0 and strictly less than 60.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="year:day:hour:minute:second:" docId="5.8.4.4" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfYear&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar in local time.</Synopsis>
        <Definition protocol="DateAndTime factory">&lt;p&gt;Answer the least &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfYear&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar in the local time specified by the implementation. The &lt;code&gt;second&lt;/code&gt; must be a &amp;lt;number&amp;gt; greater than or equal to 0 and strictly less than 60. The &lt;code&gt;minute&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 59 inclusive. The &lt;code&gt;hour&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 23 inclusive. The &lt;code&gt;day&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and 366 inclusive. An implementation may not impose any limits on the year other than those imposed on &amp;lt;integer&amp;gt; constants.&lt;/p&gt;&lt;p&gt; It is possible that the time specified does not exist in the local time specified by the implementation. If there is a time change such that the local time is set forward and the time specified is in the interregnum, then that time does not exist in the local time. For example if at 02:00 in California on April 26, 1997 there is a time change that sets local time forward one hour, then the local time 02:30  in California does not exist. Conversely if there is a time change that sets the &lt;em&gt;local time&lt;/em&gt; back there are times which are ambiguous. For example if instead of setting the local time forward from&lt;/p&gt;&lt;p&gt; 02:00 to 03:00 it is set back to 01:00 the the local time 01:30 in California is ambiguious. The result is the least &amp;lt;DateAndTime&amp;gt; that conforms to the given parameters.&lt;/p&gt;&lt;p&gt; It is worth noting that the year 1 B.C. is year 0 in the astronomical Gregorian calendar. Similarly the year 2 B.C. is year -1 in the astronomical Gregorian calendar and so on. The year 1 A.D. is year 1 in the astronomical Gregorian calendar.&lt;/p&gt;</Definition>
        <Parameter name="year" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="dayOfYear" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="hour" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="minute" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="second" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="DateAndTime" />
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;month&lt;/code&gt; is not between 1 and 12 inclusive &lt;code&gt;.&lt;/p&gt;&lt;p&gt; dayOfYear&lt;/code&gt; greater than the number of days in the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar.&lt;/p&gt;&lt;p&gt; &lt;code&gt;hour&lt;/code&gt; is not between 0 and 23 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;minute&lt;/code&gt; is not between 0 and 59 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;second&lt;/code&gt; is not greater than or equal to 0 and strictly less than 60.&lt;/p&gt;&lt;p&gt; the time specified does not exist.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="year:day:hour:minute:second:offset:" docId="5.8.4.5" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfYear&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar offset from UTC by &lt;code&gt;offset&lt;/code&gt; .</Synopsis>
        <Definition protocol="DateAndTime factory">&lt;p&gt;Answer the least &amp;lt;DateAndTime&amp;gt; which is the second &lt;code&gt;second&lt;/code&gt; of the minute &lt;code&gt;minute&lt;/code&gt; of the hour &lt;code&gt;hour&lt;/code&gt; of the day &lt;code&gt;dayOfYear&lt;/code&gt; of the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar in the local time of the &lt;em&gt;local time&lt;/em&gt; specified by the implementation. The &lt;code&gt;second&lt;/code&gt; must be a &amp;lt;number&amp;gt; greater than or equal to 0 and strictly less than 60. The &lt;code&gt;minute&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 59 inclusive. The &lt;code&gt;hour&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 0 and 23 inclusive. The &lt;code&gt;day&lt;/code&gt; must be an &amp;lt;integer&amp;gt; between 1 and 366 inclusive. An implementation may not impose any limits on the year other than those imposed on &amp;lt;integer&amp;gt; constants.&lt;/p&gt;&lt;p&gt; It is possible that the time specified does not exist in the local time defined by the implementation. If there is a time change such that the &lt;em&gt;local time&lt;/em&gt; is set forward and the time specified is in the interregnum, then that time does not exist in the local time. For example if at 02:00 in California on April 26, 1997 there is a time change that sets local time forward one hour, then the local time 02:30  in California does not exist. Conversely if there is a time change that sets the &lt;em&gt;local time&lt;/em&gt; back there are times which are ambiguous. For example if instead of setting the local time forward from 02:00 to 03:00 it is set back to 01:00 the the local time 01:30 in California is ambiguious. The result is the least &amp;lt;DateAndTime&amp;gt; that conforms to the given parameters.&lt;/p&gt;</Definition>
        <Parameter name="year" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="dayOfYear" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="hour" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="minute" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Parameter name="second" aliasing="unspecified">
          <Protocol name="number" />
        </Parameter>
        <Parameter name="offset" aliasing="unspecified">
          <Protocol name="Duration" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="DateAndTime" />
        </ReturnValue>
        <Errors>&lt;p&gt;&lt;code&gt;month&lt;/code&gt; is not between 1 and 12 inclusive &lt;code&gt;.&lt;/p&gt;&lt;p&gt; dayOfYear&lt;/code&gt; greater than the number of days in the year &lt;code&gt;year&lt;/code&gt; of the astronomical Gregorian calendar.&lt;/p&gt;&lt;p&gt; &lt;code&gt;hour&lt;/code&gt; is not between 0 and 23 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;minute&lt;/code&gt; is not between 0 and 59 inclusive.&lt;/p&gt;&lt;p&gt; &lt;code&gt;second&lt;/code&gt; is not greater than or equal to 0 and strictly less than the number of seconds in the minute specified.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="now" docId="5.8.4.6" refined="false">
        <Synopsis>Answer a &amp;lt;DateAndTime&amp;gt; representing the current date and time.</Synopsis>
        <Definition protocol="DateAndTime factory">Answer a &amp;lt;DateAndTime&amp;gt; representing the current date and time in the &lt;em&gt;local time&lt;/em&gt; specified by the implementation.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="DateAndTime" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="sequencedStream" docId="5.9.1" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>An object conforming to &amp;lt;sequencedStream&amp;gt; has a finite number of &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence&lt;/em&gt; &lt;em&gt;values&lt;/em&gt; . It maintains a position on its &lt;em&gt;sequence values&lt;/em&gt; and allows the position to be altered.</Description>
      <Message selector="close" docId="5.9.1.1" refined="false">
        <Synopsis>Disassociate a stream from its backing store.</Synopsis>
        <Definition protocol="sequencedStream">If the receiver is a &lt;em&gt;write-back stream&lt;/em&gt; update its &lt;em&gt;stream backing store&lt;/em&gt; as if the message #flush was sent to the receiver. Then eliminate any association between the receiver and its stream backing store. Any system resources associated with the association should be released. The effect of sending any message to the receiver subsequent to this message is undefined.</Definition>
      </Message>
      <Message selector="contents" docId="5.9.1.2" refined="false">
        <Synopsis>Returns a collection containing the complete contents of the stream.</Synopsis>
        <Definition protocol="sequencedStream">Returns a collection that contains the receiver's &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; , in order. The size of the collection is the sum of the sizes of the &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
      <Message selector="isEmpty" docId="5.9.1.3" refined="false">
        <Synopsis>Returns a Boolean indicating whether there are any &lt;em&gt;sequence values&lt;/em&gt; in the receiver.</Synopsis>
        <Definition protocol="sequencedStream">Returns &lt;em&gt;true&lt;/em&gt; if both the set of &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; of the receiver are empty. Otherwise returns &lt;em&gt;false.&lt;/em&gt;</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="position" docId="5.9.1.4" refined="false">
        <Synopsis>Returns the current position of the stream.</Synopsis>
        <Definition protocol="sequencedStream">Returns the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past sequence values&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="integer" />
        </ReturnValue>
      </Message>
      <Message selector="position:" docId="5.9.1.5" refined="false">
        <Synopsis>Sets the current position in a stream of values.</Synopsis>
        <Definition protocol="sequencedStream">&lt;p&gt;If the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past sequence values&lt;/em&gt; is smaller than &lt;code&gt;amount&lt;/code&gt; , move objects in sequence from the front of the receiver's &lt;em&gt;future sequence values&lt;/em&gt; to the back of th receiver's &lt;em&gt;past sequence values&lt;/em&gt; until the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; is equal to &lt;code&gt;amount&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past sequence values&lt;/em&gt; is greater than &lt;code&gt;amount&lt;/code&gt; , move objects in sequence from the back of the receiver's &lt;em&gt;past sequence values&lt;/em&gt; to the front of th receiver's &lt;em&gt;future sequence values&lt;/em&gt; until the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; is equal to &lt;code&gt;amount&lt;/code&gt; .&lt;/p&gt;&lt;p&gt; If the number of &lt;em&gt;sequence values&lt;/em&gt; in the receiver's &lt;em&gt;past sequence values&lt;/em&gt; is equal to &lt;code&gt;amount&lt;/code&gt; no action is taken.&lt;/p&gt;</Definition>
        <Parameter name="amount" aliasing="unspecified">
          <Protocol name="integer" />
        </Parameter>
        <Errors>&lt;p&gt;If &lt;code&gt;amount&lt;/code&gt; is negative.&lt;/p&gt;&lt;p&gt; If the receiver has any &lt;em&gt;sequence values&lt;/em&gt; and &lt;code&gt;amount&lt;/code&gt; is greater than or equal to the total number of &lt;em&gt;sequence values&lt;/em&gt; of the receiver.&lt;/p&gt;</Errors>
      </Message>
      <Message selector="reset" docId="5.9.1.6" refined="false">
        <Synopsis>Resets the position of the receiver to be at the beginning of the stream of values.</Synopsis>
        <Definition protocol="sequencedStream">Sets the receiver's &lt;em&gt;future sequence values&lt;/em&gt; to be the current &lt;em&gt;past sequence values&lt;/em&gt; appended with the current &lt;em&gt;future sequence values&lt;/em&gt; . Make the receiver's &lt;em&gt;past sequence values&lt;/em&gt; be empty.</Definition>
      </Message>
      <Message selector="setToEnd" docId="5.9.1.7" refined="false">
        <Synopsis>Set the position of the stream to its end.</Synopsis>
        <Definition protocol="sequencedStream">All of the &lt;em&gt;receiver's future sequence values&lt;/em&gt; are appended, in sequence, to the receiver's &lt;em&gt;past&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; . The receiver then has no &lt;em&gt;future sequence values&lt;/em&gt; .</Definition>
      </Message>
    </Protocol>
    <Protocol name="gettableStream" docId="5.9.2" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>An object conforming to &amp;lt;gettableStream&amp;gt; can read objects from its &lt;em&gt;future sequence values&lt;/em&gt; .</Description>
      <Message selector="atEnd" docId="5.9.2.1" refined="false">
        <Synopsis>Returns a Boolean indicating whether the receiver is at the end of its values.</Synopsis>
        <Definition protocol="gettableStream">Return &lt;em&gt;true&lt;/em&gt; if the receiver has no &lt;em&gt;future sequence values&lt;/em&gt; available for reading. Return &lt;em&gt;false&lt;/em&gt; otherwise.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="do:" docId="5.9.2.2" refined="false">
        <Synopsis>Evaluates the argument with each receiver &lt;em&gt;future sequence value&lt;/em&gt; , terminating evaluation when there are no more &lt;em&gt;future sequence values&lt;/em&gt; .</Synopsis>
        <Definition protocol="gettableStream">Each member of the receiver's &lt;em&gt;future sequence values&lt;/em&gt; is, in turn, removed from the future sequence values; appended to the past sequence values; and, passed as the argument to an evaluation of &lt;code&gt;operand&lt;/code&gt; . The argument, &lt;code&gt;operation&lt;/code&gt; , is evaluated as if sent the message &lt;code&gt;#value&lt;/code&gt; :. The number of evaluations is equal to the initial size of the receiver's &lt;em&gt;future sequence values&lt;/em&gt; . If there initially are no &lt;em&gt;future sequence values&lt;/em&gt; , &lt;code&gt;operation&lt;/code&gt; is not evaluated. The future sequence values are used as arguments in their sequence order. The result is undefined if any evaluation of &lt;code&gt;operand&lt;/code&gt; changes the receiver's &lt;em&gt;future sequence values&lt;/em&gt;</Definition>
        <Parameter name="operation" aliasing="uncaptured">
          <Protocol name="monadicValuable" />
        </Parameter>
      </Message>
      <Message selector="next" docId="5.9.2.3" refined="false">
        <Synopsis>Return the next object in the receiver.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;The first object is removed from the receiver's &lt;em&gt;future sequence values&lt;/em&gt; and appended to the end of the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . That object is returned as the value of the message. The returned object must conform to the receiver's &lt;em&gt;sequence value type&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; The result is undefined if there the receiver has no &lt;em&gt;future sequence values&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="next:" docId="5.9.2.4" refined="false">
        <Synopsis>Returns a collection of the next &lt;code&gt;amount&lt;/code&gt; objects in the stream.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;A number of objects equal to &lt;code&gt;amount&lt;/code&gt; are removed from the receiver's &lt;em&gt;future sequence values&lt;/em&gt; and appended, in order, to the end of the receiver's &lt;em&gt;past sequence values.&lt;/em&gt; A collection whose elements consist of those objects, in the same order, is returned. If amount is equal to 0 an empty collection is returned.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;amount&lt;/code&gt; is larger than the number of objects in the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Parameter name="amount" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>&lt;code&gt;amount&lt;/code&gt; &amp;lt; 0</Errors>
      </Message>
      <Message selector="nextLine" docId="5.9.2.5" refined="false">
        <Synopsis>Reads the next line from the stream.</Synopsis>
        <Definition protocol="gettableStream">Each object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; up to and including the first occurrence of the objects that constitute an implementation defined end-of-line sequence is removed from the &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; and appended to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . All of the transfered objects, except the end-of-line sequence objects, are collected, in order, as the elements of a string that is the return value. The result is undefined if there are no &lt;em&gt;future sequence values&lt;/em&gt; in the receiver or if the &lt;em&gt;future sequence values&lt;/em&gt; do not include the end-of-line sequence.</Definition>
        <ReturnValue aliasing="new">
          <Protocol name="readableString" />
        </ReturnValue>
        <Errors>If any of the &lt;em&gt;future sequence values&lt;/em&gt; to be returned do not conform to the protocol &amp;lt;Character&amp;gt;.</Errors>
      </Message>
      <Message selector="nextMatchFor:" docId="5.9.2.6" refined="false">
        <Synopsis>Reads the next object from the stream and returns &lt;em&gt;true&lt;/em&gt; if the object is &lt;em&gt;equivalent&lt;/em&gt; to the argument and &lt;em&gt;false&lt;/em&gt; if not.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;The first object is removed from the receiver's &lt;em&gt;future sequence value&lt;/em&gt; and appended to the end of the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . The value that would result from sending &lt;code&gt;#=&lt;/code&gt; to the object with &lt;code&gt;anObject&lt;/code&gt; as the argument is returned.&lt;/p&gt;&lt;p&gt; The results are undefined if there are no &lt;em&gt;future sequence values&lt;/em&gt; in the receiver.&lt;/p&gt;</Definition>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="peek" docId="5.9.2.7" refined="false">
        <Synopsis>Returns the next object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; without advancing the receiver's position. Returns &lt;em&gt;nil&lt;/em&gt; if the receiver is at end of stream.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;Returns the first object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; . The object is not removed from the &lt;em&gt;future sequence values&lt;/em&gt; . The returned object must conform to the receiver's &lt;em&gt;sequence value type&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; Returns &lt;em&gt;nil&lt;/em&gt; if the receiver has no &lt;em&gt;future sequence values&lt;/em&gt; . The return value will also be &lt;em&gt;nil&lt;/em&gt; if the first future sequence object is &lt;em&gt;nil&lt;/em&gt; .&lt;/p&gt;</Definition>
        <ReturnValue aliasing="state">
          <Protocol name="Object" />
        </ReturnValue>
      </Message>
      <Message selector="peekFor:" docId="5.9.2.8" refined="false">
        <Synopsis>Peeks at the next object in the stream and returns &lt;em&gt;true&lt;/em&gt; if it matches the argument, and &lt;em&gt;false&lt;/em&gt; if not.</Synopsis>
        <Definition protocol="gettableStream">Returns the result of sending &lt;code&gt;#=&lt;/code&gt; to the first object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; with &lt;code&gt;anObject&lt;/code&gt; as the argument. Returns &lt;em&gt;false&lt;/em&gt; if the receiver has no &lt;em&gt;future sequence values&lt;/em&gt; .</Definition>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="skip:" docId="5.9.2.9" refined="false">
        <Synopsis>Skips the next &lt;code&gt;amount&lt;/code&gt; objects in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; .</Synopsis>
        <Definition protocol="gettableStream">A number of objects equal to the lesser of &lt;code&gt;amount&lt;/code&gt; and the size of the receiver's &lt;em&gt;future sequence&lt;/em&gt; &lt;em&gt;values&lt;/em&gt; are removed from the receiver's &lt;em&gt;future sequence values&lt;/em&gt; and appended, in order, to the end of the receiver's &lt;em&gt;past sequence values&lt;/em&gt; &lt;b&gt;.&lt;/b&gt;</Definition>
        <Parameter name="amount" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
      </Message>
      <Message selector="skipTo:" docId="5.9.2.10" refined="false">
        <Synopsis>Sets the stream to read the object just after the next occurrence of the argument and returns &lt;em&gt;true&lt;/em&gt; . If the argument is not found before the end of the stream is encountered, &lt;em&gt;false&lt;/em&gt; is returned.</Synopsis>
        <Definition protocol="gettableStream">Each object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; up to and including the first occurrence of an object that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;anObject&lt;/code&gt; is removed from the &lt;em&gt;future sequence values&lt;/em&gt; and appended to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . If an object that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;anObject&lt;/code&gt; is not found in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; , all of the objects in &lt;em&gt;future sequence values&lt;/em&gt; are removed from &lt;em&gt;future sequence values&lt;/em&gt; and appended to &lt;em&gt;past sequence values&lt;/em&gt; . If an object equivalent to anObject is not found &lt;em&gt;false&lt;/em&gt; is returned. Otherwise return &lt;em&gt;true&lt;/em&gt; .</Definition>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="upTo:" docId="5.9.2.11" refined="false">
        <Synopsis>Returns a collection of all of the objects in the receiver up to, but not including, the next occurrence of the argument. Sets the stream to read the object just after the next occurrence of the argument. If the argument is not found and the end of the stream is encountered, an ordered collection of the objects read is returned.</Synopsis>
        <Definition protocol="gettableStream">Each object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; up to and including the first occurrence of an object that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;anObject&lt;/code&gt; is removed from the &lt;em&gt;future sequence values&lt;/em&gt; and appended to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . A collection, containing, in order, all of the transferred objects except the object (if any) that is equivalent to &lt;code&gt;anObject&lt;/code&gt; is returned. If the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; is initially empty, an empty collection is returned.</Definition>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="collectionStream" docId="5.9.3" abstract="true">
      <ConformsTo protocol="sequencedStream" />
      <Description>An object conforming to &amp;lt;collectionStream&amp;gt; has a &amp;lt;sequencedReadableCollection&amp;gt; as its &lt;em&gt;stream&lt;/em&gt; &lt;em&gt;backing store&lt;/em&gt; .</Description>
      <Message selector="contents" docId="5.9.3.1" refined="false">
        <Synopsis>Returns a collection containing the complete contents of the stream.</Synopsis>
        <Definition protocol="sequencedStream">Returns a collection that contains the receiver's &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; , in order. The size of the collection is the sum of the sizes of the &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; .</Definition>
        <Refinement protocol="collectionStream">It is unspecified whether or not the returned collection is the same object as the backing store collection. However, if the returned collection is not the same object as &lt;em&gt;the stream backing store&lt;/em&gt; collection then the class of the returned collection is the same class as would be returned if the message # &lt;code&gt;select:&lt;/code&gt; was sent to the backing store collection.</Refinement>
        <ReturnValue aliasing="unspecified">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="puttableStream" docId="5.9.4" abstract="true">
      <ConformsTo protocol="Object" />
      <Description>An object conforming to &amp;lt;puttableStream&amp;gt; allows objects to be added to its &lt;em&gt;past sequence values&lt;/em&gt; .</Description>
      <Message selector="cr" docId="5.9.4.1" refined="false">
        <Synopsis>Writes an end-of-line sequence to the receiver.</Synopsis>
        <Definition protocol="puttableStream">A sequence of character objects that constitute the implementation-defined end-of-line sequence is added to the receiver in the same manner as if the message &lt;code&gt;#nextPutAll:&lt;/code&gt; was sent to the receiver with an argument string whose elements are the sequence of characters.</Definition>
        <Errors>It is erroneous if any element of the end-of-line sequence is an object that does not conform to the receiver's &lt;em&gt;sequence value type&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="flush" docId="5.9.4.2" refined="false">
        <Synopsis>Update a stream's backing store.</Synopsis>
        <Definition protocol="puttableStream">&lt;p&gt;Upon return, if the receiver is a &lt;em&gt;write-back stream,&lt;/em&gt; the state of the &lt;em&gt;stream backing store&lt;/em&gt; must be consistent with the current state of the receiver.&lt;/p&gt;&lt;p&gt; If the receiver is not a &lt;em&gt;write-back stream&lt;/em&gt; , the effect of this message is unspecified.&lt;/p&gt;</Definition>
      </Message>
      <Message selector="nextPut:" docId="5.9.4.3" refined="false">
        <Synopsis>Writes the argument to the stream.</Synopsis>
        <Definition protocol="puttableStream">Appends &lt;code&gt;anObject&lt;/code&gt; to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . If the receiver's &lt;em&gt;future sequence&lt;/em&gt; &lt;em&gt;values&lt;/em&gt; is not empty, removes its first object.</Definition>
        <Parameter name="anObject" aliasing="captured">
          <Protocol name="Object" />
        </Parameter>
        <Errors>It is erroneous if &lt;code&gt;anObject&lt;/code&gt; is an object that does not conform to the receiver's &lt;em&gt;sequence value&lt;/em&gt; &lt;em&gt;type&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="nextPutAll:" docId="5.9.4.4" refined="false">
        <Synopsis>Enumerates the argument, adding each element to the receiver</Synopsis>
        <Definition protocol="puttableStream">&lt;p&gt;Has the effect of enumerating the &lt;code&gt;aCollection&lt;/code&gt; with the message &lt;code&gt;#do:&lt;/code&gt; and adding each element to the receiver with &lt;code&gt;#nextPut:&lt;/code&gt; . That is,&lt;/p&gt;&lt;p&gt; &lt;code&gt;aCollection do: [:each | receiver nextPut: each]&lt;/p&gt;</Definition>
        <Parameter name="aCollection" aliasing="uncaptured">
          <Protocol name="collection" />
        </Parameter>
        <Errors>It is erroneous if any element of &lt;code&gt;aCollection&lt;/code&gt; is an object that does not conform to the receiver's &lt;em&gt;sequence value type&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="space" docId="5.9.4.5" refined="false">
        <Synopsis>Writes a space character to the receiver.</Synopsis>
        <Definition protocol="puttableStream">The effect is the same as sending the message &lt;code&gt;#nextPut:&lt;/code&gt; to the receiver with an argument that is the object that is the value returned when the message # &lt;code&gt;space&lt;/code&gt; is sent to the standard global &lt;code&gt;Character&lt;/code&gt; .</Definition>
        <Errors>It is erroneous if the space character is an object that does not conform to the receiver's &lt;em&gt;sequence&lt;/em&gt; &lt;em&gt;value type&lt;/em&gt; .</Errors>
      </Message>
      <Message selector="tab" docId="5.9.4.6" refined="false">
        <Synopsis>Writes a tab character to the receiver.</Synopsis>
        <Definition protocol="puttableStream">The effect is the same as sending the message &lt;code&gt;#nextPut:&lt;/code&gt; to the receiver with an argument that is the object that is the value returned when the message # &lt;code&gt;tab&lt;/code&gt; is sent to the standard global &lt;code&gt;Character&lt;/code&gt; .</Definition>
        <Errors>It is erroneous if the tab character is an object that does not conform to the receiver's &lt;em&gt;sequence&lt;/em&gt; &lt;em&gt;value type&lt;/em&gt; .</Errors>
      </Message>
    </Protocol>
    <Protocol name="ReadStream" docId="5.9.5" abstract="false">
      <ConformsTo protocol="gettableStream" />
      <ConformsTo protocol="collectionStream" />
      <Description>An object conforming to &amp;lt;ReadStream&amp;gt; has a positionable sequence of values that can be read. The &lt;em&gt;sequence values&lt;/em&gt; are provided by a sequenced collection that serves as &lt;em&gt;the stream backing&lt;/em&gt; &lt;em&gt;store&lt;/em&gt; .</Description>
      <Message selector="next:" docId="5.9.5.1" refined="false">
        <Synopsis>Returns a collection of the next &lt;code&gt;amount&lt;/code&gt; objects in the stream.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;A number of objects equal to &lt;code&gt;amount&lt;/code&gt; are removed from the receiver's &lt;em&gt;future sequence values&lt;/em&gt; and appended, in order, to the end of the receiver's &lt;em&gt;past sequence values.&lt;/em&gt; A collection whose elements consist of those objects, in the same order, is returned. If amount is equal to 0 an empty collection is returned.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;amount&lt;/code&gt; is larger than the number of objects in the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="ReadStream">The result collection will conform to the same protocols as the object that would result if the message # &lt;code&gt;select:&lt;/code&gt; was sent to the object that serves as the &lt;em&gt;stream backing store&lt;/em&gt; .</Refinement>
        <Parameter name="amount" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>amount &amp;lt; 0</Errors>
      </Message>
      <Message selector="upTo:" docId="5.9.5.2" refined="false">
        <Synopsis>Returns a collection of all of the objects in the receiver up to, but not including, the next occurrence of the argument. Sets the stream to read the object just after the next occurrence of the argument. If the argument is not found and the end of the stream is encountered, an ordered collection of the objects read is returned.</Synopsis>
        <Definition protocol="gettableStream">Each object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; up to and including the first occurrence of an object that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;anObject&lt;/code&gt; is removed from the &lt;em&gt;future sequence values&lt;/em&gt; and appended to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . A collection, containing, in order, all of the transferred objects except the object (if any) that is equivalent to &lt;code&gt;anObject&lt;/code&gt; is returned. If the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; is initially empty, an empty collection is returned.</Definition>
        <Refinement protocol="ReadStream">The result collection will conform to the same protocols as the object that would result if the message # &lt;code&gt;select:&lt;/code&gt; was sent to the object that serves as the &lt;em&gt;stream backing store&lt;/em&gt; .</Refinement>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="WriteStream" docId="5.9.6" abstract="false">
      <ConformsTo protocol="puttableStream" />
      <ConformsTo protocol="collectionStream" />
      <Description>An object conforming to &amp;lt;WriteStream&amp;gt; has a positionable sequence of values to which new values may be written. The initial &lt;em&gt;sequence values&lt;/em&gt; are provided by a collection that serves as &lt;em&gt;the&lt;/em&gt; &lt;em&gt;stream backing store&lt;/em&gt; . It is implementation defined whether a &amp;lt;WriteStream&amp;gt; is a &lt;em&gt;write-back&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt; . Even if a &amp;lt;WriteStream&amp;gt; is not a &lt;em&gt;write-back stream&lt;/em&gt; , its associated collection may be subject to modification in an unspecified manner as long as it is associated with the stream.</Description>
    </Protocol>
    <Protocol name="ReadWriteStream" docId="5.9.7" abstract="false">
      <ConformsTo protocol="ReadStream" />
      <ConformsTo protocol="WriteStream" />
      <Description>An object conforming to &amp;lt;ReadWriteStream&amp;gt; can read from its &lt;em&gt;future sequence values&lt;/em&gt; or write to its &lt;em&gt;past sequence values&lt;/em&gt; . The &lt;em&gt;sequence values&lt;/em&gt; are provided by a collection that serves as &lt;em&gt;the&lt;/em&gt; &lt;em&gt;stream backing store&lt;/em&gt; . It is implementation defined whether a &amp;lt;ReadWriteStream&amp;gt; is &lt;em&gt;a write-back&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt; . Even if a &amp;lt;ReadWriteStream&amp;gt; is not a &lt;em&gt;write-back stream&lt;/em&gt; , its associated collection may be subject to modification in an unspecified manner as long as it is associated with the stream.</Description>
    </Protocol>
    <Protocol name="Transcript" docId="5.9.8" abstract="false">
      <ConformsTo protocol="puttableStream" />
      <Description>An object conforming to &amp;lt;Transcript&amp;gt; is a &amp;lt;puttableStream&amp;gt; for logging status messages from Smalltalk programs. The &lt;em&gt;sequence value type&lt;/em&gt; of &amp;lt;Transcript&amp;gt; is &amp;lt;Character&amp;gt;. There may be an implementation defined &lt;em&gt;stream backing store&lt;/em&gt; that receives characters written to the stream in an implementatiuon defined manner.</Description>
      <StandardGlobal name="Transcript">
        <Description>Conforms to the protocol &amp;lt;Transcript&amp;gt;. Its language element type is unspecified. This is a &amp;lt;Transcript&amp;gt; that is always available to output textual messages in an implementtion defined manner.</Description>
      </StandardGlobal>
    </Protocol>
    <Protocol name="ReadStream factory" docId="5.9.9" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>&amp;lt;ReadStream factory&amp;gt; provides for the creation of objects conforming to the &amp;lt;ReadStream&amp;gt; protocol whose sequence values are supplied by a collection.</Description>
      <StandardGlobal name="ReadStream">
        <Description>Conforms to the protocol &amp;lt;ReadStream factory&amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;ReadStream&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="on:" docId="5.9.9.1" refined="false">
        <Synopsis>Returns a stream that reads from the given collection.</Synopsis>
        <Definition protocol="ReadStream factory">Returns an object conforming to &amp;lt;ReadStream&amp;gt; whose &lt;em&gt;future sequence values&lt;/em&gt; initially consist of the elements of &lt;code&gt;aCollection&lt;/code&gt; &lt;b&gt;&lt;/b&gt;and which initially has no &lt;em&gt;past sequence values&lt;/em&gt; . The ordering of the &lt;em&gt;sequence values&lt;/em&gt; is the same as the ordering used by # &lt;code&gt;do&lt;/code&gt; : when sent to &lt;code&gt;aCollection&lt;/code&gt; . The &lt;em&gt;stream backing store&lt;/em&gt; of the returned object is &lt;code&gt;aCollection&lt;/code&gt; .</Definition>
        <Parameter name="aCollection" aliasing="captured">
          <Protocol name="sequencedReadableCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ReadStream" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="ReadWriteStream factory" docId="5.9.10" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>&amp;lt;ReadWriteStreamfactory&amp;gt; provides for the creation of objects conforming to the &amp;lt;WriteStream&amp;gt; protocol whose sequence values are supplied by a collection.</Description>
      <StandardGlobal name="ReadWriteStream">
        <Description>Conforms to the protocol &amp;lt;ReadWriteStream factory&amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;ReadWriteStream&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="with:" docId="5.9.10.1" refined="false">
        <Synopsis>Returns a stream that reads the elements of the given collection and can write new elements.</Synopsis>
        <Definition protocol="ReadWriteStream factory">Returns an object conforming to &amp;lt;ReadWriteStream&amp;gt; whose &lt;em&gt;past sequence values&lt;/em&gt; initially consist of the elements of &lt;code&gt;aCollection&lt;/code&gt; &lt;b&gt;&lt;/b&gt;and which initially has no &lt;em&gt;future sequence values&lt;/em&gt; . The ordering of the &lt;em&gt;sequence values&lt;/em&gt; is the same as the ordering used by # &lt;code&gt;do&lt;/code&gt; : when sent to &lt;code&gt;aCollection&lt;/code&gt; . The &lt;em&gt;stream backing store&lt;/em&gt; of the returned object is &lt;code&gt;aCollection&lt;/code&gt; . The &lt;em&gt;sequence value type&lt;/em&gt; of the write stream is the element type of &lt;code&gt;aCollection&lt;/code&gt; . Any restrictions on objects that may be elements of &lt;code&gt;aCollection&lt;/code&gt; also apply to the stream's &lt;em&gt;sequence elements&lt;/em&gt; .</Definition>
        <Parameter name="aCollection" aliasing="captured">
          <Protocol name="sequencedCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="ReadWriteStream" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="WriteStream factory" docId="5.9.11" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>&amp;lt;WriteStream factory&amp;gt; provides for the creation of objects conforming to the &amp;lt;WriteStream&amp;gt; protocol whose sequence values are supplied by a collection.</Description>
      <StandardGlobal name="WriteStream">
        <Description>Conforms to the protocol &amp;lt;WriteStream factory &amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;WriteStream&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="with:" docId="5.9.11.1" refined="false">
        <Synopsis>Returns a stream that appends to the given collection.</Synopsis>
        <Definition protocol="WriteStream factory">Returns an object conforming to &amp;lt;WriteStream&amp;gt; whose &lt;em&gt;past sequence values&lt;/em&gt; initially consist of the elements of &lt;code&gt;aCollection&lt;/code&gt; &lt;b&gt;&lt;/b&gt;and which initially has no &lt;em&gt;future sequence values&lt;/em&gt; . The ordering of the &lt;em&gt;sequence values&lt;/em&gt; is the same as the ordering used by # &lt;code&gt;do&lt;/code&gt; : when sent to &lt;code&gt;aCollection&lt;/code&gt; . The &lt;em&gt;stream backing store&lt;/em&gt; of the returned object is &lt;code&gt;aCollection&lt;/code&gt; . The &lt;em&gt;sequence value type&lt;/em&gt; of the write stream is the element type of &lt;code&gt;aCollection&lt;/code&gt; . Any restrictions on objects that may be elements of &lt;code&gt;aCollection&lt;/code&gt; also apply to the stream's &lt;em&gt;sequence elements&lt;/em&gt; .</Definition>
        <Parameter name="aCollection" aliasing="captured">
          <Protocol name="sequencedCollection" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="WriteStream" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="FileStream" docId="5.10.1" abstract="false">
      <ConformsTo protocol="sequencedStream" />
      <Description>&lt;p&gt;Provides protocol for streams over external files. The external file serves as &lt;em&gt;the stream backing&lt;/em&gt; &lt;em&gt;store&lt;/em&gt; . When objects are read or written from a file stream they must be translated from or two an external data representation. File streams have an &lt;em&gt;external stream type&lt;/em&gt; that is specified when the stream is created. The &lt;em&gt;external stream type&lt;/em&gt; defines the data translation and the &lt;em&gt;sequence value&lt;/em&gt; &lt;em&gt;type&lt;/em&gt; for the stream. &lt;em&gt;External stream types&lt;/em&gt; are specified using &amp;lt;symbol&amp;gt; objects. The standard defines the following &lt;em&gt;external stream types&lt;/em&gt; :&lt;/p&gt;&lt;p&gt; &lt;code&gt;#'binary'&lt;/code&gt; The external data is treated as sequence of 8-bit bytes. The &lt;em&gt;sequence&lt;/em&gt; &lt;em&gt;value type&lt;/em&gt; is &amp;lt;integer&amp;gt; with values restricted to the range 0 to 255.&lt;/p&gt;&lt;p&gt; &lt;code&gt;#'text'&lt;/code&gt; The external data is treated as a sequenced of 8-bit characters encoded using an implementation defined external character set.  The &lt;em&gt;sequence&lt;/em&gt; &lt;em&gt;value type&lt;/em&gt; is &amp;lt;Character&amp;gt; restricted to those specific characters that may be represented in the external character set.&lt;/p&gt;&lt;p&gt; Implementations may define other &lt;em&gt;external stream types&lt;/em&gt; .&lt;/p&gt;&lt;p&gt; &lt;b&gt;Rational&lt;/b&gt;&lt;/p&gt;</Description>
      <Message selector="contents" docId="5.10.1.1" refined="false">
        <Synopsis>Returns a collection containing the complete contents of the stream.</Synopsis>
        <Definition protocol="sequencedStream">Returns a collection that contains the receiver's &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; , in order. The size of the collection is the sum of the sizes of the &lt;em&gt;past&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; .</Definition>
        <Refinement protocol="FileStream">If the &lt;em&gt;external stream type&lt;/em&gt; is #'binary' the returned collection conforms to &amp;lt;ByteArray&amp;gt;. If the &lt;em&gt;external stream type&lt;/em&gt; is #'text' the returned collection conforms to &amp;lt;String&amp;gt;.</Refinement>
        <ReturnValue aliasing="new">
          <Protocol name="ByteArray" />
          <Description>&amp;lt;String&amp;gt; new</Description>
        </ReturnValue>
      </Message>
      <Message selector="externalType" docId="5.10.1.2" refined="false">
        <Synopsis>Returns a symbol that identifies the &lt;em&gt;external stream type&lt;/em&gt; of the receiver.</Synopsis>
        <Definition protocol="FileStream">Return the symbol that identifies the &lt;em&gt;external stream type&lt;/em&gt; of the receiver.</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="symbol" />
        </ReturnValue>
      </Message>
      <Message selector="isBinary" docId="5.10.1.3" refined="false">
        <Synopsis>Answer wthether the receiver's data is binary.</Synopsis>
        <Definition protocol="FileStream">Answer &lt;em&gt;true&lt;/em&gt; if the &lt;em&gt;sequence value type&lt;/em&gt; conforms to &amp;lt;integer&amp;gt;. Otherwise answer &lt;em&gt;false&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
      <Message selector="isText" docId="5.10.1.4" refined="false">
        <Synopsis>Answer whether the receiver's data is characters.</Synopsis>
        <Definition protocol="FileStream">Answer &lt;em&gt;true&lt;/em&gt; if the &lt;em&gt;sequence value type&lt;/em&gt; conforms to &amp;lt;Character&amp;gt;. Otherwise answer &lt;em&gt;false&lt;/em&gt; .</Definition>
        <ReturnValue aliasing="unspecified">
          <Protocol name="boolean" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="readFileStream" docId="5.10.2" abstract="true">
      <ConformsTo protocol="FileStream" />
      <ConformsTo protocol="gettableStream" />
      <Description>Provides protocol for traversing and reading elements in an external file. The &lt;em&gt;sequence values&lt;/em&gt; are provided by the external file which also serves as &lt;em&gt;the stream backing store&lt;/em&gt; .</Description>
      <Message selector="next:" docId="5.10.2.1" refined="true">
        <Synopsis>Returns a collection of the next &lt;code&gt;amount&lt;/code&gt; objects in the stream.</Synopsis>
        <Definition protocol="gettableStream">&lt;p&gt;A number of objects equal to &lt;code&gt;amount&lt;/code&gt; are removed from the receiver's &lt;em&gt;future sequence values&lt;/em&gt; and appended, in order, to the end of the receiver's &lt;em&gt;past sequence values.&lt;/em&gt; A collection whose elements consist of those objects, in the same order, is returned. If amount is equal to 0 an empty collection is returned.&lt;/p&gt;&lt;p&gt; The result is undefined if &lt;code&gt;amount&lt;/code&gt; is larger than the number of objects in the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; .&lt;/p&gt;</Definition>
        <Refinement protocol="readFileStream">The result collection will conform to the same protocols as the object that would result if the message # &lt;code&gt;contents&lt;/code&gt; was sent to the receiver.</Refinement>
        <Parameter name="amount" aliasing="uncaptured">
          <Protocol name="integer" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
        <Errors>amount &amp;lt; 0</Errors>
      </Message>
      <Message selector="upTo:" docId="5.10.2.2" refined="true">
        <Synopsis>Returns a collection of all of the objects in the receiver up to, but not including, the next occurrence of the argument. Sets the stream to read the object just after the next occurrence of the argument. If the argument is not found and the end of the stream is encountered, an ordered collection of the objects read is returned.</Synopsis>
        <Definition protocol="gettableStream">Each object in the receiver's &lt;em&gt;future sequence values&lt;/em&gt; up to and including the first occurrence of an object that is &lt;em&gt;equivalent&lt;/em&gt; to &lt;code&gt;anObject&lt;/code&gt; is removed from the &lt;em&gt;future sequence values&lt;/em&gt; and appended to the receiver's &lt;em&gt;past sequence values&lt;/em&gt; . A collection, containing, in order, all of the transferred objects except the object (if any) that is equivalent to &lt;code&gt;anObject&lt;/code&gt; is returned. If the receiver's &lt;em&gt;future&lt;/em&gt; &lt;em&gt;sequence values&lt;/em&gt; is initially empty, an empty collection is returned.</Definition>
        <Refinement protocol="readFileStream">The result collection will conform to the same protocols as the object that would result if the message # &lt;code&gt;contents&lt;/code&gt; was sent to the receiver.</Refinement>
        <Parameter name="anObject" aliasing="uncaptured">
          <Protocol name="Object" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="sequencedReadableCollection" />
        </ReturnValue>
      </Message>
    </Protocol>
    <Protocol name="writeFileStream" docId="5.10.3" abstract="true">
      <ConformsTo protocol="FileStream" />
      <ConformsTo protocol="puttableStream" />
      <Description>Provides protocol for storing elements in an external file. The &lt;em&gt;sequence values&lt;/em&gt; are provided by the external file which also serves as &lt;em&gt;the stream backing store&lt;/em&gt; . A &amp;lt;writeFileStream&amp;gt; is a &lt;em&gt;write-back&lt;/em&gt; &lt;em&gt;stream&lt;/em&gt; .</Description>
    </Protocol>
    <Protocol name="FileStream factory" docId="5.10.4" abstract="false">
      <ConformsTo protocol="Object" />
      <Description>&amp;lt;FileStream factory&amp;gt; provides for the creation of objects conforming to the &amp;lt;readFileStream&amp;gt; or &amp;lt;writeFileStream&amp;gt; protocols.</Description>
      <StandardGlobal name="FileStream">
        <Description>Conforms to the protocol &amp;lt;FileStream factory&amp;gt;. Its program element type is unspecified. This is a factory for collections that conform to &amp;lt;readFileStream&amp;gt; and &amp;lt;writeFileStream&amp;gt;.</Description>
      </StandardGlobal>
      <Message selector="read:" docId="5.10.4.1" refined="false">
        <Synopsis>Returns a read file stream that reads text from the file with the given name.</Synopsis>
        <Definition protocol="FileStream factory">The result is the same as if the message &lt;code&gt;#read:type:&lt;/code&gt; was sent to the receiver with &lt;code&gt;fileId&lt;/code&gt; as the first argument and the symbol &lt;code&gt;#'text'&lt;/code&gt; as the second argument.</Definition>
        <Parameter name="aString" aliasing="unspecified">
          <Protocol name="String" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readFileStream" />
        </ReturnValue>
        <Errors>As defined by &amp;lt;FileStream factory&amp;gt; #read:type:</Errors>
      </Message>
      <Message selector="read:type:" docId="5.10.4.2" refined="false">
        <Synopsis>Returns a read file stream that reads from the file with the given name.</Synopsis>
        <Definition protocol="FileStream factory">&lt;p&gt;Locate an external file that is identified by the value of &lt;code&gt;fileID&lt;/code&gt; . The syntax of the &lt;code&gt;fileID&lt;/code&gt; string is implementation defined.&lt;/p&gt;&lt;p&gt; Return an object conforming to &amp;lt;readFileStream&amp;gt; whose &lt;em&gt;future sequence values&lt;/em&gt; initially consist of the elements of the external file&lt;b&gt;&lt;/b&gt;and which initially has no &lt;em&gt;past sequence values&lt;/em&gt; . The ordering of the &lt;em&gt;sequence values&lt;/em&gt; is the same as the ordering within the external file. The external file serves as the &lt;em&gt;stream backing store&lt;/em&gt; of the returned object. The value of &lt;code&gt;fileType&lt;/code&gt; determines the &lt;em&gt;external&lt;/em&gt; &lt;em&gt;stream type&lt;/em&gt; and &lt;em&gt;sequence value type&lt;/em&gt; of the result object.&lt;/p&gt;</Definition>
        <Parameter name="fileId" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
        <Parameter name="fileType" aliasing="unspecified">
          <Protocol name="symbol" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="readFileStream" />
        </ReturnValue>
        <Errors>It is an error if the file does not exist, or if the user does not have read access to the file.</Errors>
      </Message>
      <Message selector="write:" docId="5.10.4.3" refined="false">
        <Synopsis>Returns a write file stream that writes text to the file with the given name.</Synopsis>
        <Definition protocol="FileStream factory">The result is the same as if the message &lt;code&gt;#write:mode:check:type:&lt;/code&gt; was sent to the receiver with &lt;code&gt;fileId&lt;/code&gt; as the first argument, &lt;code&gt;#'create'&lt;/code&gt; as the second argument, &lt;em&gt;false&lt;/em&gt; as the third argument, and the symbol &lt;code&gt;#'text'&lt;/code&gt; as the fourth argument.</Definition>
        <Parameter name="fileId" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="writeFileStream" />
        </ReturnValue>
        <Errors>As defined by &amp;lt;FileStream factory&amp;gt; #write:mode:check:type:</Errors>
      </Message>
      <Message selector="write:mode:" docId="5.10.4.4" refined="false">
        <Synopsis>Returns a write file stream that writes text to the file with the given name.</Synopsis>
        <Definition protocol="FileStream factory">The result is the same as if the message &lt;code&gt;#write:mode:check:type:&lt;/code&gt; was sent to the receiver with &lt;code&gt;fileId&lt;/code&gt; as the first argument, &lt;code&gt;mode&lt;/code&gt; as the second argument, &lt;em&gt;false&lt;/em&gt; as the third argument, and the symbol &lt;code&gt;#'text'&lt;/code&gt; as the fourth argument.</Definition>
        <Parameter name="fileId" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
        <Parameter name="mode" aliasing="unspecified">
          <Protocol name="symbol" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="writeFileStream" />
        </ReturnValue>
        <Errors>As defined by &amp;lt;FileStream factory&amp;gt; #write:mode:check:type:</Errors>
      </Message>
      <Message selector="write:mode:check:type:" docId="5.10.4.5" refined="false">
        <Synopsis>Returns a write file stream that writes to the file with the given name.</Synopsis>
        <Definition protocol="FileStream factory">&lt;p&gt;Depending upon the values of &lt;code&gt;check&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; , either create a new external file or locate an existing external file that is identified by the value of &lt;code&gt;fileID&lt;/code&gt; . The syntax of the &lt;code&gt;fileID&lt;/code&gt; string is implementation defined.&lt;/p&gt;&lt;p&gt; Return an object conforming to &amp;lt;writeFileStream&amp;gt;. The external file serves as the &lt;em&gt;stream backing&lt;/em&gt; &lt;em&gt;store&lt;/em&gt; of the returned object. The returned object is a &lt;em&gt;write-back stream&lt;/em&gt; . The value of &lt;code&gt;fileType&lt;/code&gt; determines the &lt;em&gt;external stream type&lt;/em&gt; and &lt;em&gt;sequence value type&lt;/em&gt; of the result object.&lt;/p&gt;&lt;p&gt; Valid values for mode are: &lt;code&gt;#'create'&lt;/code&gt; , &lt;code&gt;#'append'&lt;/code&gt; , and &lt;code&gt;#'truncate'&lt;/code&gt; . The meaning of these values are:&lt;/p&gt;&lt;p&gt; &lt;code&gt;#'create'&lt;/code&gt; create a new file, with initial position at the beginning&lt;/p&gt;&lt;p&gt; &lt;code&gt;#'append'&lt;/code&gt; use an existing file, with initial position at its end&lt;/p&gt;&lt;p&gt; &lt;code&gt;#'truncate'&lt;/code&gt; use an existing file, initially truncating it.&lt;/p&gt;&lt;p&gt; The value of &lt;code&gt;mode&lt;/code&gt; determines the initial state of the &lt;em&gt;past sequence values&lt;/em&gt; and &lt;em&gt;future sequence&lt;/em&gt; &lt;em&gt;values&lt;/em&gt; of the result object. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;#'create'&lt;/code&gt; or &lt;code&gt;#'truncate'&lt;/code&gt; the &lt;em&gt;past sequence values&lt;/em&gt; and &lt;em&gt;future sequence values&lt;/em&gt; are both initially empty. If mode is &lt;code&gt;#'append'&lt;/code&gt; the &lt;em&gt;past sequence values&lt;/em&gt;&lt;/p&gt;&lt;p&gt; initially consist of the elements of the external file&lt;b&gt;&lt;/b&gt;and&lt;b&gt;&lt;/b&gt; &lt;em&gt;future sequence values&lt;/em&gt; is initially empty. The ordering of the &lt;em&gt;sequence values&lt;/em&gt; is the same as the ordering within the external file.&lt;/p&gt;&lt;p&gt; The &lt;code&gt;check&lt;/code&gt; flag determines whether the file specified by &lt;code&gt;fileID&lt;/code&gt; must exist or not exist.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;mode&lt;/code&gt; = &lt;code&gt;#'create'&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;false&lt;/em&gt; and the file exists, then the existing file is used.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;mode&lt;/code&gt; = &lt;code&gt;#'append'&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;false&lt;/em&gt; and the file does not exist, then it is created.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;mode&lt;/code&gt; = &lt;code&gt;#'truncate'&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;false&lt;/em&gt; and the file does not exist, then it is created.&lt;/p&gt;&lt;p&gt; This operation is undefined if a value other than &lt;code&gt;#'create'&lt;/code&gt; , &lt;code&gt;#'append'&lt;/code&gt; or &lt;code&gt;#'truncate'&lt;/code&gt; is used as the &lt;code&gt;mode&lt;/code&gt; argument.&lt;/p&gt;</Definition>
        <Parameter name="fileID" aliasing="unspecified">
          <Protocol name="readableString" />
        </Parameter>
        <Parameter name="mode" aliasing="unspecified">
          <Protocol name="symbol" />
        </Parameter>
        <Parameter name="check" aliasing="unspecified">
          <Protocol name="boolean" />
        </Parameter>
        <Parameter name="fileType" aliasing="unspecified">
          <Protocol name="symbol" />
        </Parameter>
        <ReturnValue aliasing="new">
          <Protocol name="writeFileStream" />
        </ReturnValue>
        <Errors>&lt;p&gt;If &lt;code&gt;mode&lt;/code&gt; = #create and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;true&lt;/em&gt; and the file exists.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;mode&lt;/code&gt; = #append and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;true&lt;/em&gt; and the file does not exist.&lt;/p&gt;&lt;p&gt; If &lt;code&gt;mode&lt;/code&gt; = #truncate and &lt;code&gt;check&lt;/code&gt; = &lt;em&gt;true&lt;/em&gt; and the file does not exist.&lt;/p&gt;&lt;p&gt; If the user does not have write permissions for the file.&lt;/p&gt;&lt;p&gt; If the user does not have creation permissions for a file that is to be created.&lt;/p&gt;</Errors>
      </Message>
    </Protocol>
  </SystemDescription>
  <SystemImplementation xmlns="http://schemas.ironsmalltalk.org/version1.0/Tools/SystemImplementation.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="SystemImplementation.xsd">
    <Class name="AbstractArray" instanceState="namedObjectVariables" superclassName="SequencedCollection">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="AbstractDictionary" instanceState="namedObjectVariables" superclassName="Collection">
      <ImplementedInstanceProtocols>
        <Protocol name="abstractDictionary" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="AbstractFloat" instanceState="namedObjectVariables" definingProtocol="floatCharacterization" superclassName="Number">
      <ImplementedInstanceProtocols>
        <Protocol name="Float" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="floatCharacterization" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^400.</Source>
        </Method>
        <Method selector="asBigInteger">
          <Source>asBigInteger

	self &gt;= 0.0
		ifTrue: [ ^self _asBigInteger ]
		ifFalse: [ ^self abs _asBigInteger negated ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsBigInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asBigInteger">
          <Source>_asBigInteger

	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	| i n d v p z t |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i.
	p := 0.
	z := self class zero.
	t := self class one * 10.
	[ v = z ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * t.
		i := v truncated.
		n := n * 10 + i.
		v := v - (z _coerce: i).
		" Max precision reached "
		p &gt; 10 ifTrue: [ ^n / d ].
	].
	^n / d.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcCos">
          <Source>arcCos

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcCos</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcSin">
          <Source>arcSin

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcSin</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcTan">
          <Source>arcTan

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcTan</Annotation>
          </Annotations>
        </Method>
        <Method selector="cos">
          <Source>cos

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Cos</Annotation>
          </Annotations>
        </Method>
        <Method selector="sin">
          <Source>sin

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sin</Annotation>
          </Annotations>
        </Method>
        <Method selector="tan">
          <Source>tan

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Tan</Annotation>
          </Annotations>
        </Method>
        <Method selector="exp">
          <Source>exp

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Exp</Annotation>
          </Annotations>
        </Method>
        <Method selector="ln">
          <Source>ln

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Ln</Annotation>
          </Annotations>
        </Method>
        <Method selector="log:">
          <Source>log: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Log</Annotation>
          </Annotations>
        </Method>
        <Method selector="degreesToRadians">
          <Source>degreesToRadians

	^self * self class pi / 180.0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DegreesToRadians</Annotation>
          </Annotations>
        </Method>
        <Method selector="radiansToDegrees">
          <Source>radiansToDegrees

	^self * 180.0 / self class pi.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">RadiansToDegrees</Annotation>
          </Annotations>
        </Method>
        <Method selector="floorLog:">
          <Source>floorLog: operand

	^(self log: operand) floor.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FloorLog</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:">
          <Source>_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.</Source>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="_toPrintString:">
          <Source>_toPrintString: exponentLetter
	" 
	"
	| str |
	"1. Print it in .Net style. R = Roundtrip; the most verbouse format "
	str := self _toString: 'R' formatProvider: CultureInfo invariantCulture.
	" 2. Exponent letter may be upper-case, so convert to lowercase. "
	str := str copyReplacing: $E withObject: $e. 
	" 3. In case it's an integer only, we need the decimal separator in ST format "
	(str includes: $.) ifFalse: [
		(str includes: $e) 
			ifTrue: [ str := str copyReplaceAll: 'e' with: '.0e' ]
			ifFalse: [ str := str, '.0' ].
	].
	" 4. In case the exponent is positive, we don't want the + sign "
	str := str copyReplaceAll: 'e+' with: 'e'.
	" 5. In case the exponent letter is missing, add it to preserve the float type "
	(str includes: $e) ifFalse: [ str := str, 'e0' ].
	" 6. Finally, return with the exponent letter that we need for this type. "
	^str copyReplacing: $e withObject: exponentLetter.</Source>
        </Method>
        <Method selector="//">
          <Source>// operand

	^(self / operand) asFloatD _floor asInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^self asFloatD asScaledDecimal: scale.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	&lt;primitive: ConvertChecked 'System.Int32'&gt;
	^self asBigInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="e">
          <Source>e

	&lt;get_field: 'System.Math' E&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">E</Annotation>
          </Annotations>
        </Method>
        <Method selector="pi">
          <Source>pi

	&lt;get_field: 'System.Math' PI&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Pi</Annotation>
          </Annotations>
        </Method>
        <Method selector="radix">
          <Source>radix

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Radix</Annotation>
          </Annotations>
        </Method>
        <Method selector="precision">
          <Source>precision

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Precision</Annotation>
          </Annotations>
        </Method>
        <Method selector="emax">
          <Source>emax

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emax</Annotation>
          </Annotations>
        </Method>
        <Method selector="emin">
          <Source>emin

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emin</Annotation>
          </Annotations>
        </Method>
        <Method selector="denormalized">
          <Source>denormalized
	" 
	Currently, assume this feature is off. 
	Alternatively, ask the MSVCRT _controlfp for this.
	"
	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Denormalized</Annotation>
          </Annotations>
        </Method>
        <Method selector="epsilon">
          <Source>epsilon

	^(self radix raisedTo: (1 - self precision)) asFloat.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Epsilon</Annotation>
          </Annotations>
        </Method>
        <Method selector="fmin">
          <Source>fmin

	self denormalized
		ifTrue: [ ^self fminDenormalized ]
		ifFalse: [ ^self fminNormalized ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Fmin</Annotation>
          </Annotations>
        </Method>
        <Method selector="fminDenormalized">
          <Source>fminDenormalized

	^(self radix raisedTo: (self emin - self precision)) asFloat.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FminDenormalized</Annotation>
          </Annotations>
        </Method>
        <Method selector="fminNormalized">
          <Source>fminNormalized

	^(self radix raisedTo: self emin - 1) asFloat.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FminNormalized</Annotation>
          </Annotations>
        </Method>
        <Method selector="fmax">
          <Source>fmax
	" NB: There is a bug in the X3J20 formula. See ISO/IEC 10967 for the correct formula. "
	| val |
	val := (1 - (self radix raisedTo: self precision negated)) * (self radix raisedTo: self emax).
	^self one _coerce: val.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Fmax</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. The value of this global is equivalent to the value of one of the globals: &lt;CODE&gt;FloatE&lt;/CODE&gt; , &lt;CODE&gt;FloatE&lt;/CODE&gt; , or &lt;CODE&gt;FloatE&lt;/CODE&gt; .</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="AbstractReadStream" instanceState="namedObjectVariables" superclassName="AbstractStream">
      <ImplementedInstanceProtocols>
        <Protocol name="gettableStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="AbstractStream" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="sequencedStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="AbstractString" instanceState="namedObjectVariables" superclassName="SequencedReadableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="magnitude" />
        <Protocol name="readableString" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="Array" instanceState="namedObjectVariables" definingProtocol="Array factory" superclassName="AbstractArray">
      <ImplementedInstanceProtocols>
        <Protocol name="Array" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Array factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="asArray">
          <Source>asArray

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsArray</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Array factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Array&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Object[]</Annotation>
      </Annotations>
    </Class>
    <Class name="Bag" instanceState="namedObjectVariables" definingProtocol="Bag factory" superclassName="ExtensibleCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="Bag" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Bag factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Bag factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Bag&amp;gt;.</Description>
    </Class>
    <Class name="BigDecimal" instanceState="native" superclassName="ScaledDecimal">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^220.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: NumberEquals _BigDecimal _BigDecimal&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: NumberGreatherThan _BigDecimal _BigDecimal&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self error: 'Unexpected!'.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: NumberSubtract _BigDecimal _BigDecimal&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: DecimalMultiply _BigDecimal _BigDecimal&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: NumberGreatherThanOrEqual _BigDecimal _BigDecimal&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: NumberLessThanOrEqual _BigDecimal _BigDecimal&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: NumberLessThan _BigDecimal _BigDecimal&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: NumberNegate _BigDecimal&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: NumberAdd _BigDecimal _BigDecimal&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	&lt;primitive: DecimalDivide _BigDecimal _BigDecimal&gt;

	^super / operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self rounded.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber

	^aNumber asScaledDecimal: self scale.</Source>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	&lt;primitive: ConvertChecked 'System.Int32'&gt;
	^self asBigInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	&lt;call: _BigDecimal ToSourceString this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloatE">
          <Source>asFloatE

	^self asFloatD asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatE</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	^self _numerator / self _denominator.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^self _asScaledDecimal: scale asInt32.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="_numerator">
          <Source>_numerator

	&lt;get_field: _BigDecimal Numerator&gt;</Source>
        </Method>
        <Method selector="_denominator">
          <Source>_denominator

	&lt;get_field: _BigDecimal Denominator&gt;</Source>
        </Method>
        <Method selector="_asScaledDecimal:">
          <Source>_asScaledDecimal: scale

	&lt;call: _BigDecimal ToScale _BigDecimal 'System.Int32'&gt;</Source>
        </Method>
        <Method selector="scale">
          <Source>scale

	&lt;get_field: _BigDecimal Scale&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Scale</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Initializer>
        <Source>zero := 0s.
one := 1s.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">_BigDecimal</Annotation>
      </Annotations>
    </Class>
    <Class name="BigInteger" instanceState="native" superclassName="SignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^150.</Source>
        </Method>
        <Method selector="asBigInteger">
          <Source>asBigInteger

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsBigInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asBigInteger.</Source>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self error: 'Unexpected!'.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual	
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: IntegerNegate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="gcd:">
          <Source>gcd: operand

	" Not really needed to do this in primitive, but speeds up a little "
	&lt;static: _RuntimeHelper GCD 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Gcd</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' &gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Initializer sortKey="2">
        <Source>zero := 0 asBigInteger.
one := 1 asBigInteger.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</Annotation>
      </Annotations>
    </Class>
    <Class name="BlockClosure" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="valuable" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
    </Class>
    <Class name="Boolean" instanceState="native" definingProtocol="boolean" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="boolean" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="&amp;">
          <Source>&amp; operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&amp;</Annotation>
          </Annotations>
        </Method>
        <Method selector="|">
          <Source>| operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">|</Annotation>
          </Annotations>
        </Method>
        <Method selector="and:">
          <Source>and: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">And</Annotation>
          </Annotations>
        </Method>
        <Method selector="eqv:">
          <Source>eqv: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Eqv</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:">
          <Source>ifFalse: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:ifTrue:">
          <Source>ifFalse: falseOperand ifTrue: trueOperand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:">
          <Source>ifTrue: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:ifFalse:">
          <Source>ifTrue: trueOperand ifFalse: falseOperand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="not">
          <Source>not

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Not</Annotation>
          </Annotations>
        </Method>
        <Method selector="or:">
          <Source>or: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Or</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="xor:">
          <Source>xor: operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Xor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>&lt;P&gt;This class describes the behavior of the objects that are the values of the reserved identifiers "true" and "false". These objects are &lt;EM&gt;identity objects&lt;/EM&gt; .&lt;/P&gt;
&lt;P&gt;Several message specifications include a truth table describing the result of the binary operation implemented by that message. In each table, the value of the receiver is used to locate a row and the value of the argument is used to locate a column, the result being located at the intersection of the row and column.&lt;/P&gt;</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Boolean</Annotation>
      </Annotations>
    </Class>
    <Class name="Byte" instanceState="native" superclassName="UnsignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^110.</Source>
        </Method>
        <Method selector="asByte">
          <Source>asByte

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asByte.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.Byte' 'System.Byte'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.Byte' 'System.Byte'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt16.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.Byte' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.Byte' 'System.Byte'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.Byte' 'System.Byte'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.Byte' 'System.Byte'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Byte' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.Byte' 'System.Byte'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.Byte' 'System.Byte'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.Byte' 'System.Byte'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.Byte' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.Byte' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="3">
        <Source>zero := 0 asByte.
one := 1 asByte.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Byte</Annotation>
      </Annotations>
    </Class>
    <Class name="ByteArray" instanceState="native" definingProtocol="ByteArray factory" superclassName="AbstractArray">
      <ImplementedInstanceProtocols>
        <Protocol name="ByteArray" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="ByteArray factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="asByteArray">
          <Source>asByteArray

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByteArray</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;ByteArray factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;ByteArray&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Byte[]</Annotation>
      </Annotations>
    </Class>
    <Class name="Character" instanceState="native" definingProtocol="Character factory" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="Character" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Character factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools>
        <Pool name="CharacterConstants" />
      </SharedPools>
      <InstanceMethods>
        <Method selector="asLowercase">
          <Source>asLowercase

	&lt;static: char ToLower char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsLowercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="asString">
          <Source>asString

	^String with: self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsString</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUppercase">
          <Source>asUppercase

	&lt;static: char ToUpper char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUppercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="isAlphaNumeric">
          <Source>isAlphaNumeric

	^self isLetter or: [ self isDigit ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsAlphaNumeric</Annotation>
          </Annotations>
        </Method>
        <Method selector="isDigit">
          <Source>isDigit

	&lt;static: char IsDigit char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsDigit</Annotation>
          </Annotations>
        </Method>
        <Method selector="isLetter">
          <Source>isLetter

	&lt;static: char IsLetter char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsLetter</Annotation>
          </Annotations>
        </Method>
        <Method selector="isLowercase">
          <Source>isLowercase

	&lt;static: char IsLower char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsLowercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="isUppercase">
          <Source>isUppercase

	&lt;static: char IsUpper char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsUppercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="codePoint">
          <Source>codePoint

	&lt;primitive: ConvertUnchecked int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CodePoint</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: Equals char char&gt;
	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="asImmutableString">
          <Source>asImmutableString

	&lt;static: char ToString char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsImmutableString</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="codePoint:">
          <Source>codePoint: integer

	&lt;primitive: ConvertChecked char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CodePoint</Annotation>
          </Annotations>
        </Method>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="cr">
          <Source>cr

	^Cr.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Cr</Annotation>
          </Annotations>
        </Method>
        <Method selector="lf">
          <Source>lf

	^Lf.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Lf</Annotation>
          </Annotations>
        </Method>
        <Method selector="space">
          <Source>space

	^Space.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Space</Annotation>
          </Annotations>
        </Method>
        <Method selector="tab">
          <Source>tab

	^Tab.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Tab</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global is a factory for for creating or accessing objects that conform to &amp;lt;Character&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Char</Annotation>
      </Annotations>
    </Class>
    <Pool name="CharacterConstants">
      <PoolValue name="Nul" type="constant">
        <Initializer sortKey="3.25">
          <Source>Character codePoint: 0</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Soh" type="constant">
        <Initializer sortKey="3.30">
          <Source>Character codePoint: 1</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Stx" type="constant">
        <Initializer sortKey="3.32">
          <Source>Character codePoint: 2</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Etx" type="constant">
        <Initializer sortKey="3.18">
          <Source>Character codePoint: 3</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Eot" type="constant">
        <Initializer sortKey="3.15">
          <Source>Character codePoint: 4</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Enq" type="constant">
        <Initializer sortKey="3.14">
          <Source>Character codePoint: 5</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Ack" type="constant">
        <Initializer sortKey="3.00">
          <Source>Character codePoint: 6</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Bel" type="constant">
        <Initializer sortKey="3.02">
          <Source>Character codePoint: 7</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Bs" type="constant">
        <Initializer sortKey="3.04">
          <Source>Character codePoint: 8</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Ht" type="constant">
        <Initializer sortKey="3.22">
          <Source>Character codePoint: 9</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Lf" type="constant">
        <Initializer sortKey="3.23">
          <Source>Character codePoint: 10</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Vt" type="constant">
        <Initializer sortKey="3.38">
          <Source>Character codePoint: 11</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Ff" type="constant">
        <Initializer sortKey="3.19">
          <Source>Character codePoint: 12</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Cr" type="constant">
        <Initializer sortKey="3.06">
          <Source>Character codePoint: 13</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="So" type="constant">
        <Initializer sortKey="3.29">
          <Source>Character codePoint: 14</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Si" type="constant">
        <Initializer sortKey="3.28">
          <Source>Character codePoint: 15</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Dle" type="constant">
        <Initializer sortKey="3.12">
          <Source>Character codePoint: 16</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Dc1" type="constant">
        <Initializer sortKey="3.07">
          <Source>Character codePoint: 17</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Dc2" type="constant">
        <Initializer sortKey="3.08">
          <Source>Character codePoint: 18</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Dc3" type="constant">
        <Initializer sortKey="3.09">
          <Source>Character codePoint: 19</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Dc4" type="constant">
        <Initializer sortKey="3.10">
          <Source>Character codePoint: 20</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Nak" type="constant">
        <Initializer sortKey="3.24">
          <Source>Character codePoint: 21</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Syn" type="constant">
        <Initializer sortKey="3.34">
          <Source>Character codePoint: 22</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Etb" type="constant">
        <Initializer sortKey="3.17">
          <Source>Character codePoint: 23</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Can" type="constant">
        <Initializer sortKey="3.05">
          <Source>Character codePoint: 24</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Em" type="constant">
        <Initializer sortKey="3.13">
          <Source>Character codePoint: 25</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Sub" type="constant">
        <Initializer sortKey="3.33">
          <Source>Character codePoint: 26</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Esc" type="constant">
        <Initializer sortKey="3.16">
          <Source>Character codePoint: 27</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Fs" type="constant">
        <Initializer sortKey="3.20">
          <Source>Character codePoint: 28</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Gs" type="constant">
        <Initializer sortKey="3.21">
          <Source>Character codePoint: 29</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Rs" type="constant">
        <Initializer sortKey="3.27">
          <Source>Character codePoint: 30</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Us" type="constant">
        <Initializer sortKey="3.36">
          <Source>Character codePoint: 31</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Tab" type="constant">
        <Initializer sortKey="3.35">
          <Source>Character codePoint: 9</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="VerticalTab" type="constant">
        <Initializer sortKey="3.37">
          <Source>Character codePoint: 11</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Backspace" type="constant">
        <Initializer sortKey="3.01">
          <Source>Character codePoint: 8</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Bell" type="constant">
        <Initializer sortKey="3.03">
          <Source>Character codePoint: 7</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Null" type="constant">
        <Initializer sortKey="3.26">
          <Source>Character codePoint: 0</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Space" type="constant">
        <Initializer sortKey="3.31">
          <Source>Character codePoint: 32</Source>
        </Initializer>
      </PoolValue>
      <PoolValue name="Del" type="constant">
        <Initializer sortKey="3.11">
          <Source>Character codePoint: 127</Source>
        </Initializer>
      </PoolValue>
      <Description>Contains characters that are control characters or other characters that are not easyly typed on the keyboard.</Description>
    </Pool>
    <Class name="Class" instanceState="native" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="classDescription" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="name">
          <Source>name

	&lt;get_property: _SmalltalkClass Name _Symbol&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Name</Annotation>
          </Annotations>
        </Method>
        <Method selector="superclass">
          <Source>superclass

	&lt;get_property: _SmalltalkClass Superclass _SmalltalkClass&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Superclass</Annotation>
          </Annotations>
        </Method>
        <Method selector="basicNew">
          <Source>basicNew

	&lt;call: _SmalltalkClass NewObject this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BasicNew</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;call: _SmalltalkClass Equals this object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="subclasses">
          <Source>subclasses

	&lt;get_property: _SmalltalkClass Subclasses 
	'System.Collections.Generic.IEnumerable`1[[IronSmalltalk.Runtime.SmalltalkClass, IronSmalltalk.Runtime]]'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Subclasses</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">class</Annotation>
      </Annotations>
    </Class>
    <Class name="Collection" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="collection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="collection factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="allSatisfy:">
          <Source>allSatisfy: discriminator

	self do: [ :element |
		(discriminator value: element) ifFalse: [ ^false ].
	].
	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AllSatisfy</Annotation>
          </Annotations>
        </Method>
        <Method selector="anySatisfy:">
          <Source>anySatisfy: discriminator

	self do: [ :element |
		(discriminator value: element) ifTrue: [ ^true ].
	].
	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AnySatisfy</Annotation>
          </Annotations>
        </Method>
        <Method selector="detect:ifNone:">
          <Source>detect: discriminator ifNone: exceptionHandler

	self do: [ :element |
		(discriminator value: element) ifTrue: [ ^element ].
	].
	^exceptionHandler value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Detect</Annotation>
          </Annotations>
        </Method>
        <Method selector="do:separatedBy:">
          <Source>do: operation separatedBy: separator

	| firstTime |
	firstTime := true.
	self do: [ :element |
		firstTime 
			ifTrue: [ firstTime := false ]
			ifFalse: [ separator value ].
		operation value: element.
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Do</Annotation>
          </Annotations>
        </Method>
        <Method selector="includes:">
          <Source>includes: target

	self do: [ :element |
		element = target ifTrue: [ ^true ].
	].
	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Includes</Annotation>
          </Annotations>
        </Method>
        <Method selector="inject:into:">
          <Source>inject: initialValue into: operation

	| value |
	value := initialValue.
	self do: [ :element |
		value := operation value: value value: element.
	].
	^value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Inject</Annotation>
          </Annotations>
        </Method>
        <Method selector="isEmpty">
          <Source>isEmpty

	^self size = 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsEmpty</Annotation>
          </Annotations>
        </Method>
        <Method selector="notEmpty">
          <Source>notEmpty

	^self size ~= 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NotEmpty</Annotation>
          </Annotations>
        </Method>
        <Method selector="occurrencesOf:">
          <Source>occurrencesOf: target

	| occurrences |
	occurrences := 0.
	self do: [ :element |
		element = target ifTrue: [ occurrences := occurrences + 1 ].
	].
	^occurrences.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OccurrencesOf</Annotation>
          </Annotations>
        </Method>
        <Method selector="reject:">
          <Source>reject: discriminator

	^self select: [ :element | (discriminator value: element) not ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Reject</Annotation>
          </Annotations>
        </Method>
        <Method selector="size">
          <Source>size

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Size</Annotation>
          </Annotations>
        </Method>
        <Method selector="asArray">
          <Source>asArray

	^Array withAll: self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsArray</Annotation>
          </Annotations>
        </Method>
        <Method selector="asByteArray">
          <Source>asByteArray

	^ByteArray withAll: self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByteArray</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
    </Class>
    <Class name="CollectionReadStream" instanceState="namedObjectVariables" superclassName="AbstractReadStream">
      <ImplementedInstanceProtocols>
        <Protocol name="collectionStream" />
        <Protocol name="ReadStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="Console" instanceState="native" superclassName="NativeObject">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols>
        <Protocol name="puttableStream" />
        <Protocol name="Transcript" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods>
        <Method selector="writeLine:">
          <Source>writeLine: anObject

	&lt;static: 'System.Console' WriteLine object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteLine</Annotation>
          </Annotations>
        </Method>
        <Method selector="beep">
          <Source>beep

	&lt;static: 'System.Console' Beep&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Beep</Annotation>
          </Annotations>
        </Method>
        <Method selector="beep:duration:">
          <Source>beep: frequency duration: duration

	&lt;static: 'System.Console' Beep int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Beep</Annotation>
          </Annotations>
        </Method>
        <Method selector="clear">
          <Source>clear

	&lt;static: 'System.Console' Clear&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Clear</Annotation>
          </Annotations>
        </Method>
        <Method selector="read">
          <Source>read

	&lt;static: 'System.Console' Read&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Read</Annotation>
          </Annotations>
        </Method>
        <Method selector="readKey">
          <Source>readKey

	&lt;static: 'System.Console' ReadKey&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReadKey</Annotation>
          </Annotations>
        </Method>
        <Method selector="readKey:">
          <Source>readKey: intercept

	&lt;static: 'System.Console' ReadKey bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReadKey</Annotation>
          </Annotations>
        </Method>
        <Method selector="readLine">
          <Source>readLine

	&lt;static: 'System.Console' ReadLine&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReadLine</Annotation>
          </Annotations>
        </Method>
        <Method selector="openStandardInput">
          <Source>openStandardInput

	&lt;static: 'System.Console' OpenStandardInput&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OpenStandardInput</Annotation>
          </Annotations>
        </Method>
        <Method selector="openStandardOutput">
          <Source>openStandardOutput

	&lt;static: 'System.Console' OpenStandardOutput&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OpenStandardOutput</Annotation>
          </Annotations>
        </Method>
        <Method selector="openStandardError">
          <Source>openStandardError

	&lt;static: 'System.Console' OpenStandardError&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OpenStandardError</Annotation>
          </Annotations>
        </Method>
        <Method selector="resetColor">
          <Source>resetColor

	&lt;static: 'System.Console' ResetColor&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ResetColor</Annotation>
          </Annotations>
        </Method>
        <Method selector="setCursorPosition:top:">
          <Source>setCursorPosition: left top: top

	&lt;static: 'System.Console' SetCursorPosition int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">SetCursorPosition</Annotation>
          </Annotations>
        </Method>
        <Method selector="error:">
          <Source>error: aTextWriter

	&lt;static: 'System.Console' SetError 'System.IO.TextWriter'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Error</Annotation>
          </Annotations>
        </Method>
        <Method selector="in:">
          <Source>in: aTextWriter

	&lt;static: 'System.Console' SetIn 'System.IO.TextReader'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">In</Annotation>
          </Annotations>
        </Method>
        <Method selector="out:">
          <Source>out: aTextWriter

	&lt;static: 'System.Console' SetOut 'System.IO.TextWriter'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Out</Annotation>
          </Annotations>
        </Method>
        <Method selector="setWindowPosition:top:">
          <Source>setWindowPosition: left top: top

	&lt;static: 'System.Console' SetWindowPosition int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">SetWindowPosition</Annotation>
          </Annotations>
        </Method>
        <Method selector="setWindowSize:height:">
          <Source>setWindowSize: width height: height

	&lt;static: 'System.Console' SetWindowSize int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">SetWindowSize</Annotation>
          </Annotations>
        </Method>
        <Method selector="write:">
          <Source>write: anObject

	&lt;static: 'System.Console' Write object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Write</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeFormatted:with:with:">
          <Source>writeFormatted: format with: arg1 with: arg2

	&lt;static: 'System.Console' Write string object object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeFormatted:arguments:">
          <Source>writeFormatted: format arguments: arg

	&lt;static: 'System.Console' Write string 'System.Object[]'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeFormatted:with:">
          <Source>writeFormatted: format with: arg

	&lt;static: 'System.Console' Write string object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeFormatted:with:with:with:">
          <Source>writeFormatted: format with: arg1 with: arg2 with: arg3

	&lt;static: 'System.Console' Write string object object object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeLineFormatted:arguments:">
          <Source>writeLineFormatted: format arguments: arg

	&lt;static: 'System.Console' WriteLine string 'System.Object[]'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteLineFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeLineFormatted:with:">
          <Source>writeLineFormatted: format with: arg

	&lt;static: 'System.Console' WriteLine string object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteLineFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeLineFormatted:with:with:">
          <Source>writeLineFormatted: format with: arg1 with: arg2

	&lt;static: 'System.Console' WriteLine string object object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteLineFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="writeLineFormatted:with:with:with:">
          <Source>writeLineFormatted: format with: arg1 with: arg2 with: arg3

	&lt;static: 'System.Console' WriteLine string object object object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WriteLineFormatted</Annotation>
          </Annotations>
        </Method>
        <Method selector="backgroundColor">
          <Source>backgroundColor

	&lt;get_property: 'System.Console' BackgroundColor 'System.ConsoleColor'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BackgroundColor</Annotation>
          </Annotations>
        </Method>
        <Method selector="backgroundColor:">
          <Source>backgroundColor: aConsoleColor

	&lt;set_property: 'System.Console' BackgroundColor 'System.ConsoleColor'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BackgroundColor</Annotation>
          </Annotations>
        </Method>
        <Method selector="bufferWidth">
          <Source>bufferWidth

	&lt;get_property: 'System.Console' BufferWidth int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BufferWidth</Annotation>
          </Annotations>
        </Method>
        <Method selector="bufferWidth:">
          <Source>bufferWidth: anInteger

	&lt;set_property: 'System.Console' BufferWidth int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BufferWidth</Annotation>
          </Annotations>
        </Method>
        <Method selector="bufferHeight">
          <Source>bufferHeight

	&lt;get_property: 'System.Console' BufferHeight int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BufferHeight</Annotation>
          </Annotations>
        </Method>
        <Method selector="bufferHeight:">
          <Source>bufferHeight: anInteger

	&lt;set_property: 'System.Console' BufferHeight int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BufferHeight</Annotation>
          </Annotations>
        </Method>
        <Method selector="capsLock">
          <Source>capsLock

	&lt;get_property: 'System.Console' CapsLock bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CapsLock</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorLeft">
          <Source>cursorLeft

	&lt;get_property: 'System.Console' CursorLeft int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorLeft</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorSize">
          <Source>cursorSize

	&lt;get_property: 'System.Console' CursorSize int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorSize</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorTop">
          <Source>cursorTop

	&lt;get_property: 'System.Console' CursorTop int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorTop</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorVisible">
          <Source>cursorVisible

	&lt;get_property: 'System.Console' CursorVisible bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorVisible</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorVisible:">
          <Source>cursorVisible: aBoolean

	&lt;set_property: 'System.Console' CursorVisible bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorVisible</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorTop:">
          <Source>cursorTop: anInteger

	&lt;set_property: 'System.Console' CursorTop int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorTop</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorSize:">
          <Source>cursorSize: anInteger

	&lt;set_property: 'System.Console' CursorSize int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorSize</Annotation>
          </Annotations>
        </Method>
        <Method selector="cursorLeft:">
          <Source>cursorLeft: anInteger

	&lt;set_property: 'System.Console' CursorLeft int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CursorLeft</Annotation>
          </Annotations>
        </Method>
        <Method selector="error">
          <Source>error

	&lt;get_property: 'System.Console' Error 'System.IO.TextWriter'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Error</Annotation>
          </Annotations>
        </Method>
        <Method selector="in">
          <Source>in

	&lt;get_property: 'System.Console' In 'System.IO.TextReader'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">In</Annotation>
          </Annotations>
        </Method>
        <Method selector="out">
          <Source>out

	&lt;get_property: 'System.Console' Out 'System.IO.TextWriter'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Out</Annotation>
          </Annotations>
        </Method>
        <Method selector="foregroundColor">
          <Source>foregroundColor

	&lt;get_property: 'System.Console' ForegroundColor 'System.ConsoleColor'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ForegroundColor</Annotation>
          </Annotations>
        </Method>
        <Method selector="foregroundColor:">
          <Source>foregroundColor: aConsoleColor

	&lt;set_property: 'System.Console' ForegroundColor 'System.ConsoleColor'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ForegroundColor</Annotation>
          </Annotations>
        </Method>
        <Method selector="inputEncoding:">
          <Source>inputEncoding: anEncoding

	&lt;set_property: 'System.Console' InputEncoding 'System.Text.Encoding'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">InputEncoding</Annotation>
          </Annotations>
        </Method>
        <Method selector="inputEncoding">
          <Source>inputEncoding

	&lt;get_property: 'System.Console' InputEncoding 'System.Text.Encoding'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">InputEncoding</Annotation>
          </Annotations>
        </Method>
        <Method selector="outputEncoding">
          <Source>outputEncoding

	&lt;get_property: 'System.Console' OutputEncoding 'System.Text.Encoding'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OutputEncoding</Annotation>
          </Annotations>
        </Method>
        <Method selector="outputEncoding:">
          <Source>outputEncoding: anEncoding

	&lt;set_property: 'System.Console' OutputEncoding 'System.Text.Encoding'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">OutputEncoding</Annotation>
          </Annotations>
        </Method>
        <Method selector="keyAvailable">
          <Source>keyAvailable 

	&lt;get_property: 'System.Console' KeyAvailable bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">KeyAvailable</Annotation>
          </Annotations>
        </Method>
        <Method selector="largestWindowHeight">
          <Source>largestWindowHeight 

	&lt;get_property: 'System.Console' LargestWindowHeight int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">LargestWindowHeight</Annotation>
          </Annotations>
        </Method>
        <Method selector="largestWindowWidth">
          <Source>largestWindowWidth

	&lt;get_property: 'System.Console' LargestWindowWidth int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">LargestWindowWidth</Annotation>
          </Annotations>
        </Method>
        <Method selector="numberLock">
          <Source>numberLock

	&lt;get_property: 'System.Console' NumberLock bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NumberLock</Annotation>
          </Annotations>
        </Method>
        <Method selector="title">
          <Source>title

	&lt;get_property: 'System.Console' Title string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Title</Annotation>
          </Annotations>
        </Method>
        <Method selector="title:">
          <Source>title: aString

	&lt;set_property: 'System.Console' Title string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Title</Annotation>
          </Annotations>
        </Method>
        <Method selector="treatControlCAsInput:">
          <Source>treatControlCAsInput: aBoolean

	&lt;set_property: 'System.Console' TreatControlCAsInput bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">TreatControlCAsInput</Annotation>
          </Annotations>
        </Method>
        <Method selector="treatControlCAsInput">
          <Source>treatControlCAsInput

	&lt;get_property: 'System.Console' TreatControlCAsInput bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">TreatControlCAsInput</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowHeight">
          <Source>windowHeight

	&lt;get_property: 'System.Console' WindowHeight int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowHeight</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowLeft">
          <Source>windowLeft

	&lt;get_property: 'System.Console' WindowLeft int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowLeft</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowTop">
          <Source>windowTop

	&lt;get_property: 'System.Console' WindowTop int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowTop</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowWidth">
          <Source>windowWidth

	&lt;get_property: 'System.Console' WindowWidth int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowWidth</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowWidth:">
          <Source>windowWidth: anInteger

	&lt;set_property: 'System.Console' WindowWidth int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowWidth</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowTop:">
          <Source>windowTop: anInteger

	&lt;set_property: 'System.Console' WindowTop int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowTop</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowLeft:">
          <Source>windowLeft: anInteger

	&lt;set_property: 'System.Console' WindowLeft int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowLeft</Annotation>
          </Annotations>
        </Method>
        <Method selector="windowHeight:">
          <Source>windowHeight: anInteger

	&lt;set_property: 'System.Console' WindowHeight int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WindowHeight</Annotation>
          </Annotations>
        </Method>
        <Method selector="cr">
          <Source>cr

	self nextPut: Character cr.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Cr</Annotation>
          </Annotations>
        </Method>
        <Method selector="flush">
          <Source>flush

	" Does nothing - No need for flush "</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Flush</Annotation>
          </Annotations>
        </Method>
        <Method selector="space">
          <Source>space

	self nextPut: Character space.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Space</Annotation>
          </Annotations>
        </Method>
        <Method selector="tab">
          <Source>tab

	self nextPut: Character tab.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Tab</Annotation>
          </Annotations>
        </Method>
        <Method selector="nextPutAll:">
          <Source>nextPutAll: aString

	self write: aString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NextPutAll</Annotation>
          </Annotations>
        </Method>
        <Method selector="nextPut:">
          <Source>nextPut: anObject

	&lt;static: 'System.Console' Write char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NextPut</Annotation>
          </Annotations>
        </Method>
        <Method selector="show:">
          <Source>show: aString

	self write: aString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Show</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="CultureInfo" instanceState="native" superclassName="NativeObject">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="clearCachedData">
          <Source>clearCachedData

	&lt;call: 'System.Globalization.CultureInfo' ClearCachedData this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ClearCachedData</Annotation>
          </Annotations>
        </Method>
        <Method selector="clone">
          <Source>clone

	&lt;call: 'System.Globalization.CultureInfo' Clone this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Clone</Annotation>
          </Annotations>
        </Method>
        <Method selector="getConsoleFallbackUICulture">
          <Source>getConsoleFallbackUICulture 

	&lt;call: 'System.Globalization.CultureInfo' GetConsoleFallbackUICulture this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetConsoleFallbackUICulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="calendar">
          <Source>calendar

	&lt;get_property: 'System.Globalization.CultureInfo' Calendar 'System.Globalization.Calendar'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Calendar</Annotation>
          </Annotations>
        </Method>
        <Method selector="dateTimeFormat">
          <Source>dateTimeFormat

	&lt;get_property: 'System.Globalization.CultureInfo' DateTimeFormat 'System.Globalization.DateTimeFormatInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DateTimeFormat</Annotation>
          </Annotations>
        </Method>
        <Method selector="displayName">
          <Source>displayName

	&lt;get_property: 'System.Globalization.CultureInfo' DisplayName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DisplayName</Annotation>
          </Annotations>
        </Method>
        <Method selector="englishName">
          <Source>englishName

	&lt;get_property: 'System.Globalization.CultureInfo' EnglishName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">EnglishName</Annotation>
          </Annotations>
        </Method>
        <Method selector="dateTimeFormat:">
          <Source>dateTimeFormat: aDateTimeFormatInfo

	&lt;set_property: 'System.Globalization.CultureInfo' DateTimeFormat 'System.Globalization.DateTimeFormatInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DateTimeFormat</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNeutralCulture">
          <Source>isNeutralCulture

	&lt;get_property: 'System.Globalization.CultureInfo' IsNeutralCulture bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNeutralCulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="isReadOnly">
          <Source>isReadOnly

	&lt;get_property: 'System.Globalization.CultureInfo' IsReadOnly bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsReadOnly</Annotation>
          </Annotations>
        </Method>
        <Method selector="keyboardLayoutId">
          <Source>keyboardLayoutId 

	&lt;get_property: 'System.Globalization.CultureInfo' KeyboardLayoutId int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">KeyboardLayoutId</Annotation>
          </Annotations>
        </Method>
        <Method selector="lcid">
          <Source>lcid

	&lt;get_property: 'System.Globalization.CultureInfo' LCID int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Lcid</Annotation>
          </Annotations>
        </Method>
        <Method selector="name">
          <Source>name

	&lt;get_property: 'System.Globalization.CultureInfo' Name string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Name</Annotation>
          </Annotations>
        </Method>
        <Method selector="nativeName">
          <Source>nativeName

	&lt;get_property: 'System.Globalization.CultureInfo' NativeName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NativeName</Annotation>
          </Annotations>
        </Method>
        <Method selector="numberFormat">
          <Source>numberFormat

	&lt;get_property: 'System.Globalization.CultureInfo' NumberFormat 'System.Globalization.NumberFormatInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NumberFormat</Annotation>
          </Annotations>
        </Method>
        <Method selector="threeLetterISOLanguageName">
          <Source>threeLetterISOLanguageName

	&lt;get_property: 'System.Globalization.CultureInfo' ThreeLetterISOLanguageName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ThreeLetterISOLanguageName</Annotation>
          </Annotations>
        </Method>
        <Method selector="threeLetterWindowsLanguageName">
          <Source>threeLetterWindowsLanguageName

	&lt;get_property: 'System.Globalization.CultureInfo' ThreeLetterWindowsLanguageName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ThreeLetterWindowsLanguageName</Annotation>
          </Annotations>
        </Method>
        <Method selector="twoLetterISOLanguageName">
          <Source>twoLetterISOLanguageName

	&lt;get_property: 'System.Globalization.CultureInfo' TwoLetterISOLanguageName string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">TwoLetterISOLanguageName</Annotation>
          </Annotations>
        </Method>
        <Method selector="useUserOverride">
          <Source>useUserOverride

	&lt;get_property: 'System.Globalization.CultureInfo' UseUserOverride bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">UseUserOverride</Annotation>
          </Annotations>
        </Method>
        <Method selector="numberFormat:">
          <Source>numberFormat: aNumberFormatInfo

	&lt;set_property: 'System.Globalization.CultureInfo' NumberFormat 'System.Globalization.NumberFormatInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NumberFormat</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="currentCulture">
          <Source>currentCulture

	&lt;get_property: 'System.Globalization.CultureInfo' CurrentCulture 'System.Globalization.CultureInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CurrentCulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="currentUICulture">
          <Source>currentUICulture

	&lt;get_property: 'System.Globalization.CultureInfo' CurrentUICulture 'System.Globalization.CultureInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CurrentUICulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="installedUICulture">
          <Source>installedUICulture

	&lt;get_property: 'System.Globalization.CultureInfo' InstalledUICulture 'System.Globalization.CultureInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">InstalledUICulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="invariantCulture">
          <Source>invariantCulture

	&lt;get_property: 'System.Globalization.CultureInfo' InvariantCulture 'System.Globalization.CultureInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">InvariantCulture</Annotation>
          </Annotations>
        </Method>
        <Method selector="readOnly:">
          <Source>readOnly: aCultureInfo

	&lt;static: 'System.Globalization.CultureInfo' ReadOnly 'System.Globalization.CultureInfo'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReadOnly</Annotation>
          </Annotations>
        </Method>
        <Method selector="getCultureInfo:alternativeName:">
          <Source>getCultureInfo: name alternativeName: altName

	&lt;static: 'System.Globalization.CultureInfo' GetCultureInfo string string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetCultureInfo</Annotation>
          </Annotations>
        </Method>
        <Method selector="getCultureInfo:">
          <Source>getCultureInfo: name

	&lt;static: 'System.Globalization.CultureInfo' GetCultureInfo string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetCultureInfo</Annotation>
          </Annotations>
        </Method>
        <Method selector="getCultureInfoFromLCID:">
          <Source>getCultureInfoFromLCID: lcid

	&lt;static: 'System.Globalization.CultureInfo' GetCultureInfo int&gt;

	^self getCultureInfoFromLCID: lcid asInt32.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetCultureInfoFromLCID</Annotation>
          </Annotations>
        </Method>
        <Method selector="createSpecificCulture:">
          <Source>createSpecificCulture: name

	&lt;static: 'System.Globalization.CultureInfo' CreateSpecificCulture string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CreateSpecificCulture</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Globalization.CultureInfo</Annotation>
      </Annotations>
    </Class>
    <Global name="DateAndTime" type="constant">
      <ImplementedProtocols>
        <Protocol name="DateAndTime factory" />
      </ImplementedProtocols>
      <Initializer sortKey="1">
        <Source>DateTime</Source>
      </Initializer>
    </Global>
    <Class name="DateTime" instanceState="native" definingProtocol="DateAndTime factory" superclassName="SimpleDateTime">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="asDateTime">
          <Source>asDateTime

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsDateTime</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: Subtract 'System.DateTimeOffset' 'System.DateTimeOffset'&gt;
	^self asDateTime - operand asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="year:month:day:hour:minute:second:">
          <Source>year: year month: month day: dayOfMonth hour: hour minute: minute second: second
	
	^(super year: year month: month day: dayOfMonth hour: hour minute: minute second: second) asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="now">
          <Source>now

	&lt;get_property: 'System.DateTimeOffset' Now 'System.DateTimeOffset'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Now</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:day:hour:minute:second:offset:">
          <Source>year: year day: dayOfYear hour: hour minute: minute second: second offset: offset

	| monthStartDay |
	monthStartDay := 0.
	1 to: 12 do: [ :month |
		| daysInMonth |
		daysInMonth := self _daysIn: year month: month.
		dayOfYear &lt;= (monthStartDay + daysInMonth) ifTrue: [
			| day |
			day := dayOfYear - monthStartDay.
			^self year: year month: month day: day hour: hour minute: minute second: second offset: offset.
		].
		monthStartDay := monthStartDay + daysInMonth.
	].
	^self error: 'Invalid dayOfYear'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:month:day:hour:minute:second:offset:">
          <Source>year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: offset

	&lt;ctor: 'System.DateTimeOffset' int int int int int int 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.DateTimeOffset</Annotation>
      </Annotations>
    </Class>
    <Class name="DateTimeFormatInfo" instanceState="native" superclassName="NativeObject">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Globalization.DateTimeFormatInfo</Annotation>
      </Annotations>
    </Class>
    <Class name="Decimal" instanceState="native" superclassName="ScaledDecimal">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^210.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: NumberEquals 'System.Decimal' 'System.Decimal'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: NumberGreatherThan 'System.Decimal' 'System.Decimal'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: NumberSubtract 'System.Decimal' 'System.Decimal'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: DecimalMultiply 'System.Decimal' 'System.Decimal'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: NumberGreatherThanOrEqual 'System.Decimal' 'System.Decimal'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: NumberLessThanOrEqual 'System.Decimal' 'System.Decimal'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: NumberLessThan 'System.Decimal' 'System.Decimal'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: NumberNegate 'System.Decimal'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="asNativeDecimal">
          <Source>asNativeDecimal

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsNativeDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: NumberAdd 'System.Decimal' 'System.Decimal'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	&lt;primitive: DecimalDivide 'System.Decimal' 'System.Decimal'&gt;

	^super / operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	&lt;primitive: ConvertChecked 'System.Int32'&gt;
	^self asBigInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self _asBigDecimal.</Source>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asNativeDecimal.</Source>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^self _asBigDecimal asScaledDecimal: scale.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self rounded.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	| i n d v p |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i.
	p := 0.
	[ v = 0.0 ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * 10.
		i := v truncated.
		n := n * 10 + i.
		v := v - i.
		" Just in case of a bug ... max precision is 28 for decimal "
		p &gt; 30 ifTrue: [ ^n / d ].
	].
	^n / d.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="scale">
          <Source>scale

	^self _asBigDecimal scale.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Scale</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Decimal' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="_toString:">
          <Source>_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.</Source>
        </Method>
        <Method selector="_asBigDecimal">
          <Source>_asBigDecimal

	&lt;primitive: ConvertChecked _BigDecimal&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name"></Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self _asBigDecimal printString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Initializer sortKey="5">
        <Source>zero := 0 asNativeDecimal.
one := 1 asNativeDecimal.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Decimal</Annotation>
      </Annotations>
    </Class>
    <Class name="Dictionary" instanceState="namedObjectVariables" definingProtocol="Dictionary factory" superclassName="AbstractDictionary">
      <ImplementedInstanceProtocols>
        <Protocol name="Dictionary" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Dictionary factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Dictionary factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Dictionary&amp;gt;.</Description>
    </Class>
    <Class name="Duration" instanceState="native" definingProtocol="Duration factory" superclassName="Magnitude">
      <ImplementedInstanceProtocols>
        <Protocol name="Duration" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Duration factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_ticks">
          <Source>_ticks

	&lt;get_property: 'System.TimeSpan' Ticks 'System.Int64'&gt;</Source>
        </Method>
        <Method selector="seconds">
          <Source>seconds

	&lt;get_property: 'System.TimeSpan' Seconds 'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Seconds</Annotation>
          </Annotations>
        </Method>
        <Method selector="milliseconds">
          <Source>milliseconds

	&lt;get_property: 'System.TimeSpan' Milliseconds 'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Milliseconds</Annotation>
          </Annotations>
        </Method>
        <Method selector="asMilliseconds">
          <Source>asMilliseconds

	&lt;get_property: 'System.TimeSpan' TotalMilliseconds 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsMilliseconds</Annotation>
          </Annotations>
        </Method>
        <Method selector="asSeconds">
          <Source>asSeconds

	&lt;get_property: 'System.TimeSpan' TotalSeconds 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSeconds</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: LessThan 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: LessThanOrEqual 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: GreatherThan 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: GreatherThanOrEqual 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: Equals 'System.TimeSpan' 'System.TimeSpan'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: Add 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: Subtract 'System.TimeSpan' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	^self class _ticks: (self _ticks * operand) asInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="abs">
          <Source>abs

	^self class _ticks: self _ticks abs.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Abs</Annotation>
          </Annotations>
        </Method>
        <Method selector="days">
          <Source>days

	&lt;get_property: 'System.TimeSpan' Days 'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Days</Annotation>
          </Annotations>
        </Method>
        <Method selector="hours">
          <Source>hours

	&lt;get_property: 'System.TimeSpan' Hours 'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hours</Annotation>
          </Annotations>
        </Method>
        <Method selector="minutes">
          <Source>minutes

	&lt;get_property: 'System.TimeSpan' Minutes'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Minutes</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: Negate 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="negative">
          <Source>negative

	^self &lt; self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negative</Annotation>
          </Annotations>
        </Method>
        <Method selector="positive">
          <Source>positive

	^self &gt;= self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Positive</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.TimeSpan' ToString this string 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="_toString:">
          <Source>_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.</Source>
        </Method>
        <Method selector="printString">
          <Source>printString
	"
	X3J20 requires relatively stiff representation - we obey.
	"
	self negative ifTrue: [
		self milliseconds = 0
			ifTrue: [ ^self _toString: '\-d\:hh\:mm\:ss' ]
			ifFalse: [ ^self _toString: '\-d\:hh\:mm\:ss\.fffffff' ].
	] ifFalse: [
		self milliseconds = 0
			ifTrue: [ ^self _toString: 'd\:hh\:mm\:ss' ]
			ifFalse: [ ^self _toString: 'd\:hh\:mm\:ss\.fffffff' ].
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	operand class = self class ifTrue: [
		" Duration ... return number "
		^self _ticks / operand _ticks.
	] ifFalse: [
		" Number ... return duration "
		^self class _ticks: (self _ticks / operand) asInteger.
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="zero">
          <Source>zero

	&lt;get_field: 'System.TimeSpan' Zero&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Zero</Annotation>
          </Annotations>
        </Method>
        <Method selector="days:hours:minutes:seconds:">
          <Source>days: days hours: hours minutes: minutes seconds: seconds

	&lt;ctor: 'System.TimeSpan' int int int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Days</Annotation>
          </Annotations>
        </Method>
        <Method selector="_ticks:">
          <Source>_ticks: ticks

	&lt;ctor: 'System.TimeSpan' 'System.Int64'&gt;

	^self _ticks: ticks asInt64.</Source>
        </Method>
        <Method selector="seconds:">
          <Source>seconds: seconds
	"
	1 tick = 100 nanoseconds.
	1 seconds = 10000000 ticks.
	"
	^self _ticks: (seconds * 10000000) asInt64.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Seconds</Annotation>
          </Annotations>
        </Method>
        <Method selector="days:hours:minutes:seconds:milliseconds:">
          <Source>days: days hours: hours minutes: minutes seconds: seconds milliseconds: milliseconds

	&lt;ctor: 'System.TimeSpan' int int int int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Days</Annotation>
          </Annotations>
        </Method>
        <Method selector="milliseconds:">
          <Source>milliseconds: milliseconds
	"
	1 tick = 100 nanoseconds.
	1 milliseconds = 10000 ticks.
	"
	^self _ticks: (milliseconds * 10000) asInt64.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Milliseconds</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;Duration factory&amp;gt;. Its language element type is unspecified.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.TimeSpan</Annotation>
      </Annotations>
    </Class>
    <Class name="DyadicBlock" instanceState="native" superclassName="BlockClosure">
      <ImplementedInstanceProtocols>
        <Protocol name="dyadicValuable" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="value:value:">
          <Source>value: argument1 value: argument2

	&lt;static: _RuntimeHelper BlockValue 'System.Func`3[[System.Object], [System.Object], [System.Object]]' 'System.Object' 'System.Object'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Value</Annotation>
          </Annotations>
        </Method>
        <Method selector="argumentCount">
          <Source>argumentCount

	^2.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArgumentCount</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Func`3[[System.Object],[System.Object],[System.Object]]</Annotation>
      </Annotations>
    </Class>
    <Class name="Enumerable" instanceState="native" superclassName="Collection">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="Error" instanceState="namedObjectVariables" definingProtocol="Error class" superclassName="Exception">
      <ImplementedInstanceProtocols>
        <Protocol name="Error" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Error class" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isResumable">
          <Source>isResumable

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsResumable</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>A class name. Conforms to the protocol &amp;lt;Error class&amp;gt;. &lt;CODE&gt;Error&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Exception&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Error&amp;gt;.</Description>
    </Class>
    <Class name="Exception" instanceState="namedObjectVariables" definingProtocol="Exception class" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="Exception" />
        <Protocol name="exceptionBuilder" />
        <Protocol name="exceptionDescription" />
        <Protocol name="exceptionSignaler" />
        <Protocol name="signaledException" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Exception class" />
        <Protocol name="exceptionInstantiator" />
        <Protocol name="exceptionSelector" />
        <Protocol name="exceptionSignaler" />
      </ImplementedClassProtocols>
      <InstanceVariables>
        <Variable name="messageText" />
        <Variable name="tag" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isResumable">
          <Source>isResumable

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsResumable</Annotation>
          </Annotations>
        </Method>
        <Method selector="messageText">
          <Source>messageText

	^messageText.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">MessageText</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>A class name. Conforms to the protocol &amp;lt;Exception class&amp;gt;. Instances of this class conform to the protocol &amp;lt;Exception&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="ExceptionSet" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="exceptionSelector" />
        <Protocol name="exceptionSet" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="ExtensibleCollection" instanceState="namedObjectVariables" superclassName="InitializableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="extensibleCollection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="FailedMessage" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="failedMessage" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables>
        <Variable name="arguments" />
        <Variable name="selector" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="arguments">
          <Source>arguments

	^arguments.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Arguments</Annotation>
          </Annotations>
        </Method>
        <Method selector="selector">
          <Source>selector

	^selector.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Selector</Annotation>
          </Annotations>
        </Method>
        <Method selector="_selector:arguments:">
          <Source>_selector: aSymbol arguments: anArray

	selector := aSymbol.
	arguments := anArray.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name"></Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="_selector:arguments:">
          <Source>_selector: aSymbol arguments: anArray

	^self new _selector: aSymbol arguments: anArray; yourself.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name"></Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Represent a message that was sent to an object, but was not understood by that object.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="False" instanceState="native" definingProtocol="boolean" superclassName="Boolean">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="not">
          <Source>not

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Not</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^'false'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:">
          <Source>ifFalse: operand

	^operand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:ifTrue:">
          <Source>ifFalse: falseOperand ifTrue: trueOperand

	^falseOperand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:">
          <Source>ifTrue: operand

	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:ifFalse:">
          <Source>ifTrue: trueOperand ifFalse: falseOperand

	^falseOperand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="eqv:">
          <Source>eqv: operand

	^operand not.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Eqv</Annotation>
          </Annotations>
        </Method>
        <Method selector="&amp;">
          <Source>&amp; operand

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&amp;</Annotation>
          </Annotations>
        </Method>
        <Method selector="|">
          <Source>| operand

	^operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">|</Annotation>
          </Annotations>
        </Method>
        <Method selector="and:">
          <Source>and: operand

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">And</Annotation>
          </Annotations>
        </Method>
        <Method selector="or:">
          <Source>or: operand

	^operand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Or</Annotation>
          </Annotations>
        </Method>
        <Method selector="xor:">
          <Source>xor: operand

	^operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Xor</Annotation>
          </Annotations>
        </Method>
        <Method selector="printOn:">
          <Source>printOn: target

	target nextPutAll: 'false'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintOn</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">false</Annotation>
      </Annotations>
    </Class>
    <Class name="FileStream" instanceState="namedObjectVariables" definingProtocol="FileStream factory" superclassName="AbstractReadStream">
      <ImplementedInstanceProtocols>
        <Protocol name="FileStream" />
        <Protocol name="puttableStream" />
        <Protocol name="readFileStream" />
        <Protocol name="writeFileStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="FileStream factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;FileStream factory&amp;gt;. Its program element type is unspecified. This is a factory for collections that conform to &amp;lt;readFileStream&amp;gt; and &amp;lt;writeFileStream&amp;gt;.</Description>
    </Class>
    <Global name="Float" definingProtocol="floatCharacterization" type="constant">
      <ImplementedProtocols>
        <Protocol name="floatCharacterization" />
      </ImplementedProtocols>
      <Initializer sortKey="6">
        <Source>FloatD</Source>
      </Initializer>
    </Global>
    <Class name="FloatD" instanceState="native" definingProtocol="floatCharacterization" superclassName="AbstractFloat">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^420.</Source>
        </Method>
        <Method selector="asFloatD">
          <Source>asFloatD

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asFloatD.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: FloatEquals 'System.Double' 'System.Double'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: FloatGreatherThan 'System.Double' 'System.Double'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asBigInteger">
          <Source>_asBigInteger

	&lt;ctor: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Double'&gt;</Source>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self error: 'Unexpected!'.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: FloatSubtract 'System.Double' 'System.Double'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: FloatMultiply 'System.Double' 'System.Double'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: FloatGreatherThanOrEqual 'System.Double' 'System.Double'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: FloatLessThanOrEqual 'System.Double' 'System.Double'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: FloatLessThan 'System.Double' 'System.Double'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: FloatAdd 'System.Double' 'System.Double'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: FloatNegate 'System.Double'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	&lt;primitive: FloatDivide 'System.Double' 'System.Double'&gt;

	^super / operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="_truncated">
          <Source>_truncated

	&lt;static: 'System.Math' Truncate 'System.Double'&gt;</Source>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	| i n d v p z t |
	i := self truncated.
	n := i.
	d := 1.
	v := self - i asFloatD.
	p := 0.
	z := self class zero.
	t := self class one * 10.
	[ v = z or: [ p &gt; scale ] ] whileFalse: [
		p := p + 1.
		d := d * 10.
		v := v * t.
		i := v truncated.
		n := n * 10 + i.
		v := v - i asFloatD.
	].
	^(n asScaledDecimal: scale) / (d asScaledDecimal: scale).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self rounded.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcCos">
          <Source>arcCos

	&lt;static: 'System.Math' Acos 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcCos</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcSin">
          <Source>arcSin

	&lt;static: 'System.Math' Asin 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcSin</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcTan">
          <Source>arcTan

	&lt;static: 'System.Math' Atan 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcTan</Annotation>
          </Annotations>
        </Method>
        <Method selector="cos">
          <Source>cos

	&lt;static: 'System.Math' Cos 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Cos</Annotation>
          </Annotations>
        </Method>
        <Method selector="sin">
          <Source>sin

	&lt;static: 'System.Math' Sin 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sin</Annotation>
          </Annotations>
        </Method>
        <Method selector="tan">
          <Source>tan

	&lt;static: 'System.Math' Tan 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Tan</Annotation>
          </Annotations>
        </Method>
        <Method selector="exp">
          <Source>exp

	&lt;static: 'System.Math' Exp 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Exp</Annotation>
          </Annotations>
        </Method>
        <Method selector="ln">
          <Source>ln

	&lt;static: 'System.Math' Log 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Ln</Annotation>
          </Annotations>
        </Method>
        <Method selector="log:">
          <Source>log: operand

	^self _log: operand asFloatD.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Log</Annotation>
          </Annotations>
        </Method>
        <Method selector="_log:">
          <Source>_log: operand

	&lt;static: 'System.Math' Log 'System.Double' 'System.Double'&gt;</Source>
        </Method>
        <Method selector="rounded">
          <Source>rounded

	" Optimization "
	self &lt; self class zero
		ifTrue: [ ^(self - 0.5) truncated ]
		ifFalse: [ ^(self + 0.5) truncated ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rounded</Annotation>
          </Annotations>
        </Method>
        <Method selector="sqrt">
          <Source>sqrt

	&lt;static: 'System.Math' Sqrt 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sqrt</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Double' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self _toPrintString: $d.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="_floor">
          <Source>_floor 

	&lt;static: 'System.Math' Floor 'System.Double'&gt;</Source>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="radix">
          <Source>radix
	
	" System.Double uses IEEE 754 binary64 floats "
	^2.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Radix</Annotation>
          </Annotations>
        </Method>
        <Method selector="emin">
          <Source>emin
	" System.Double uses IEEE 754 binary64 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^-1021.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emin</Annotation>
          </Annotations>
        </Method>
        <Method selector="emax">
          <Source>emax
	" System.Double uses IEEE 754 binary64 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^1024.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emax</Annotation>
          </Annotations>
        </Method>
        <Method selector="precision">
          <Source>precision
	
	" System.Double uses IEEE 754 binary64 floats "
	^53 " 52 + 1 ".</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Precision</Annotation>
          </Annotations>
        </Method>
        <Method selector="fmax">
          <Source>fmax

	&lt;get_field: 'System.Double' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Fmax</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="15">
        <Source>zero := 0.0d0 asFloatD.
one := 1.0d0 asFloatD.</Source>
      </Initializer>
      <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the 'd' floating point literal syntax.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Double</Annotation>
      </Annotations>
    </Class>
    <Class name="FloatE" instanceState="native" definingProtocol="floatCharacterization" superclassName="AbstractFloat">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^410.</Source>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asFloatE.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: FloatEquals 'System.Single' 'System.Single'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: FloatGreatherThan 'System.Single' 'System.Single'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asBigInteger">
          <Source>_asBigInteger

	&lt;ctor: 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
	'System.Single'&gt;</Source>
        </Method>
        <Method selector="asFloatE">
          <Source>asFloatE

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatE</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asFloatD.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: FloatSubtract 'System.Single' 'System.Single'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: FloatMultiply 'System.Single' 'System.Single'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: FloatGreatherThanOrEqual 'System.Single' 'System.Single'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: FloatLessThanOrEqual 'System.Single' 'System.Single'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: FloatLessThan 'System.Single' 'System.Single'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: FloatAdd 'System.Single' 'System.Single'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: FloatNegate 'System.Single'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	&lt;primitive: FloatDivide 'System.Single' 'System.Single'&gt;

	^super / operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self rounded.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcCos">
          <Source>arcCos

	^self asFloatD arcCos asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcCos</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcSin">
          <Source>arcSin

	^self asFloatD arcSin asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcSin</Annotation>
          </Annotations>
        </Method>
        <Method selector="arcTan">
          <Source>arcTan

	^self asFloatD arcTan asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArcTan</Annotation>
          </Annotations>
        </Method>
        <Method selector="cos">
          <Source>cos

	^self asFloatD cos asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Cos</Annotation>
          </Annotations>
        </Method>
        <Method selector="tan">
          <Source>tan

	^self asFloatD tan asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Tan</Annotation>
          </Annotations>
        </Method>
        <Method selector="sin">
          <Source>sin

	^self asFloatD sin asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sin</Annotation>
          </Annotations>
        </Method>
        <Method selector="ln">
          <Source>ln

	^self asFloatD ln asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Ln</Annotation>
          </Annotations>
        </Method>
        <Method selector="exp">
          <Source>exp

	^self asFloatD exp asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Exp</Annotation>
          </Annotations>
        </Method>
        <Method selector="log:">
          <Source>log: operand

	^(self asFloatD log: operand) asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Log</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Single' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self _toPrintString: $e.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="radix">
          <Source>radix
	
	" System.Single uses IEEE 754 binary32 floats "
	^2.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Radix</Annotation>
          </Annotations>
        </Method>
        <Method selector="emin">
          <Source>emin
	" System.Single uses IEEE 754 binary32 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^-125.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emin</Annotation>
          </Annotations>
        </Method>
        <Method selector="emax">
          <Source>emax
	" System.Single uses IEEE 754 binary32 floats.

	ISO/IEC 10967, A.5.2. Floating point types says:
	... Consequently IEEE 754 Emax and Emin are one smaller than
	the emax and emin given in the LIA-1 model."
	^128.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Emax</Annotation>
          </Annotations>
        </Method>
        <Method selector="fmax">
          <Source>fmax

	&lt;get_field: 'System.Single' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Fmax</Annotation>
          </Annotations>
        </Method>
        <Method selector="precision">
          <Source>precision
	
	" System.Duble uses IEEE 754 binary64 floats "
	^24 " 23 + 1 ".</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Precision</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="16">
        <Source>zero := 0.0e0 asFloatE.
one := 1.0e0 asFloatE.</Source>
      </Initializer>
      <Description>Conforms to the protocol &amp;lt;floatCharacterization&amp;gt;. Its language element type is implementation defined. This global characterizes the floating point representation corresponding to the 'e' floating point literal syntax.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Single</Annotation>
      </Annotations>
    </Class>
    <Global name="FloatQ" definingProtocol="floatCharacterization" type="constant">
      <ImplementedProtocols>
        <Protocol name="floatCharacterization" />
      </ImplementedProtocols>
      <Initializer sortKey="18">
        <Source>FloatD</Source>
      </Initializer>
    </Global>
    <Class name="Fraction" instanceState="namedObjectVariables" definingProtocol="Fraction factory" superclassName="Number">
      <ImplementedInstanceProtocols>
        <Protocol name="Fraction" />
        <Protocol name="rational" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Fraction factory" />
      </ImplementedClassProtocols>
      <InstanceVariables>
        <Variable name="denominator" />
        <Variable name="numerator" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^300.</Source>
        </Method>
        <Method selector="_numerator:denominator:">
          <Source>_numerator: top denominator: bottom

	bottom = 0 
		ifTrue: [ ^self _divideByZero ].
	bottom negative ifTrue: [
		numerator := top negated.
		denominator := bottom negated.
	] ifFalse: [
		numerator := top.
		denominator := bottom.
	].</Source>
        </Method>
        <Method selector="printString">
          <Source>printString

	^numerator printString, '/', denominator printString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="denominator">
          <Source>denominator

	^denominator.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Denominator</Annotation>
          </Annotations>
        </Method>
        <Method selector="numerator">
          <Source>numerator

	^numerator.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Numerator</Annotation>
          </Annotations>
        </Method>
        <Method selector="asNativeDecimal">
          <Source>asNativeDecimal

	^numerator asNativeDecimal / denominator asNativeDecimal.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsNativeDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator &lt; operand numerator ].
		^(numerator * operand denominator) &lt; (operand numerator * denominator).
	].

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator &lt;= operand numerator ].
		^(numerator * operand denominator) &lt;= (operand numerator * denominator).
	].

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator &gt; operand numerator ].
		^(numerator * operand denominator) &gt; (operand numerator * denominator).
	].

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	operand isRational ifTrue: [
		denominator = operand denominator ifTrue: [ ^numerator &gt;= operand numerator ].
		^(numerator * operand denominator) &gt;= (operand numerator * denominator).
	].

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	comparand isNumber ifFalse: [ ^false ].

	comparand isRational ifTrue: [
		" NB: Both rationals are already reduced, so we can do direct compare. "
		^denominator = comparand denominator and: [ numerator = comparand numerator ].
	].

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	operand isRational 
		ifTrue: [ ^(numerator * operand numerator) / (denominator * operand denominator) ].

	^super * operand</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	operand isRational ifTrue: [ 
		^((numerator * operand denominator) + (operand numerator * denominator)) 
			/ (denominator * operand denominator).
	].

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	operand isRational ifTrue: [ 
		^((numerator * operand denominator) - (operand numerator * denominator)) 
			/ (denominator * operand denominator).
	].

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 

	"
	aNumber isInteger ifTrue: [
		" NB: An integer will always coerce to an integer if sent #asFraction,
			however, we need a Fraction object so _coercionWeight etc. works. "
		^self class basicNew
			_numerator: aNumber denominator: 1;
			yourself.
	].
	^aNumber asFraction.</Source>
        </Method>
        <Method selector="/">
          <Source>/ operand

	operand isRational 
		ifTrue: [ ^(numerator * operand denominator) / (denominator * operand numerator) ].

	^super / operand</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	operand isRational 
		ifTrue: [ ^(numerator * operand denominator) // (denominator * operand numerator) ].

	^super // operand</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	^numerator quo: denominator.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self error: 'Unexpected!'.</Source>
        </Method>
        <Method selector="asInt32">
          <Source>asInt32

	^self asInteger asInt32.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt32</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt64">
          <Source>asInt64

	^self asInteger asInt64.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt64</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt16">
          <Source>asInt16

	^self asInteger asInt16.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt16</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt16">
          <Source>asUInt16

	^self asInteger asUInt16.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt16</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt32">
          <Source>asUInt32

	^self asInteger asUInt32.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt32</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt64">
          <Source>asUInt64

	^self asInteger asUInt64.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt64</Annotation>
          </Annotations>
        </Method>
        <Method selector="asSByte">
          <Source>asSByte

	^self asInteger asSByte.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="asByte">
          <Source>asByte

	^self asInteger asByte.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="asBigInteger">
          <Source>asBigInteger

	^self asInteger asBigInteger.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsBigInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^(numerator asScaledDecimal: scale) / (denominator asScaledDecimal: scale).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self rounded.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloatD">
          <Source>asFloatD

	^numerator asFloatD / denominator asFloatD.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloatE">
          <Source>asFloatE

	^numerator asFloatE / denominator asFloatE.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatE</Annotation>
          </Annotations>
        </Method>
        <Method selector="isRational">
          <Source>isRational

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsRational</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="numerator:denominator:">
          <Source>numerator: top denominator: bottom

	| gcd |
	bottom = 1
		ifTrue: [ ^top ].
	top = bottom
		ifTrue: [ ^1 ].
	top = 0
		ifTrue: [ ^0 ].

	gcd := top gcd: bottom.

	gcd = bottom
		ifTrue: [ ^top // bottom ].

	^self basicNew
		_numerator: top // gcd denominator: bottom // gcd;
		yourself.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Numerator</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="7">
        <Source>zero := 0.
one := 1.</Source>
      </Initializer>
      <Description>Conforms to the protocol &amp;lt;Fraction factory&amp;gt;. Its language element type is implementation defined.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="IdentityDictionary" instanceState="namedObjectVariables" definingProtocol="IdentityDictionary factory" superclassName="AbstractDictionary">
      <ImplementedInstanceProtocols>
        <Protocol name="IdentityDictionary" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="IdentityDictionary factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;IdentityDictionary factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;IdentityDictionary&amp;gt;.</Description>
    </Class>
    <Class name="ImmutableString" instanceState="native" superclassName="AbstractString">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols>
        <Protocol name="String factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools>
        <Pool name="CharacterConstants" />
      </SharedPools>
      <InstanceMethods>
        <Method selector=",">
          <Source>, operand

	&lt;static: 'System.String' Concat 'System.String' 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">,</Annotation>
          </Annotations>
        </Method>
        <Method selector="copyReplacing:withObject:">
          <Source>copyReplacing: targetElement withObject: replacementElement

	&lt;call: 'System.String' Replace this 'System.Char' 'System.Char'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CopyReplacing</Annotation>
          </Annotations>
        </Method>
        <Method selector="copyReplaceAll:with:">
          <Source>copyReplaceAll: targetElements with: replacementElements

	&lt;call: 'System.String' Replace this 'System.String' 'System.String'&gt;

	" TO - DO - Fallback "
	self error: 'TO-DO'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">CopyReplaceAll</Annotation>
          </Annotations>
        </Method>
        <Method selector="_indexOf:">
          <Source>_indexOf: target

	&lt;call: 'System.String' IndexOf this 'System.Char'&gt;
	^-1. " -1 to get it to 0-based index "</Source>
        </Method>
        <Method selector="indexOf:">
          <Source>indexOf: target

	^(self _indexOf: target) + 1. " +1 0-based to 1-based "</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IndexOf</Annotation>
          </Annotations>
        </Method>
        <Method selector="includes:">
          <Source>includes: target

	^(self _indexOf: target) &gt;= 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Includes</Annotation>
          </Annotations>
        </Method>
        <Method selector="asString">
          <Source>asString

	&lt;ctor: _SmalltalkString 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsString</Annotation>
          </Annotations>
        </Method>
        <Method selector="at:">
          <Source>at: index

	&lt;get_property: 'System.String' this int char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUppercase">
          <Source>asUppercase

	&lt;call: 'System.String' ToUpper this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUppercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="asLowercase">
          <Source>asLowercase

	&lt;call: 'System.String' ToLower this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsLowercase</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	&lt;get_field: 'System.String' Empty&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="new:">
          <Source>new: count

	^self new: Space count: count.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="new:count:">
          <Source>new: char count: count

	&lt;ctor: 'System.String' char int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">string</Annotation>
      </Annotations>
    </Class>
    <Class name="InitializableCollection" instanceState="namedObjectVariables" superclassName="Collection">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols>
        <Protocol name="initializableCollection factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="Int16" instanceState="native" superclassName="SignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^120.</Source>
        </Method>
        <Method selector="asInt16">
          <Source>asInt16

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt16</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asInt16.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.Int16' 'System.Int16'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.Int16' 'System.Int16'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.Int16' 'System.Int16'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt32.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.Int16' 'System.Int16'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.Int16' 'System.Int16'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.Int16' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.Int16' 'System.Int16'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.Int16' 'System.Int16'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.Int16' 'System.Int16'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: IntegerNegate 'System.Int16'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.Int16' 'System.Int16'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.Int16' 'System.Int16'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.Int16' 'System.Int16'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.Int16' 'System.Int16'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Int16' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.Int16' 'System.Int16'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.Int16' 'System.Int16'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.Int16' 'System.Int16'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.Int16' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.Int16' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="8">
        <Source>zero := 0 asInt16.
one := 1 asInt16.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Int16</Annotation>
      </Annotations>
    </Class>
    <Class name="Int32" instanceState="native" superclassName="SignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^130.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.Int32' 'System.Int32'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.Int32' 'System.Int32'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.Int32' 'System.Int32'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.Int32' 'System.Int32'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.Int32' 'System.Int32'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="asByte">
          <Source>asByte

	&lt;primitive: ConvertChecked 'System.Byte'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="asSByte">
          <Source>asSByte

	&lt;primitive: ConvertChecked 'System.SByte'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asInt32.</Source>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.Int32' 'System.Int32'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt64.</Source>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.Int32' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.Int32' 'System.Int32'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.Int32' 'System.Int32'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.Int32' 'System.Int32'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.Int32' 'System.Int32'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: IntegerNegate 'System.Int32'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="gcd:">
          <Source>gcd: operand

	" Not really needed to do this in primitive, but speeds up a little "
	&lt;static: _RuntimeHelper GCD 'System.Int32' 'System.Int32'&gt;

	^super gcd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Gcd</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.Int32' 'System.Int32'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.Int32' 'System.Int32'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Int32' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.Int32' 'System.Int32'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.Int32' 'System.Int32'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.Int32' 'System.Int32'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt32">
          <Source>asInt32

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt32</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.Int32' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.Int32' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="9">
        <Source>zero := 0 asInt32.
one := 1 asInt32.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Int32</Annotation>
      </Annotations>
    </Class>
    <Class name="Int64" instanceState="native" superclassName="SignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^140.</Source>
        </Method>
        <Method selector="asInt64">
          <Source>asInt64

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInt64</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asInt64.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.Int64' 'System.Int64'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.Int64' 'System.Int64'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asBigInteger.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.Int64' 'System.Int64'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.Int64' 'System.Int64'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.Int64' 'System.Int64'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.Int64' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.Int64' 'System.Int64'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.Int64' 'System.Int64'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.Int64' 'System.Int64'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	&lt;primitive: IntegerNegate 'System.Int64'&gt;

	^super negated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.Int64' 'System.Int64'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.Int64' 'System.Int64'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.Int64' 'System.Int64'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.Int64' 'System.Int64'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.Int64' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.Int64' 'System.Int64'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.Int64' 'System.Int64'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.Int64' 'System.Int64'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.Int64' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.Int64' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="10">
        <Source>zero := 0 asInt64.
one := 1 asInt64.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Int64</Annotation>
      </Annotations>
    </Class>
    <Class name="Integer" instanceState="namedObjectVariables" definingProtocol="Object" superclassName="Number">
      <ImplementedInstanceProtocols>
        <Protocol name="integer" />
        <Protocol name="rational" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^100.</Source>
        </Method>
        <Method selector="factorial">
          <Source>factorial

    self &gt; 1 ifTrue: [ ^(self - 1) factorial * self ].
    self &lt; 0 ifTrue: [ ^self error: 'Invalid input' ].
    ^1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Factorial</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	" 1. Are we doing negative shifting? "
	self negative
		ifTrue: [ ^(self abs bitShift: shift) negated ].

	" 2. Good chance we are overflowing "
	shift class = Int32
		ifTrue: [ ^self _asHigherPrecision bitShift: shift ].

	" 3. The primitive accept only Int32 as shift argument "
	shift _coercionWeight &lt;= 0 _coercionWeight
		ifTrue: [ ^self bitShift: shift asInt32 ].

	" 4. shift must be very large! "
	" I don't see idea of trying to shift 2.2e9 bits - we will run out of mem anyway. "
	^self error: 'Overflow'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="floor">
          <Source>floor

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Floor</Annotation>
          </Annotations>
        </Method>
        <Method selector="ceiling">
          <Source>ceiling

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Ceiling</Annotation>
          </Annotations>
        </Method>
        <Method selector="rounded">
          <Source>rounded

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rounded</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
        <Method selector="gcd:">
          <Source>gcd: operand

	| a b r |
	(self = 0 and: [ operand = 0 ])
		ifTrue: [ ^0 ].

	self positive
		ifTrue: [ a := self ]
		ifFalse: [ a := self negated ].
	operand positive
		ifTrue: [ b := operand ]
		ifFalse: [ b := operand negated ].
	[ b = 0 ] whileFalse: [
		r := a \\ b.
		a := b.
		b := r.
	].

	^a.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Gcd</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) / operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self / (self _coerce: operand) ].
	^Fraction numerator: self denominator: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^(self _asScaledDecimal asScaledDecimal: scale).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asScaledDecimal">
          <Source>_asScaledDecimal
	" 
	If I read X3J20 correctly, the scale should be set to 0 for integers.
	"
	&lt;primitive: ConvertUnchecked _BigDecimal&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name"></Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="denominator">
          <Source>denominator

	^1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Denominator</Annotation>
          </Annotations>
        </Method>
        <Method selector="numerator">
          <Source>numerator

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Numerator</Annotation>
          </Annotations>
        </Method>
        <Method selector="odd">
          <Source>odd

	^(self \\ 2) = 1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Odd</Annotation>
          </Annotations>
        </Method>
        <Method selector="even">
          <Source>even

	^(self \\ 2) = 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Even</Annotation>
          </Annotations>
        </Method>
        <Method selector="integerPart">
          <Source>integerPart

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IntegerPart</Annotation>
          </Annotations>
        </Method>
        <Method selector="fractionPart">
          <Source>fractionPart

	^self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FractionPart</Annotation>
          </Annotations>
        </Method>
        <Method selector="isRational">
          <Source>isRational

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsRational</Annotation>
          </Annotations>
        </Method>
        <Method selector="isInteger">
          <Source>isInteger

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	" Just some opttimization ... we'll give another try with integer operations "
	operand isInteger ifTrue: [
		self _coercionWeight &lt; operand _coercionWeight
			ifTrue: [ ^(operand _coerce: self) quo:  operand ].
		self _coercionWeight &gt; operand _coercionWeight
			ifTrue: [ ^self quo:  (self _coerce: operand) ].
	].

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	" Just some opttimization ... we'll give another try with integer operations "
	operand isInteger ifTrue: [
		self _coercionWeight &lt; operand _coercionWeight
			ifTrue: [ ^(operand _coerce: self) rem: operand ].
		self _coercionWeight &gt; operand _coercionWeight
			ifTrue: [ ^self rem: (self _coerce: operand) ].
	].

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="_toString:">
          <Source>_toString: format

	^self _toString: format formatProvider: CultureInfo invariantCulture.</Source>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self _toString: 'D' formatProvider: CultureInfo invariantCulture.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitAnd: operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self bitAnd: (self _coerce: operand) ].
	^self error: 'Implementation bug!'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitOr: operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self bitOr: (self _coerce: operand) ].
	^self error: 'Implementation bug!'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) bitXor: operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self bitXor: (self _coerce: operand) ].
	^self error: 'Implementation bug!'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
        <Method selector="anyMask:">
          <Source>anyMask: mask

	^(self bitAnd: mask) ~= 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AnyMask</Annotation>
          </Annotations>
        </Method>
        <Method selector="allMask:">
          <Source>allMask: mask

	^(self bitAnd: mask) = mask.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AllMask</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitAt:">
          <Source>bitAt: index

	| mask |
	index &lt; 1 
		ifTrue: [ ^self error: 'Invalid index' ].
	mask := 1 bitShift: index - 1.
	(self bitAnd: mask) = 0
		ifTrue: [ ^0 ]
		ifFalse: [ ^1 ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAt</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitAt:put:">
          <Source>bitAt: index put: value

	| mask |
	index &lt; 1 
		ifTrue: [ ^self error: 'Invalid index' ].
	mask := 1 bitShift: index - 1.
	(value bitAnd: 1) = 0 ifTrue: [
		" Turn off the bit "
		(self bitAnd: mask) = 0
			ifTrue: [ ^self ]
			ifFalse: [ ^self - mask " OK, cause not defined for negative numbers " ].
	] ifFalse: [
		" Turn on the bit " 
		(self bitAnd: mask) = 0
			ifTrue: [ ^self bitOr: mask ]
			ifFalse: [ ^self ].
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAt</Annotation>
          </Annotations>
        </Method>
        <Method selector="highBit">
          <Source>highBit

	| bits val |
	self &lt; 0 ifTrue: [ ^self error: 'Negative number' ].
	bits := 0.
	val := self.
	" Naïve algorithm :-/ "
	[ val &gt; 0 ] whileTrue: [
		val := val bitShift: -1.
		bits := bits + 1.
	].
	^bits.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">HighBit</Annotation>
          </Annotations>
        </Method>
        <Method selector="noMask:">
          <Source>noMask: mask

	^(self bitAnd: mask) = 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NoMask</Annotation>
          </Annotations>
        </Method>
        <Method selector="lcm:">
          <Source>lcm: operand

	| a b |
	(self = 0 and: [ operand = 0 ])
		ifTrue: [ ^0 ].
	self &lt; 0 
		ifTrue: [ a := self negated ]
		ifFalse: [ a := self ].
	operand &lt; 0 
		ifTrue: [ b := operand negated ]
		ifFalse: [ b := operand ].
	^a * b // (a gcd: b).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Lcm</Annotation>
          </Annotations>
        </Method>
        <Method selector="fibonacci">
          <Source>fibonacci

	^self fibonacciIterative: 1 b: 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Fibonacci</Annotation>
          </Annotations>
        </Method>
        <Method selector="fibonacciIterative:b:">
          <Source>fibonacciIterative: a b: b

	^self = 0
		ifTrue: [ b ]
		ifFalse: [ (self - 1) fibonacciIterative: a+b b: a ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FibonacciIterative</Annotation>
          </Annotations>
        </Method>
        <Method selector="fibonacciRecursive">
          <Source>fibonacciRecursive

	self &lt; 2 
		ifTrue: [ ^self ]
		ifFalse: [ ^(self - 1) fibonacciRecursive + (self - 2) fibonacciRecursive ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FibonacciRecursive</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies integer objects.</Description>
    </Class>
    <Class name="Interval" instanceState="namedObjectVariables" definingProtocol="Interval factory" superclassName="SequencedReadableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="Interval" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Interval factory" />
      </ImplementedClassProtocols>
      <InstanceVariables>
        <Variable name="start" />
        <Variable name="step" />
        <Variable name="stop" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_from:to:by:">
          <Source>_from: startArg to: stopArg by: stepArg

	start := startArg.
	stop := stopArg.
	step := stepArg.</Source>
        </Method>
        <Method selector="printString">
          <Source>printString

	^start printString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="with:">
          <Source>with: element1

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:">
          <Source>with: element1 with: element2

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:with:">
          <Source>with: element1 with: element2 with: element3

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:with:with:">
          <Source>with: element1 with: element2 with: element3 with: element4

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="withAll:">
          <Source>withAll: newElements

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WithAll</Annotation>
          </Annotations>
        </Method>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="new:">
          <Source>new: count

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="from:to:">
          <Source>from: start to: stop

	^self from: start to: stop by: 1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">From</Annotation>
          </Annotations>
        </Method>
        <Method selector="from:to:by:">
          <Source>from: start to: stop by: step

	^self basicNew
		_from: start to: stop by: step;
		yourself.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">From</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;Interval factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Interval&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="Magnitude" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="magnitude" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="between:and:">
          <Source>between: min and: max

	^min &lt;= self and: [ self &lt;= max ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Between</Annotation>
          </Annotations>
        </Method>
        <Method selector="max:">
          <Source>max: operand

	self &gt; operand
		ifTrue: [ ^self ]
		ifFalse: [ ^operand ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
        <Method selector="min:">
          <Source>min: operand

	self &lt; operand 
		ifTrue: [ ^self ]
		ifFalse: [ ^operand ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
    </Class>
    <Class name="MessageNotUnderstood" instanceState="namedObjectVariables" definingProtocol="MessageNotUnderstoodSelector" superclassName="Error">
      <ImplementedInstanceProtocols>
        <Protocol name="MessageNotUnderstood" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="MessageNotUnderstoodSelector" />
      </ImplementedClassProtocols>
      <InstanceVariables>
        <Variable name="message" />
        <Variable name="receiver" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isResumable">
          <Source>isResumable

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsResumable</Annotation>
          </Annotations>
        </Method>
        <Method selector="message">
          <Source>message

	^message.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Message</Annotation>
          </Annotations>
        </Method>
        <Method selector="receiver">
          <Source>receiver

	^receiver.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Receiver</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Unspecified language element type. Conforms to the protocol &amp;lt;MessageNotUnderstoodSelector&amp;gt;. Used as an &lt;EM&gt;exception selector&lt;/EM&gt; .</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="MonadicBlock" instanceState="native" superclassName="BlockClosure">
      <ImplementedInstanceProtocols>
        <Protocol name="monadicBlock" />
        <Protocol name="monadicValuable" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="value:">
          <Source>value: argument

	&lt;static: _RuntimeHelper BlockValue 'System.Func`2[[System.Object], [System.Object]]' 'System.Object'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Value</Annotation>
          </Annotations>
        </Method>
        <Method selector="argumentCount">
          <Source>argumentCount

	^1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArgumentCount</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Func`2[[System.Object],[System.Object]]</Annotation>
      </Annotations>
    </Class>
    <Class name="NativeArray" instanceState="native" superclassName="AbstractArray">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="NativeObject" instanceState="native" superclassName="Object">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="=">
          <Source>= comparand

	&lt;static: object Equals object object&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">native</Annotation>
      </Annotations>
    </Class>
    <Class name="NiladicBlock" instanceState="native" superclassName="BlockClosure">
      <ImplementedInstanceProtocols>
        <Protocol name="niladicBlock" />
        <Protocol name="niladicValuable" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="value">
          <Source>value

	&lt;static: _RuntimeHelper BlockValue 'System.Func`1[[System.Object]]'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Value</Annotation>
          </Annotations>
        </Method>
        <Method selector="_timeToRun">
          <Source>_timeToRun

	| start end |
	start := SimpleDateTime now.
	self value.
	end := SimpleDateTime now.
	^(end - start) asMilliseconds.</Source>
        </Method>
        <Method selector="argumentCount">
          <Source>argumentCount

	^0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ArgumentCount</Annotation>
          </Annotations>
        </Method>
        <Method selector="whileFalse">
          <Source>whileFalse
	"
	This method will get inlined.
	"
	[ self value ] whileFalse: [ ].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WhileFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="whileTrue">
          <Source>whileTrue
	"
	This method will get inlined.
	"
	[ self value ] whileTrue: [ ].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WhileTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="whileFalse:">
          <Source>whileFalse: iterationBlock
	"
	This method will get inlined.
	"
	[ self value ] whileFalse: [ iterationBlock value ].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WhileFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="whileTrue:">
          <Source>whileTrue: iterationBlock
	"
	This method will get inlined.
	"
	[ self value ] whileTrue: [ iterationBlock value ].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WhileTrue</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Func`1[[System.Object]]</Annotation>
      </Annotations>
    </Class>
    <Class name="Notification" instanceState="namedObjectVariables" definingProtocol="Notification class" superclassName="Exception">
      <ImplementedInstanceProtocols>
        <Protocol name="Notification" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Notification class" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isResumable">
          <Source>isResumable

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsResumable</Annotation>
          </Annotations>
        </Method>
        <Method selector="defaultAction">
          <Source>defaultAction

	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DefaultAction</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>A class name. Conforms to the protocol &amp;lt;Notification class&amp;gt;. &lt;CODE&gt;Notification&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Exception&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Notification&amp;gt;.</Description>
    </Class>
    <Class name="Number" instanceState="namedObjectVariables" definingProtocol="Object" superclassName="Magnitude">
      <ImplementedInstanceProtocols>
        <Protocol name="number" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables>
        <Variable name="one" />
        <Variable name="zero" />
      </ClassInstanceVariables>
      <SharedPools />
      <InstanceMethods>
        <Method selector="to:by:do:">
          <Source>to: stop by: step do: operation
	" Normally, this is inlined "
	| i |
	step = 0 ifTrue: [ self error: 'step = 0' ].
	i := self.
	step &gt; 0 ifTrue: [
		[ i &lt;= stop ] whileTrue: [
			operation value: i.
			i := i + step.
		].
	] ifFalse: [
		[ stop &lt;= i ] whileTrue: [
			operation value: i.
			i := i + step.
		].
	].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">To</Annotation>
          </Annotations>
        </Method>
        <Method selector="to:do:">
          <Source>to: stop do: operation
	" Normally, this is inlined "
	| i |
	i := self.
	[ i &lt;= stop ] whileTrue: [
		operation value: i.
		i := i + 1.
	].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">To</Annotation>
          </Annotations>
        </Method>
        <Method selector="squared">
          <Source>squared

	^self * self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Squared</Annotation>
          </Annotations>
        </Method>
        <Method selector="strictlyPositive">
          <Source>strictlyPositive

	^self &gt; self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">StrictlyPositive</Annotation>
          </Annotations>
        </Method>
        <Method selector="negative">
          <Source>negative

	 ^self &lt; self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negative</Annotation>
          </Annotations>
        </Method>
        <Method selector="abs">
          <Source>abs

	self &lt; self class zero
		ifTrue: [ ^self negated ]
		ifFalse: [ ^self ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Abs</Annotation>
          </Annotations>
        </Method>
        <Method selector="sign">
          <Source>sign

	self &gt; self class zero ifTrue: [ ^1 ].
	self &lt; self class zero ifTrue: [ ^-1 ].
	^0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sign</Annotation>
          </Annotations>
        </Method>
        <Method selector="positive">
          <Source>positive

	^self &gt;= self class zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Positive</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloat">
          <Source>asFloat

	^self asFloatD.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloat</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="asFloatQ">
          <Source>asFloatQ

	^self asFloatD.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatQ</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) &lt; operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self &lt; (self _coerce: operand) ].
	^self _asHigherPrecision &lt; operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt16">
          <Source>asInt16

	&lt;primitive: ConvertChecked 'System.Int16'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asByte">
          <Source>asByte

	^self asInt32 asByte.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt32">
          <Source>asInt32

	&lt;primitive: ConvertChecked 'System.Int32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInt64">
          <Source>asInt64

	&lt;primitive: ConvertChecked 'System.Int64'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt16">
          <Source>asUInt16

	&lt;primitive: ConvertChecked 'System.UInt16'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt32">
          <Source>asUInt32

	&lt;primitive: ConvertChecked 'System.UInt32'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUInt64">
          <Source>asUInt64

	&lt;primitive: ConvertChecked 'System.UInt64'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asSByte">
          <Source>asSByte

	^self asInt32 asSByte.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloatD">
          <Source>asFloatD

	&lt;primitive: ConvertUnchecked 'System.Double'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatD</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFloatE">
          <Source>asFloatE

	&lt;primitive: ConvertUnchecked 'System.Single'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatE</Annotation>
          </Annotations>
        </Method>
        <Method selector="asFraction">
          <Source>asFraction

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFraction</Annotation>
          </Annotations>
        </Method>
        <Method selector="asInteger">
          <Source>asInteger

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="asScaledDecimal:">
          <Source>asScaledDecimal: scale

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsScaledDecimal</Annotation>
          </Annotations>
        </Method>
        <Method selector="asBigInteger">
          <Source>asBigInteger

	&lt;primitive: ConvertUnchecked 
	'System.Numerics.BigInteger, System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsBigInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="isNumber">
          <Source>isNumber
	"
	Answer true if the receiver is a number.
	"
	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNumber</Annotation>
          </Annotations>
        </Method>
        <Method selector="timesRepeat:">
          <Source>timesRepeat: operation 
	" 
	Normally, this is inlined.
	Usually, this is implemented on Integer,
	but I see no problem on having it on Number,
	for example two-and-a-half times repeat
	will perform the block 2 times.
	"
	| i |
	i := 1.
	[ i &lt;= self ] whileTrue: [
		operation value.
		i := i + 1.
	].
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">TimesRepeat</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	comparand isNumber ifFalse: [ ^false ].

	self _coercionWeight &lt; comparand _coercionWeight
		ifTrue: [ ^(comparand _coerce: self) = comparand ].
	self _coercionWeight &gt; comparand _coercionWeight
		ifTrue: [ ^self = (self _coerce: comparand) ].
	^self _asHigherPrecision = comparand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) &gt; operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self &gt; (self _coerce: operand) ].
	^self _asHigherPrecision &gt; operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision
	"
	This converts the receiver to numeric class that can contain larger numbers 
	than the receiver's class. For example:
	SByte	=&gt; Int16	
	Byte	=&gt; Int16	NB: Notice for unsigned, we go to signed so aritmetics can be done!
	Int16	=&gt; Int32
	UInt16	=&gt; Int32
	Int32	=&gt; Int64
	UInt32	=&gt; Int64
	Int64	=&gt; BigInteger
	UInt64	=&gt; BigInteger
	BigInteger =&gt; !!ERROR!!   ... this is already unlimited precision, so we won't need larger!
	FloatE	=&gt; FloatD
	FloatD	=&gt; !!ERROR!!   ... we don't have anything else than Double (64-bit floats).
	Decimal =&gt; BigDecimal
	BigDecimal =&gt; !!ERROR!!   ... this is already unlimited precision, so we won't need larger!

	A type of number never changes to another type, e.g. Integer will not change to Float!
	"
	^self subclassResponsibility.</Source>
        </Method>
        <Method selector="+">
          <Source>+ operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) + operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self + (self _coerce: operand) ].
	^self _asHigherPrecision + operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) - operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self - (self _coerce: operand) ].
	^self _asHigherPrecision - operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) * operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self * (self _coerce: operand) ].
	^self _asHigherPrecision * operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) &lt;= operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self &lt;= (self _coerce: operand) ].
	^self _asHigherPrecision &lt;= operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) &gt;= operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self &gt;= (self _coerce: operand) ].
	^self _asHigherPrecision &gt;= operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	operand = self class zero
		ifTrue: [ ^self _divideByZero ].
	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) // operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self // (self _coerce: operand) ].
	^self error: 'Implementation bug!'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand
	" (receiver // operand) * operand + (receiver \\ operand) = receiver "
	^self - ((self // operand) * operand).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="_divideByZero">
          <Source>_divideByZero

	^self class _divideByZero.</Source>
        </Method>
        <Method selector="to:">
          <Source>to: stop

	^Interval from: self to: stop.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">To</Annotation>
          </Annotations>
        </Method>
        <Method selector="to:by:">
          <Source>to: stop by: step

	^Interval from: self to: stop by: step.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">To</Annotation>
          </Annotations>
        </Method>
        <Method selector="negated">
          <Source>negated

	^self class zero - self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negated</Annotation>
          </Annotations>
        </Method>
        <Method selector="/">
          <Source>/ operand

	self _coercionWeight &lt; operand _coercionWeight
		ifTrue: [ ^(operand _coerce: self) / operand ].
	self _coercionWeight &gt; operand _coercionWeight
		ifTrue: [ ^self / (self _coerce: operand) ].
	^self _asHigherPrecision / operand _asHigherPrecision.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">/</Annotation>
          </Annotations>
        </Method>
        <Method selector="asNativeDecimal">
          <Source>asNativeDecimal

	&lt;primitive: ConvertUnchecked 'System.Decimal'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsFloatQ</Annotation>
          </Annotations>
        </Method>
        <Method selector="floor">
          <Source>floor

	^self // self class one.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Floor</Annotation>
          </Annotations>
        </Method>
        <Method selector="ceiling">
          <Source>ceiling

	| val |
	val := self // self class one.
	val = self ifTrue: [ ^val ].
	^val + self class one.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Ceiling</Annotation>
          </Annotations>
        </Method>
        <Method selector="isRational">
          <Source>isRational

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsRational</Annotation>
          </Annotations>
        </Method>
        <Method selector="reciprocal">
          <Source>reciprocal

	^self class one / self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Reciprocal</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncated">
          <Source>truncated

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Truncated</Annotation>
          </Annotations>
        </Method>
        <Method selector="fractionPart">
          <Source>fractionPart

	^self - self integerPart.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FractionPart</Annotation>
          </Annotations>
        </Method>
        <Method selector="integerPart">
          <Source>integerPart

	^self _coerce: self truncated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IntegerPart</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	^(self / operand) truncated.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="raisedTo:">
          <Source>raisedTo: operand

	operand isInteger ifTrue: [ ^self raisedToInteger: operand ].
	^(self asFloat ln * operand) exp.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">RaisedTo</Annotation>
          </Annotations>
        </Method>
        <Method selector="raisedToInteger:">
          <Source>raisedToInteger: operand

	| result |
	operand isInteger
		ifFalse: [ ^self error: '#raisedToInteger: requires an integer operand' ].

	operand &lt; 0 ifTrue: [ ^(self raisedToInteger: operand negated) reciprocal ].
	operand = 0 ifTrue: [ ^self class one ].
	operand = 1 ifTrue: [ ^self ].

	result := self.
	2 to: operand do: [ :i | result := result * self ].
	^result.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">RaisedToInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	^self - ((self quo: operand) * operand).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="rounded">
          <Source>rounded

	self &lt; self class zero
		ifTrue: [ ^(self - (self class one / 2)) truncated ]
		ifFalse: [ ^(self + (self class one / 2)) truncated ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rounded</Annotation>
          </Annotations>
        </Method>
        <Method selector="roundTo:">
          <Source>roundTo: factor

	^(self / factor) rounded * factor.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">RoundTo</Annotation>
          </Annotations>
        </Method>
        <Method selector="sqrt">
          <Source>sqrt

	^self asFloatD sqrt.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Sqrt</Annotation>
          </Annotations>
        </Method>
        <Method selector="truncateTo:">
          <Source>truncateTo: factor

	^(self quo: factor) * factor.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">TruncateTo</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="between:and:">
          <Source>between: min and: max

	^min &lt;= self and: [ self &lt;= max ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Between</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="_divideByZero">
          <Source>_divideByZero

	^self error: 'Zero Division'.</Source>
        </Method>
        <Method selector="zero">
          <Source>zero

	^zero.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Zero</Annotation>
          </Annotations>
        </Method>
        <Method selector="one">
          <Source>one

	^one.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">One</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies number objects.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="NumberFormatInfo" instanceState="native" superclassName="NativeObject">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.Globalization.NumberFormatInfo</Annotation>
      </Annotations>
    </Class>
    <Class name="Object" instanceState="namedObjectVariables" definingProtocol="Object class">
      <ImplementedInstanceProtocols>
        <Protocol name="Object" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="instantiator" />
        <Protocol name="Object class" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="yourself">
          <Source>yourself

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Yourself</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNil">
          <Source>isNil

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNil</Annotation>
          </Annotations>
        </Method>
        <Method selector="notNil">
          <Source>notNil

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NotNil</Annotation>
          </Annotations>
        </Method>
        <Method selector="hash">
          <Source>hash

	&lt;call: object GetHashCode this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hash</Annotation>
          </Annotations>
        </Method>
        <Method selector="identityHash">
          <Source>identityHash

	&lt;call: object GetHashCode this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IdentityHash</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	&lt;call: object ToString this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="printOn:">
          <Source>printOn: target

	target nextPutAll: self printString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintOn</Annotation>
          </Annotations>
        </Method>
        <Method selector="subclassResponsibility">
          <Source>subclassResponsibility

	self error: 'My subclass should have overridden one of my messages.'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">SubclassResponsibility</Annotation>
          </Annotations>
        </Method>
        <Method selector="class">
          <Source>class

	&lt;primitive: ObjectClass&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Class</Annotation>
          </Annotations>
        </Method>
        <Method selector="_doesNotUnderstand:arguments:">
          <Source>_doesNotUnderstand: selector arguments: arguments

	^self doesNotUnderstand: (FailedMessage _selector: selector arguments: arguments).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name"></Annotation>
          </Annotations>
        </Method>
        <Method selector="invalidMessage">
          <Source>invalidMessage

	self error: 'Invalid message'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">InvalidMessage</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNumber">
          <Source>isNumber
	"
	Answer true if the receiver is a number.
	"
	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNumber</Annotation>
          </Annotations>
        </Method>
        <Method selector="__createException:">
          <Source>__createException: signalerText

	&lt;ctor: 'System.ApplicationException' 'System.String'&gt;</Source>
        </Method>
        <Method selector="__error:">
          <Source>__error: exception

	&lt;static: _RuntimeHelper Throw 'System.Exception'&gt;</Source>
        </Method>
        <Method selector="error:">
          <Source>error: signalerText

	self __error: (self __createException: signalerText).</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Error</Annotation>
          </Annotations>
        </Method>
        <Method selector="isInteger">
          <Source>isInteger

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsInteger</Annotation>
          </Annotations>
        </Method>
        <Method selector="doesNotUnderstand:">
          <Source>doesNotUnderstand: message

	^self error: self printString, ' does not understand #', message selector asString.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DoesNotUnderstand</Annotation>
          </Annotations>
        </Method>
        <Method selector="isMemberOf:">
          <Source>isMemberOf: candidateClass

	^self class = candidateClass.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsMemberOf</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	&lt;call: _SmalltalkClass NewObject this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;Object class&amp;gt;. It is a class object and the name of a class definition.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="OrderedCollection" instanceState="namedObjectVariables" definingProtocol="OrderedCollection factory" superclassName="SequencedCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="extensibleCollection" />
        <Protocol name="OrderedCollection" />
        <Protocol name="sequencedContractibleCollection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="OrderedCollection factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;OrderedCollection factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;OrderedCollection&amp;gt;.</Description>
    </Class>
    <Class name="ReadStream" instanceState="namedObjectVariables" definingProtocol="ReadStream factory" superclassName="CollectionReadStream">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols>
        <Protocol name="ReadStream factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;ReadStream factory&amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;ReadStream&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="ReadWriteStream" instanceState="namedObjectVariables" definingProtocol="ReadWriteStream factory" superclassName="CollectionReadStream">
      <ImplementedInstanceProtocols>
        <Protocol name="puttableStream" />
        <Protocol name="ReadWriteStream" />
        <Protocol name="WriteStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="ReadWriteStream factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;ReadWriteStream factory&amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;ReadWriteStream&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="SByte" instanceState="native" superclassName="SignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^110.</Source>
        </Method>
        <Method selector="asSByte">
          <Source>asSByte

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSByte</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asSByte.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.SByte' 'System.SByte'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.SByte' 'System.SByte'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt16.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.SByte' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.SByte' 'System.SByte'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.SByte' 'System.SByte'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.SByte' 'System.SByte'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand
	" 
	.Net does not have +, - or * for Byte or SByte,
	their solution is to:
		return (byte) a + b;
	which is equivelent to:
		return (byte) ((int)a + (int) b);
	We've decided to ignore the reduction (i.e. the cast back 
	to the original Byte/SByte type) and return an Int32 instead.
	"
	^self asInt32 rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.SByte' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.SByte' 'System.SByte'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.SByte' 'System.SByte'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.SByte' 'System.SByte'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.SByte' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.SByte' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="11">
        <Source>zero := 0 asSByte.
one := 1 asSByte.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.SByte</Annotation>
      </Annotations>
    </Class>
    <Class name="ScaledDecimal" instanceState="namedObjectVariables" definingProtocol="Object" superclassName="Number">
      <ImplementedInstanceProtocols>
        <Protocol name="scaledDecimal" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^200.</Source>
        </Method>
        <Method selector="scale">
          <Source>scale

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Scale</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies scaled decimal objects.</Description>
    </Class>
    <Class name="SequencedCollection" instanceState="namedObjectVariables" superclassName="SequencedReadableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="sequencedCollection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
    </Class>
    <Class name="SequencedReadableCollection" instanceState="namedObjectVariables" superclassName="InitializableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="sequencedReadableCollection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="do:">
          <Source>do: operation

	1 to: self size do: [ :idx |
		operation value: (self at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Do</Annotation>
          </Annotations>
        </Method>
        <Method selector="_ivalidIndex:">
          <Source>_ivalidIndex: index

	^self error: 'Index ', index asString, ' does not exist.'.</Source>
        </Method>
        <Method selector="first">
          <Source>first

	^self at: 1.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">First</Annotation>
          </Annotations>
        </Method>
        <Method selector="last">
          <Source>last

	^self at: self size.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Last</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:do:">
          <Source>with: otherCollection do: operation

	self size = otherCollection size
		ifFalse: [ ^self error: 'Collections must have same size' ].
	1 to: self size do: [ :idx |
		operation value: (self at: idx) value: (otherCollection at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="reverseDo:">
          <Source>reverseDo: operation

	self size to: 1 by: -1 do: [ :idx |
		operation value: (self at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReverseDo</Annotation>
          </Annotations>
        </Method>
        <Method selector="indexOf:">
          <Source>indexOf: target

	1 to: self size do: [ :idx |
		(self at: idx) = target ifTrue: [ ^idx ].
	].
	^0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IndexOf</Annotation>
          </Annotations>
        </Method>
        <Method selector="indexOf:ifAbsent:">
          <Source>indexOf: target ifAbsent: exceptionHandler

	| idx |
	idx := self indexOf: target.
	idx = 0 ifFalse: [ ^idx ].
	^exceptionHandler value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IndexOf</Annotation>
          </Annotations>
        </Method>
        <Method selector="from:to:do:">
          <Source>from: start to: stop do: operation

	start to: stop do: [ :idx |
		operation value: (self at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">From</Annotation>
          </Annotations>
        </Method>
        <Method selector="from:to:keysAndValuesDo:">
          <Source>from: start to: stop keysAndValuesDo: operation

	start to: stop do: [ :idx |
		operation value: idx value: (self at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">From</Annotation>
          </Annotations>
        </Method>
        <Method selector="keysAndValuesDo:">
          <Source>keysAndValuesDo: operation

	1 to: self size do: [ :idx |
		operation value: idx value: (self at: idx).
	].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">KeysAndValuesDo</Annotation>
          </Annotations>
        </Method>
        <Method selector="findFirst:">
          <Source>findFirst: discriminator

	1 to: self size do: [ :idx |
		(discriminator value: (self at: idx)) ifTrue: [ ^idx ].
	].
	^0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FindFirst</Annotation>
          </Annotations>
        </Method>
        <Method selector="findLast:">
          <Source>findLast: discriminator

	self size to: 1 by: -1 do: [ :idx |
		(discriminator value: (self at: idx)) ifTrue: [ ^idx ].
	].
	^0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FindLast</Annotation>
          </Annotations>
        </Method>
        <Method selector="at:">
          <Source>at: index

	^self subclassResponsibility.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
        <Method selector="at:ifAbsent:">
          <Source>at: index ifAbsent: exceptionBlock

	(index between: 1 and: self size)
		ifTrue: [ ^self at: index ]
		ifFalse: [ ^exceptionBlock value ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
        <Method selector="before:ifAbsent:">
          <Source>before: target ifAbsent: exceptionBlock

	| index |
	index := self indexOf: target.
	(index between: 2 and: self size)
		ifTrue: [ ^self at: index - 1 ]
		ifFalse: [ ^exceptionBlock value ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Before</Annotation>
          </Annotations>
        </Method>
        <Method selector="before:">
          <Source>before: target

	^self before: target ifAbsent: [ self error: 'Element was not found in the collection' ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Before</Annotation>
          </Annotations>
        </Method>
        <Method selector="after:ifAbsent:">
          <Source>after: target ifAbsent: exceptionBlock

	| index |
	index := self indexOf: target.
	(index between: 1 and: self size - 1)
		ifTrue: [ ^self at: index + 1 ]
		ifFalse: [ ^exceptionBlock value ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">After</Annotation>
          </Annotations>
        </Method>
        <Method selector="after:">
          <Source>after: target

	^self after: target ifAbsent: [ self error: 'Element was not found in the collection' ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">After</Annotation>
          </Annotations>
        </Method>
        <Method selector="=">
          <Source>= comparand

	self class = comparand class 
		ifFalse: [ ^false ].
	self size = comparand size 
		ifFalse: [ ^false ].
	1 to: self size do: [ :idx |
		(self at: idx) = (comparand at: idx)
			ifFalse: [ ^false ].
	].
	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
    </Class>
    <Class name="Set" instanceState="namedObjectVariables" definingProtocol="Set factory" superclassName="ExtensibleCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="Set" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Set factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Set factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;Set&amp;gt;.</Description>
    </Class>
    <Class name="SignedInteger" instanceState="namedObjectVariables" superclassName="Integer">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="SimpleDateTime" instanceState="native" definingProtocol="DateAndTime factory" superclassName="Magnitude">
      <ImplementedInstanceProtocols>
        <Protocol name="DateAndTime" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="DateAndTime factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: Equals 'System.DateTime' 'System.DateTime'&gt;

	comparand class = DateTime 
		ifFalse: [ ^super = comparand ]
		ifTrue: [ ^self asDateTime = comparand ].</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="month">
          <Source>month

	&lt;get_property: 'System.DateTime' Month int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Month</Annotation>
          </Annotations>
        </Method>
        <Method selector="asDateTime">
          <Source>asDateTime

	&lt;ctor: 'System.DateTimeOffset' 'System.DateTime'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsDateTime</Annotation>
          </Annotations>
        </Method>
        <Method selector="hour">
          <Source>hour

	&lt;get_property: 'System.DateTime' Hour int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hour</Annotation>
          </Annotations>
        </Method>
        <Method selector="hour24">
          <Source>hour24

	&lt;get_property: 'System.DateTime' Hour int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hour24</Annotation>
          </Annotations>
        </Method>
        <Method selector="year">
          <Source>year

	&lt;get_property: 'System.DateTime' Year int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="dayOfMonth">
          <Source>dayOfMonth

	&lt;get_property: 'System.DateTime' Day int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DayOfMonth</Annotation>
          </Annotations>
        </Method>
        <Method selector="dayOfYear">
          <Source>dayOfYear

	&lt;get_property: 'System.DateTime' DayOfYear int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DayOfYear</Annotation>
          </Annotations>
        </Method>
        <Method selector="second">
          <Source>second

	&lt;get_property: 'System.DateTime' Second int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Second</Annotation>
          </Annotations>
        </Method>
        <Method selector="minute">
          <Source>minute

	&lt;get_property: 'System.DateTime' Minute int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Minute</Annotation>
          </Annotations>
        </Method>
        <Method selector="isLeapYear">
          <Source>isLeapYear

	^self class isLeapYear: self year.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsLeapYear</Annotation>
          </Annotations>
        </Method>
        <Method selector="hour12">
          <Source>hour12

	| hour |
	hour := self hour24.
	hour = 0 ifTrue: [ ^12 ].
	hour &gt; 12 ifTrue: [ ^hour - 12 ].
	^hour.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hour12</Annotation>
          </Annotations>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: Subtract 'System.DateTime' 'System.DateTime'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: LessThan 'System.DateTime' 'System.DateTime'&gt;

	^self asDateTime &lt; operand asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: LessThanOrEqual 'System.DateTime' 'System.DateTime'&gt;

	^self asDateTime &lt;= operand asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: GreatherThanOrEqual 'System.DateTime' 'System.DateTime'&gt;

	^self asDateTime &gt;= operand asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: GreatherThan 'System.DateTime' 'System.DateTime'&gt;

	^self asDateTime &gt; operand asDateTime.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: Add 'System.DateTime' 'System.TimeSpan'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="now">
          <Source>now

	&lt;get_property: 'System.DateTime' Now 'System.DateTime'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Now</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:month:day:hour:minute:second:">
          <Source>year: year month: month day: dayOfMonth hour: hour minute: minute second: second

	&lt;ctor: 'System.DateTime' int int int int int int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:month:day:hour:minute:second:offset:">
          <Source>year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: offset

	self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:day:hour:minute:second:offset:">
          <Source>year: year day: dayOfYear hour: hour minute: minute second: second offset: offset

	self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="year:day:hour:minute:second:">
          <Source>year: year day: dayOfYear hour: hour minute: minute second: second

	| monthStartDay |
	monthStartDay := 0.
	1 to: 12 do: [ :month |
		| daysInMonth |
		daysInMonth := self _daysIn: year month: month.
		dayOfYear &lt;= (monthStartDay + daysInMonth) ifTrue: [
			| day |
			day := dayOfYear - monthStartDay.
			^self year: year month: month day: day hour: hour minute: minute second: second.
		].
		monthStartDay := monthStartDay + daysInMonth.
	].
	^self error: 'Invalid dayOfYear'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Year</Annotation>
          </Annotations>
        </Method>
        <Method selector="_daysIn:month:">
          <Source>_daysIn: year month: month

	&lt;static: 'System.DateTime' DaysInMonth int int&gt;</Source>
        </Method>
        <Method selector="isLeapYear:">
          <Source>isLeapYear: year

	&lt;static: 'System.DateTime' IsLeapYear int&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsLeapYear</Annotation>
          </Annotations>
        </Method>
        <Method selector="clockPrecision">
          <Source>clockPrecision
	"
	According to MSDN (See System.DateTime::Now):
	The resolution of this property depends on the system timer.
		System: Windows NT 3.5 and later
		Approximate Resolution: 10 milliseconds
	"
	^Duration days: 0 hours: 0 minutes: 0 seconds: 0 milliseconds: 10.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ClockPrecision</Annotation>
          </Annotations>
        </Method>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;DateAndTime factory&amp;gt;. Its language element type is unspecified.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.DateTime</Annotation>
      </Annotations>
    </Class>
    <Class name="SmalltalkRuntime" instanceState="native" superclassName="Object">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="getSmalltalkClassForType:">
          <Source>getSmalltalkClassForType: aType
	" 
	DANGER!
	Extreme care must be taken here not to do something 
	that will require this method to be re-enteres with 
	the same parameters, or we will end in endless recursion.
	"
	aType isArray 
		ifTrue: [ ^NativeArray ].
	((SystemType getType: 'System.Collections.IEnumerable') isAssignableFrom: aType)
		ifTrue: [ ^Enumerable ].
	
	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetSmalltalkClassForType</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">_SmalltalkRuntime</Annotation>
      </Annotations>
    </Class>
    <Class name="SortedCollection" instanceState="namedObjectVariables" definingProtocol="SortedCollection factory" superclassName="SequencedReadableCollection">
      <ImplementedInstanceProtocols>
        <Protocol name="extensibleCollection" />
        <Protocol name="sequencedContractibleCollection" />
        <Protocol name="SortedCollection" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="SortedCollection factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;SortedCollection factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;SortedCollection&amp;gt;.</Description>
    </Class>
    <Class name="String" instanceState="native" definingProtocol="String factory" superclassName="AbstractString">
      <ImplementedInstanceProtocols>
        <Protocol name="sequencedCollection" />
        <Protocol name="String" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="String factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools>
        <Pool name="CharacterConstants" />
      </SharedPools>
      <InstanceMethods>
        <Method selector="asString">
          <Source>asString

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsString</Annotation>
          </Annotations>
        </Method>
        <Method selector="asImmutableString">
          <Source>asImmutableString

	&lt;primitive: ConvertUnchecked string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsImmutableString</Annotation>
          </Annotations>
        </Method>
        <Method selector="_contents">
          <Source>_contents

	&lt;get_field: _SmalltalkString Contents&gt;</Source>
        </Method>
        <Method selector="at:put:">
          <Source>at: index put: newElement

	&lt;set_property: _SmalltalkString this int char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
        <Method selector="asLowercase">
          <Source>asLowercase

	&lt;call: _SmalltalkString ToLower this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsLowercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="asUppercase">
          <Source>asUppercase

	&lt;call: _SmalltalkString ToUpper this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUppercase</Annotation>
          </Annotations>
        </Method>
        <Method selector="at:">
          <Source>at: index

	&lt;get_property: _SmalltalkString this int char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
        <Method selector="at:ifAbsent:">
          <Source>at: index ifAbsent: exceptionBlock

	| _exception |
	&lt;get_property: _SmalltalkString this int char&gt;
	^_exception.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">At</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self new: 0.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="_new:">
          <Source>_new: count

	&lt;ctor: _SmalltalkString int&gt;</Source>
        </Method>
        <Method selector="new:">
          <Source>new: count

	^self new: count asInt32.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:">
          <Source>with: element1

	&lt;ctor: _SmalltalkString char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:">
          <Source>with: element1 with: element2

	&lt;ctor: _SmalltalkString char char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:with:">
          <Source>with: element1 with: element2 with: element3

	&lt;ctor: _SmalltalkString char char char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="with:with:with:with:">
          <Source>with: element1 with: element2 with: element3 with: element4

	&lt;ctor: _SmalltalkString char char char char&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">With</Annotation>
          </Annotations>
        </Method>
        <Method selector="withAll:copyContents:">
          <Source>withAll: newElements copyContents: copyContents
	
	| result |
	" Try to optimize ... if we got the collection as char-array "
	&lt;ctor: _SmalltalkString 'System.Char[]' bool&gt;

	" Fallback "
	result := self new: newElements size.
	1 to: newElements size do: [ :idx |
		result at: idx put: (newElements at: idx).
	].

	^result.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WithAll</Annotation>
          </Annotations>
        </Method>
        <Method selector="withAll:">
          <Source>withAll: newElements

	^self withAll: newElements copyContents: true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">WithAll</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Description>Conforms to the protocol &amp;lt;String factory&amp;gt;. Its language element type is unspecified. This is a factory and discriminator for collections that conform to &amp;lt;String&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">_SmalltalkString</Annotation>
      </Annotations>
    </Class>
    <Class name="Symbol" instanceState="native" definingProtocol="Object" superclassName="AbstractString">
      <ImplementedInstanceProtocols>
        <Protocol name="selector" />
        <Protocol name="symbol" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="asSymbol">
          <Source>asSymbol

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsSymbol</Annotation>
          </Annotations>
        </Method>
        <Method selector="asString">
          <Source>asString

	&lt;primitive: ConvertChecked 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsString</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;Object&amp;gt;. Its language element type is unspecified. This global identifies objects that conform to the protocol &amp;lt;symbol&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class">_Symbol</Annotation>
      </Annotations>
    </Class>
    <Class name="SystemType" instanceState="native" superclassName="NativeObject">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="assemblyQualifiedName">
          <Source>assemblyQualifiedName

	&lt;get_property: 'System.Type' AssemblyQualifiedName 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AssemblyQualifiedName</Annotation>
          </Annotations>
        </Method>
        <Method selector="baseType">
          <Source>baseType

	&lt;get_property: 'System.Type' BaseType 'System.Type'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BaseType</Annotation>
          </Annotations>
        </Method>
        <Method selector="containsGenericParameters">
          <Source>containsGenericParameters 

	&lt;get_property: 'System.Type' ContainsGenericParameters 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ContainsGenericParameters</Annotation>
          </Annotations>
        </Method>
        <Method selector="declaringType">
          <Source>declaringType 

	&lt;get_property: 'System.Type' DeclaringType 'System.Type'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">DeclaringType</Annotation>
          </Annotations>
        </Method>
        <Method selector="fullName">
          <Source>fullName 

	&lt;get_property: 'System.Type' FullName 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">FullName</Annotation>
          </Annotations>
        </Method>
        <Method selector="guid">
          <Source>guid

	&lt;get_property: 'System.Type' GUID 'System.Guid'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Guid</Annotation>
          </Annotations>
        </Method>
        <Method selector="hasElementType">
          <Source>hasElementType 

	&lt;get_property: 'System.Type' HasElementType 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">HasElementType</Annotation>
          </Annotations>
        </Method>
        <Method selector="isAbstract">
          <Source>isAbstract 

	&lt;get_property: 'System.Type' IsAbstract 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsAbstract</Annotation>
          </Annotations>
        </Method>
        <Method selector="isArray">
          <Source>isArray

	&lt;get_property: 'System.Type' IsArray 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsArray</Annotation>
          </Annotations>
        </Method>
        <Method selector="isByRef">
          <Source>isByRef

	&lt;get_property: 'System.Type' IsByRef 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsByRef</Annotation>
          </Annotations>
        </Method>
        <Method selector="isClass">
          <Source>isClass

	&lt;get_property: 'System.Type' IsClass 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsClass</Annotation>
          </Annotations>
        </Method>
        <Method selector="isCOMObject">
          <Source>isCOMObject

	&lt;get_property: 'System.Type' IsCOMObject 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsCOMObject</Annotation>
          </Annotations>
        </Method>
        <Method selector="isEnum">
          <Source>isEnum

	&lt;get_property: 'System.Type' IsEnum 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsEnum</Annotation>
          </Annotations>
        </Method>
        <Method selector="isGenericParameter">
          <Source>isGenericParameter

	&lt;get_property: 'System.Type' IsGenericParameter 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsGenericParameter</Annotation>
          </Annotations>
        </Method>
        <Method selector="isGenericType">
          <Source>isGenericType

	&lt;get_property: 'System.Type' IsGenericType 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsGenericType</Annotation>
          </Annotations>
        </Method>
        <Method selector="isGenericTypeDefinition">
          <Source>isGenericTypeDefinition

	&lt;get_property: 'System.Type' IsGenericTypeDefinition 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsGenericTypeDefinition</Annotation>
          </Annotations>
        </Method>
        <Method selector="isInterface">
          <Source>isInterface

	&lt;get_property: 'System.Type' IsInterface 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsInterface</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNested">
          <Source>isNested

	&lt;get_property: 'System.Type' IsNested 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNested</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedAssembly">
          <Source>isNestedAssembly

	&lt;get_property: 'System.Type' IsNestedAssembly 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedAssembly</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedFamily">
          <Source>isNestedFamily

	&lt;get_property: 'System.Type' IsNestedFamily 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedFamily</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedPublic">
          <Source>isNestedPublic

	&lt;get_property: 'System.Type' IsNestedPublic 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedPublic</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedPrivate">
          <Source>isNestedPrivate

	&lt;get_property: 'System.Type' IsNestedPrivate 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedPrivate</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedFamORAssem">
          <Source>isNestedFamORAssem

	&lt;get_property: 'System.Type' IsNestedFamORAssem 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedFamORAssem</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNotPublic">
          <Source>isNotPublic

	&lt;get_property: 'System.Type' IsNotPublic 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNotPublic</Annotation>
          </Annotations>
        </Method>
        <Method selector="isPointer">
          <Source>isPointer

	&lt;get_property: 'System.Type' IsPointer 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsPointer</Annotation>
          </Annotations>
        </Method>
        <Method selector="isPrimitive">
          <Source>isPrimitive

	&lt;get_property: 'System.Type' IsPrimitive 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsPrimitive</Annotation>
          </Annotations>
        </Method>
        <Method selector="isPublic">
          <Source>isPublic

	&lt;get_property: 'System.Type' IsPublic 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsPublic</Annotation>
          </Annotations>
        </Method>
        <Method selector="isSealed">
          <Source>isSealed

	&lt;get_property: 'System.Type' IsSealed 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsSealed</Annotation>
          </Annotations>
        </Method>
        <Method selector="isSerializable">
          <Source>isSerializable

	&lt;get_property: 'System.Type' IsSerializable 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsSerializable</Annotation>
          </Annotations>
        </Method>
        <Method selector="isSpecialName">
          <Source>isSpecialName

	&lt;get_property: 'System.Type' IsSpecialName 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsSpecialName</Annotation>
          </Annotations>
        </Method>
        <Method selector="isValueType">
          <Source>isValueType

	&lt;get_property: 'System.Type' IsValueType 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsValueType</Annotation>
          </Annotations>
        </Method>
        <Method selector="isVisible">
          <Source>isVisible

	&lt;get_property: 'System.Type' IsVisible 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsVisible</Annotation>
          </Annotations>
        </Method>
        <Method selector="name">
          <Source>name

	&lt;get_property: 'System.Type' Name 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Name</Annotation>
          </Annotations>
        </Method>
        <Method selector="namespace">
          <Source>namespace

	&lt;get_property: 'System.Type' Namespace 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Namespace</Annotation>
          </Annotations>
        </Method>
        <Method selector="isNestedFamANDAssem">
          <Source>isNestedFamANDAssem

	&lt;get_property: 'System.Type' IsNestedFamANDAssem 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNestedFamANDAssem</Annotation>
          </Annotations>
        </Method>
        <Method selector="isSubclassOf:">
          <Source>isSubclassOf: aType

	&lt;call: 'System.Type' IsSubclassOf this 'System.Type'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsSubclassOf</Annotation>
          </Annotations>
        </Method>
        <Method selector="getInterfaces">
          <Source>getInterfaces

	&lt;call: 'System.Type' GetInterfaces this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetInterfaces</Annotation>
          </Annotations>
        </Method>
        <Method selector="getInterface:">
          <Source>getInterface: name

	&lt;call: 'System.Type' GetInterface this string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetInterface</Annotation>
          </Annotations>
        </Method>
        <Method selector="getInterface:ignoreCase:">
          <Source>getInterface: name ignoreCase: ignoreCase 

	&lt;call: 'System.Type' GetInterface this string bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetInterface</Annotation>
          </Annotations>
        </Method>
        <Method selector="isAssignableFrom:">
          <Source>isAssignableFrom: aType

	&lt;call: 'System.Type' IsAssignableFrom this 'System.Type'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsAssignableFrom</Annotation>
          </Annotations>
        </Method>
        <Method selector="getGenericTypeDefinition">
          <Source>getGenericTypeDefinition 

	&lt;call: 'System.Type' GetGenericTypeDefinition this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetGenericTypeDefinition</Annotation>
          </Annotations>
        </Method>
        <Method selector="getDefaultMembers">
          <Source>getDefaultMembers

	&lt;call: 'System.Type' GetDefaultMembers this&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetDefaultMembers</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="delimiter">
          <Source>delimiter

	&lt;get_field: 'System.Type' Delimiter&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Delimiter</Annotation>
          </Annotations>
        </Method>
        <Method selector="emptyTypes">
          <Source>emptyTypes 

	&lt;get_field: 'System.Type' EmptyTypes&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">EmptyTypes</Annotation>
          </Annotations>
        </Method>
        <Method selector="missing">
          <Source>missing 

	&lt;get_field: 'System.Type' Missing&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Missing</Annotation>
          </Annotations>
        </Method>
        <Method selector="reflectionOnlyGetType:throwIfNotFound:ignoreCase:">
          <Source>reflectionOnlyGetType: typeName throwIfNotFound: throwIfNotFound ignoreCase: ignoreCase 

	&lt;static: 'System.Type' ReflectionOnlyGetType string bool bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">ReflectionOnlyGetType</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromProgID:server:throwOnError:">
          <Source>getTypeFromProgID: progID server: server throwOnError: throwOnError 

	&lt;static: 'System.Type' GetTypeFromProgID string string bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromProgID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromProgID:server:">
          <Source>getTypeFromProgID: progID server: server 

	&lt;static: 'System.Type' GetTypeFromProgID string string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromProgID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromProgID:throwOnError:">
          <Source>getTypeFromProgID: progID throwOnError: throwOnError 

	&lt;static: 'System.Type' GetTypeFromProgID string bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromProgID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromProgID:">
          <Source>getTypeFromProgID: progID 

	&lt;static: 'System.Type' GetTypeFromProgID string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromProgID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromCLSID:server:throwOnError:">
          <Source>getTypeFromCLSID: clsid server: server throwOnError: throwOnError 

	&lt;static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.String' 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromCLSID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromCLSID:server:">
          <Source>getTypeFromCLSID: clsid server: server 

	&lt;static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.String'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromCLSID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromCLSID:">
          <Source>getTypeFromCLSID: clsid  

	&lt;static: 'System.Type' GetTypeFromCLSID 'System.Guid'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromCLSID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeFromCLSID:throwOnError:">
          <Source>getTypeFromCLSID: clsid throwOnError: throwOnError 

	&lt;static: 'System.Type' GetTypeFromCLSID 'System.Guid' 'System.Boolean'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeFromCLSID</Annotation>
          </Annotations>
        </Method>
        <Method selector="getTypeCode:">
          <Source>getTypeCode: aType

	&lt;static: 'System.Type' GetTypeCode 'System.Type'&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetTypeCode</Annotation>
          </Annotations>
        </Method>
        <Method selector="getType:throwOnError:ignoreCase:">
          <Source>getType: typeName throwOnError: throwOnError ignoreCase: ignoreCase

	&lt;static: 'System.Type' GetType string bool bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetType</Annotation>
          </Annotations>
        </Method>
        <Method selector="getType:throwOnError:">
          <Source>getType: typeName throwOnError: throwOnError

	&lt;static: 'System.Type' GetType string bool&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetType</Annotation>
          </Annotations>
        </Method>
        <Method selector="getType:">
          <Source>getType: typeName 

	&lt;static: 'System.Type' GetType string&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">GetType</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">type</Annotation>
      </Annotations>
    </Class>
    <Global name="Transcript" definingProtocol="Transcript" type="constant">
      <ImplementedProtocols>
        <Protocol name="Transcript" />
      </ImplementedProtocols>
      <Initializer sortKey="17">
        <Source>Console " ... Console class implements the Transcript protocol "</Source>
      </Initializer>
      <Description>Conforms to the protocol &amp;lt;Transcript&amp;gt;. Its language element type is unspecified. This is a &amp;lt;Transcript&amp;gt; that is always available to output textual messages in an implementtion defined manner.</Description>
    </Global>
    <Class name="True" instanceState="native" definingProtocol="boolean" superclassName="Boolean">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="&amp;">
          <Source>&amp; operand

	^operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&amp;</Annotation>
          </Annotations>
        </Method>
        <Method selector="|">
          <Source>| operand

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">|</Annotation>
          </Annotations>
        </Method>
        <Method selector="and:">
          <Source>and: operand

	^operand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">And</Annotation>
          </Annotations>
        </Method>
        <Method selector="eqv:">
          <Source>eqv: operand

	^operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Eqv</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:">
          <Source>ifFalse: operand

	^nil.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifFalse:ifTrue:">
          <Source>ifFalse: falseOperand ifTrue: trueOperand

	^trueOperand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfFalse</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:ifFalse:">
          <Source>ifTrue: trueOperand ifFalse: falseOperand

	^trueOperand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="ifTrue:">
          <Source>ifTrue: operand

	^operand value.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IfTrue</Annotation>
          </Annotations>
        </Method>
        <Method selector="not">
          <Source>not

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Not</Annotation>
          </Annotations>
        </Method>
        <Method selector="or:">
          <Source>or: operand

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Or</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^'true'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="xor:">
          <Source>xor: operand

	^operand not.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Xor</Annotation>
          </Annotations>
        </Method>
        <Method selector="printOn:">
          <Source>printOn: target

	target nextPutAll: 'true'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintOn</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class">true</Annotation>
      </Annotations>
    </Class>
    <Class name="UInt16" instanceState="native" superclassName="UnsignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^120.</Source>
        </Method>
        <Method selector="asUInt16">
          <Source>asUInt16

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt16</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asUInt16.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.UInt16' 'System.UInt16'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.UInt16' 'System.UInt16'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt32.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.UInt16' 'System.UInt16'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.UInt16' 'System.UInt16'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.UInt16' 'System.UInt16'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.UInt16' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.UInt16' 'System.UInt16'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.UInt16' 'System.UInt16'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.UInt16' 'System.UInt16'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.UInt16' 'System.UInt16'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.UInt16' 'System.UInt16'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.UInt16' 'System.UInt16'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.UInt16' 'System.UInt16'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.UInt16' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.UInt16' 'System.UInt16'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.UInt16' 'System.UInt16'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.UInt16' 'System.UInt16'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.UInt16' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.UInt16' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="12">
        <Source>zero := 0 asUInt16.
one := 1 asUInt16.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.UInt16</Annotation>
      </Annotations>
    </Class>
    <Class name="UInt32" instanceState="native" superclassName="UnsignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^130.</Source>
        </Method>
        <Method selector="asUInt32">
          <Source>asUInt32

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt32</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asUInt32.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.UInt32' 'System.UInt32'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.UInt32' 'System.UInt32'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asInt64.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.UInt32' 'System.UInt32'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.UInt32' 'System.UInt32'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.UInt32' 'System.UInt32'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.UInt32' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.UInt32' 'System.UInt32'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.UInt32' 'System.UInt32'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.UInt32' 'System.UInt32'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.UInt32' 'System.UInt32'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.UInt32' 'System.UInt32'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.UInt32' 'System.UInt32'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.UInt32' 'System.UInt32'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.UInt32' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.UInt32' 'System.UInt32'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.UInt32' 'System.UInt32'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.UInt32' 'System.UInt32'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.UInt32' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.UInt32' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="13">
        <Source>zero := 0 asUInt32.
one := 1 asUInt32.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.UInt32</Annotation>
      </Annotations>
    </Class>
    <Class name="UInt64" instanceState="native" superclassName="UnsignedInteger">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="_coercionWeight">
          <Source>_coercionWeight
	" 
	Tells us how this number would like to convert to another number.
	Numbers with smaller weight will coerce to numbers with higher weight.
	"
	^140.</Source>
        </Method>
        <Method selector="asUInt64">
          <Source>asUInt64

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">AsUInt64</Annotation>
          </Annotations>
        </Method>
        <Method selector="_coerce:">
          <Source>_coerce: aNumber
	"
	Converts &lt;aNumber&gt; to the same class as the receiver. 
	"
	^aNumber asUInt64.</Source>
        </Method>
        <Method selector="=">
          <Source>= comparand

	&lt;primitive: IntegerEquals 'System.UInt64' 'System.UInt64'&gt;

	^super = comparand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;">
          <Source>&gt; operand

	&lt;primitive: IntegerGreatherThan 'System.UInt64' 'System.UInt64'&gt;

	^super &gt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="_asHigherPrecision">
          <Source>_asHigherPrecision

	^self asBigInteger.</Source>
        </Method>
        <Method selector="-">
          <Source>- operand

	&lt;primitive: IntegerSubtract 'System.UInt64' 'System.UInt64'&gt;

	^super - operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">-</Annotation>
          </Annotations>
        </Method>
        <Method selector="*">
          <Source>* operand

	&lt;primitive: IntegerMultiply 'System.UInt64' 'System.UInt64'&gt;

	^super * operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">*</Annotation>
          </Annotations>
        </Method>
        <Method selector="+">
          <Source>+ operand

	&lt;primitive: IntegerAdd 'System.UInt64' 'System.UInt64'&gt;

	^super + operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">+</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitShift:">
          <Source>bitShift: shift

	&lt;primitive: IntegerBitShift 'System.UInt64' 'System.Int32'&gt;

	^super bitShift: shift.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitShift</Annotation>
          </Annotations>
        </Method>
        <Method selector="&gt;=">
          <Source>&gt;= operand

	&lt;primitive: IntegerGreatherThanOrEqual 'System.UInt64' 'System.UInt64'&gt;

	^super &gt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&gt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;=">
          <Source>&lt;= operand

	&lt;primitive: IntegerLessThanOrEqual 'System.UInt64' 'System.UInt64'&gt;

	^super &lt;= operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;=</Annotation>
          </Annotations>
        </Method>
        <Method selector="&lt;">
          <Source>&lt; operand

	&lt;primitive: IntegerLessThan 'System.UInt64' 'System.UInt64'&gt;

	^super &lt; operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">&lt;</Annotation>
          </Annotations>
        </Method>
        <Method selector="//">
          <Source>// operand

	&lt;primitive: IntegerDivideFloor 'System.UInt64' 'System.UInt64'&gt;

	^super // operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">//</Annotation>
          </Annotations>
        </Method>
        <Method selector="\\">
          <Source>\\ operand

	&lt;primitive: IntegerRemainderFloor 'System.UInt64' 'System.UInt64'&gt;

	^super \\ operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">\\</Annotation>
          </Annotations>
        </Method>
        <Method selector="quo:">
          <Source>quo: operand

	&lt;primitive: IntegerDivideTruncate 'System.UInt64' 'System.UInt64'&gt;

	^super quo: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Quo</Annotation>
          </Annotations>
        </Method>
        <Method selector="rem:">
          <Source>rem: operand

	&lt;primitive: IntegerRemainderTruncate 'System.UInt64' 'System.UInt64'&gt;

	^super rem: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Rem</Annotation>
          </Annotations>
        </Method>
        <Method selector="_toString:formatProvider:">
          <Source>_toString: format formatProvider: formatProvider

	&lt;call: 'System.UInt64' ToString this 'System.String' 'System.IFormatProvider'&gt;</Source>
        </Method>
        <Method selector="bitAnd:">
          <Source>bitAnd: operand

	&lt;primitive: IntegerBitAnd 'System.UInt64' 'System.UInt64'&gt;

	^super bitAnd: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitAnd</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitOr:">
          <Source>bitOr: operand

	&lt;primitive: IntegerBitOr 'System.UInt64' 'System.UInt64'&gt;

	^super bitOr: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitOr</Annotation>
          </Annotations>
        </Method>
        <Method selector="bitXor:">
          <Source>bitXor: operand

	&lt;primitive: IntegerBitXor 'System.UInt64' 'System.UInt64'&gt;

	^super bitXor: operand.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">BitXor</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="min">
          <Source>min

	&lt;get_field: 'System.UInt64' MinValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Min</Annotation>
          </Annotations>
        </Method>
        <Method selector="max">
          <Source>max

	&lt;get_field: 'System.UInt64' MaxValue&gt;</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Max</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Initializer sortKey="14">
        <Source>zero := 0 asUInt64.
one := 1 asUInt64.</Source>
      </Initializer>
      <Annotations>
        <Annotation key="ist.runtime.native-class">System.UInt64</Annotation>
      </Annotations>
    </Class>
    <Class name="UndefinedObject" instanceState="namedObjectVariables" superclassName="Object">
      <ImplementedInstanceProtocols>
        <Protocol name="nil" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isNil">
          <Source>isNil

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsNil</Annotation>
          </Annotations>
        </Method>
        <Method selector="notNil">
          <Source>notNil

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">NotNil</Annotation>
          </Annotations>
        </Method>
        <Method selector="hash">
          <Source>hash

	^19761214.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Hash</Annotation>
          </Annotations>
        </Method>
        <Method selector="identityHash">
          <Source>identityHash

	^19761214.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IdentityHash</Annotation>
          </Annotations>
        </Method>
        <Method selector="copy">
          <Source>copy

	^self.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Copy</Annotation>
          </Annotations>
        </Method>
        <Method selector="printString">
          <Source>printString

	^'nil'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintString</Annotation>
          </Annotations>
        </Method>
        <Method selector="printOn:">
          <Source>printOn: target

	target nextPutAll: 'nil'.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">PrintOn</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods>
        <Method selector="new">
          <Source>new

	^self invalidMessage.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">New</Annotation>
          </Annotations>
        </Method>
      </ClassMethods>
      <Annotations>
        <Annotation key="ist.runtime.native-class">nil</Annotation>
      </Annotations>
    </Class>
    <Class name="UnsignedInteger" instanceState="namedObjectVariables" superclassName="Integer">
      <ImplementedInstanceProtocols />
      <ImplementedClassProtocols />
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="negative">
          <Source>negative

	^false.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Negative</Annotation>
          </Annotations>
        </Method>
        <Method selector="positive">
          <Source>positive

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Positive</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
    <Class name="Warning" instanceState="namedObjectVariables" definingProtocol="Warning class" superclassName="Notification">
      <ImplementedInstanceProtocols>
        <Protocol name="Warning" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="Warning class" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>A class name. Conforms to the protocol &amp;lt;Warning class&amp;gt;. &lt;CODE&gt;Warning&lt;/CODE&gt; must inherit (possibly indirectly) from the class &lt;CODE&gt;Notification&lt;/CODE&gt; . Instances of this class conform to the protocol &amp;lt;Warning&amp;gt;.</Description>
    </Class>
    <Class name="WriteStream" instanceState="namedObjectVariables" definingProtocol="WriteStream factory" superclassName="AbstractStream">
      <ImplementedInstanceProtocols>
        <Protocol name="collectionStream" />
        <Protocol name="puttableStream" />
        <Protocol name="WriteStream" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="WriteStream factory" />
      </ImplementedClassProtocols>
      <InstanceVariables />
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods />
      <ClassMethods />
      <Description>Conforms to the protocol &amp;lt;WriteStream factory &amp;gt;. Its language element type is unspecified. This is a factory for streams that conform to &amp;lt;WriteStream&amp;gt;.</Description>
    </Class>
    <Class name="ZeroDivide" instanceState="namedObjectVariables" definingProtocol="ZeroDivide factory" superclassName="Error">
      <ImplementedInstanceProtocols>
        <Protocol name="ZeroDivide" />
      </ImplementedInstanceProtocols>
      <ImplementedClassProtocols>
        <Protocol name="ZeroDivide factory" />
      </ImplementedClassProtocols>
      <InstanceVariables>
        <Variable name="dividend" />
      </InstanceVariables>
      <ClassVariables />
      <ClassInstanceVariables />
      <SharedPools />
      <InstanceMethods>
        <Method selector="isResumable">
          <Source>isResumable

	^true.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">IsResumable</Annotation>
          </Annotations>
        </Method>
        <Method selector="dividend">
          <Source>dividend

	^dividend.</Source>
          <Annotations>
            <Annotation key="ist.runtime.native-name">Dividend</Annotation>
          </Annotations>
        </Method>
      </InstanceMethods>
      <ClassMethods />
      <Description>Unspecified language element type. Conforms to the protocol &amp;lt;ZeroDivide class&amp;gt;.</Description>
      <Annotations>
        <Annotation key="ist.runtime.native-class"></Annotation>
      </Annotations>
    </Class>
  </SystemImplementation>
</SmalltalkSystem>